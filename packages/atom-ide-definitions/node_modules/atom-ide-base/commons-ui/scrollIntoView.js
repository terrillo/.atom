"use strict";
/* globals getComputedStyle */
Object.defineProperty(exports, "__esModule", { value: true });
exports.isOverflowHidden = exports.scrollIntoViewIfNeeded = exports.scrollIntoView = void 0;
/**
 * Use these functions instead of `Element::scrollIntoView()` and
 * `Element::scrollIntoViewIfNeeded()`!
 *
 * We've had a recurring issue in Nuclide (e.g. T20028138) where the UI would shift, leaving part of
 * the workspace element offscreen and a blank area in the window. This was caused by called to the
 * native `scrollIntoView()` and `scrollIntoViewIfNeeded()` which, according to the spec, has two
 * potentially surprising behaviors:
 *
 * 1. [It scrolls every scrollable ancestor (not just the closest)][1], where
 * 2. "scrollable" is [explicitly defined][2] to include elements with `overflow: hidden`
 *
 * This is surprising because `overflow: hidden` is typically used to make elements *not
 * scrollable*.
 *
 * Once the `overflow: hidden` element is scrolled, the user has no way to return it to its original
 * position (as it has no scrollbars).
 *
 * Note that this API doesn't support smooth scrolling. If that becomes necessary, we'll need to
 * come up with a better fix.
 *
 * It's tempting to assume that using `scrollIntoViewIfNeeded()` would fix this issue, however, if
 * the window is small enough so that no amount of scrolling the desired scrollable element would
 * ever reveal the element you're trying to, the browser will keep scrolling ancestors.
 *
 * [1]: https://drafts.csswg.org/cssom-view/#element-scrolling-members
 * [2]: https://drafts.csswg.org/cssom-view/#scrolling-box
 */
function scrollIntoView(el, alignToTop) {
    const scrollTops = getScrollTops(el);
    el.scrollIntoView(alignToTop);
    restoreOverflowHiddenScrollTops(scrollTops);
}
exports.scrollIntoView = scrollIntoView;
function scrollIntoViewIfNeeded(el, center = true) {
    var _a, _b, _c;
    const scrollTops = getScrollTops(el);
    (_c = (_b = (_a = el).scrollIntoViewIfNeeded) === null || _b === void 0 ? void 0 : _b.call(_a, center)) !== null && _c !== void 0 ? _c : el.scrollIntoView(center);
    restoreOverflowHiddenScrollTops(scrollTops);
}
exports.scrollIntoViewIfNeeded = scrollIntoViewIfNeeded;
function getScrollTops(el_) {
    let el = el_;
    const scrollTops = new Map();
    while (el !== null) {
        scrollTops.set(el, el.scrollTop);
        el = el.parentElement;
    }
    return scrollTops;
}
function restoreOverflowHiddenScrollTops(scrollTops) {
    scrollTops.forEach((scrollTop, el) => {
        if (el.scrollTop !== scrollTop && isOverflowHidden(el)) {
            el.scrollTop = scrollTop;
        }
    });
}
function isOverflowHidden(el) {
    var _a;
    const overflowStyle = (_a = el) === null || _a === void 0 ? void 0 : _a.style.overflow;
    const overflow = overflowStyle !== null && overflowStyle !== void 0 ? overflowStyle : getComputedStyle(el).overflow;
    return overflow === "hidden";
}
exports.isOverflowHidden = isOverflowHidden;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2Nyb2xsSW50b1ZpZXcuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMtY29tbW9ucy11aS9zY3JvbGxJbnRvVmlldy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsOEJBQThCOzs7QUFFOUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTJCRztBQUVILFNBQWdCLGNBQWMsQ0FBQyxFQUFXLEVBQUUsVUFBb0I7SUFDOUQsTUFBTSxVQUFVLEdBQUcsYUFBYSxDQUFDLEVBQUUsQ0FBQyxDQUFBO0lBQ3BDLEVBQUUsQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDLENBQUE7SUFDN0IsK0JBQStCLENBQUMsVUFBVSxDQUFDLENBQUE7QUFDN0MsQ0FBQztBQUpELHdDQUlDO0FBSUQsU0FBZ0Isc0JBQXNCLENBQUMsRUFBVyxFQUFFLFNBQWtCLElBQUk7O0lBQ3hFLE1BQU0sVUFBVSxHQUFHLGFBQWEsQ0FBQyxFQUFFLENBQUMsQ0FFbkM7SUFBQSxNQUFBLE1BQUEsTUFBQyxFQUFzQixFQUFDLHNCQUFzQixtREFBRyxNQUFNLENBQUMsbUNBQUksRUFBRSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsQ0FBQTtJQUN0RiwrQkFBK0IsQ0FBQyxVQUFVLENBQUMsQ0FBQTtBQUM3QyxDQUFDO0FBTEQsd0RBS0M7QUFFRCxTQUFTLGFBQWEsQ0FBQyxHQUFZO0lBQ2pDLElBQUksRUFBRSxHQUFtQixHQUFHLENBQUE7SUFDNUIsTUFBTSxVQUFVLEdBQUcsSUFBSSxHQUFHLEVBQW1CLENBQUE7SUFDN0MsT0FBTyxFQUFFLEtBQUssSUFBSSxFQUFFO1FBQ2xCLFVBQVUsQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxTQUFTLENBQUMsQ0FBQTtRQUNoQyxFQUFFLEdBQUcsRUFBRSxDQUFDLGFBQWEsQ0FBQTtLQUN0QjtJQUNELE9BQU8sVUFBVSxDQUFBO0FBQ25CLENBQUM7QUFFRCxTQUFTLCtCQUErQixDQUFDLFVBQWdDO0lBQ3ZFLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxTQUFTLEVBQUUsRUFBRSxFQUFFLEVBQUU7UUFDbkMsSUFBSSxFQUFFLENBQUMsU0FBUyxLQUFLLFNBQVMsSUFBSSxnQkFBZ0IsQ0FBQyxFQUFFLENBQUMsRUFBRTtZQUN0RCxFQUFFLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQTtTQUN6QjtJQUNILENBQUMsQ0FBQyxDQUFBO0FBQ0osQ0FBQztBQUVELFNBQWdCLGdCQUFnQixDQUFDLEVBQXNDOztJQUNyRSxNQUFNLGFBQWEsR0FBRyxNQUFDLEVBQWtCLDBDQUFFLEtBQUssQ0FBQyxRQUFRLENBQUE7SUFDekQsTUFBTSxRQUFRLEdBQUcsYUFBYSxhQUFiLGFBQWEsY0FBYixhQUFhLEdBQUksZ0JBQWdCLENBQUMsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFBO0lBQy9ELE9BQU8sUUFBUSxLQUFLLFFBQVEsQ0FBQTtBQUM5QixDQUFDO0FBSkQsNENBSUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWxzIGdldENvbXB1dGVkU3R5bGUgKi9cblxuLyoqXG4gKiBVc2UgdGhlc2UgZnVuY3Rpb25zIGluc3RlYWQgb2YgYEVsZW1lbnQ6OnNjcm9sbEludG9WaWV3KClgIGFuZFxuICogYEVsZW1lbnQ6OnNjcm9sbEludG9WaWV3SWZOZWVkZWQoKWAhXG4gKlxuICogV2UndmUgaGFkIGEgcmVjdXJyaW5nIGlzc3VlIGluIE51Y2xpZGUgKGUuZy4gVDIwMDI4MTM4KSB3aGVyZSB0aGUgVUkgd291bGQgc2hpZnQsIGxlYXZpbmcgcGFydCBvZlxuICogdGhlIHdvcmtzcGFjZSBlbGVtZW50IG9mZnNjcmVlbiBhbmQgYSBibGFuayBhcmVhIGluIHRoZSB3aW5kb3cuIFRoaXMgd2FzIGNhdXNlZCBieSBjYWxsZWQgdG8gdGhlXG4gKiBuYXRpdmUgYHNjcm9sbEludG9WaWV3KClgIGFuZCBgc2Nyb2xsSW50b1ZpZXdJZk5lZWRlZCgpYCB3aGljaCwgYWNjb3JkaW5nIHRvIHRoZSBzcGVjLCBoYXMgdHdvXG4gKiBwb3RlbnRpYWxseSBzdXJwcmlzaW5nIGJlaGF2aW9yczpcbiAqXG4gKiAxLiBbSXQgc2Nyb2xscyBldmVyeSBzY3JvbGxhYmxlIGFuY2VzdG9yIChub3QganVzdCB0aGUgY2xvc2VzdCldWzFdLCB3aGVyZVxuICogMi4gXCJzY3JvbGxhYmxlXCIgaXMgW2V4cGxpY2l0bHkgZGVmaW5lZF1bMl0gdG8gaW5jbHVkZSBlbGVtZW50cyB3aXRoIGBvdmVyZmxvdzogaGlkZGVuYFxuICpcbiAqIFRoaXMgaXMgc3VycHJpc2luZyBiZWNhdXNlIGBvdmVyZmxvdzogaGlkZGVuYCBpcyB0eXBpY2FsbHkgdXNlZCB0byBtYWtlIGVsZW1lbnRzICpub3RcbiAqIHNjcm9sbGFibGUqLlxuICpcbiAqIE9uY2UgdGhlIGBvdmVyZmxvdzogaGlkZGVuYCBlbGVtZW50IGlzIHNjcm9sbGVkLCB0aGUgdXNlciBoYXMgbm8gd2F5IHRvIHJldHVybiBpdCB0byBpdHMgb3JpZ2luYWxcbiAqIHBvc2l0aW9uIChhcyBpdCBoYXMgbm8gc2Nyb2xsYmFycykuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgQVBJIGRvZXNuJ3Qgc3VwcG9ydCBzbW9vdGggc2Nyb2xsaW5nLiBJZiB0aGF0IGJlY29tZXMgbmVjZXNzYXJ5LCB3ZSdsbCBuZWVkIHRvXG4gKiBjb21lIHVwIHdpdGggYSBiZXR0ZXIgZml4LlxuICpcbiAqIEl0J3MgdGVtcHRpbmcgdG8gYXNzdW1lIHRoYXQgdXNpbmcgYHNjcm9sbEludG9WaWV3SWZOZWVkZWQoKWAgd291bGQgZml4IHRoaXMgaXNzdWUsIGhvd2V2ZXIsIGlmXG4gKiB0aGUgd2luZG93IGlzIHNtYWxsIGVub3VnaCBzbyB0aGF0IG5vIGFtb3VudCBvZiBzY3JvbGxpbmcgdGhlIGRlc2lyZWQgc2Nyb2xsYWJsZSBlbGVtZW50IHdvdWxkXG4gKiBldmVyIHJldmVhbCB0aGUgZWxlbWVudCB5b3UncmUgdHJ5aW5nIHRvLCB0aGUgYnJvd3NlciB3aWxsIGtlZXAgc2Nyb2xsaW5nIGFuY2VzdG9ycy5cbiAqXG4gKiBbMV06IGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS12aWV3LyNlbGVtZW50LXNjcm9sbGluZy1tZW1iZXJzXG4gKiBbMl06IGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS12aWV3LyNzY3JvbGxpbmctYm94XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjcm9sbEludG9WaWV3KGVsOiBFbGVtZW50LCBhbGlnblRvVG9wPzogYm9vbGVhbik6IHZvaWQge1xuICBjb25zdCBzY3JvbGxUb3BzID0gZ2V0U2Nyb2xsVG9wcyhlbClcbiAgZWwuc2Nyb2xsSW50b1ZpZXcoYWxpZ25Ub1RvcClcbiAgcmVzdG9yZU92ZXJmbG93SGlkZGVuU2Nyb2xsVG9wcyhzY3JvbGxUb3BzKVxufVxuXG5leHBvcnQgdHlwZSBFbGVtZW50RXh0ZW5kZWQgPSBFbGVtZW50ICYgeyBzY3JvbGxJbnRvVmlld0lmTmVlZGVkPzogKHNob3VsZENlbnRlcjogYm9vbGVhbikgPT4gdm9pZCB9XG5cbmV4cG9ydCBmdW5jdGlvbiBzY3JvbGxJbnRvVmlld0lmTmVlZGVkKGVsOiBFbGVtZW50LCBjZW50ZXI6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XG4gIGNvbnN0IHNjcm9sbFRvcHMgPSBnZXRTY3JvbGxUb3BzKGVsKVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG4gIDsoZWwgYXMgRWxlbWVudEV4dGVuZGVkKS5zY3JvbGxJbnRvVmlld0lmTmVlZGVkPy4oY2VudGVyKSA/PyBlbC5zY3JvbGxJbnRvVmlldyhjZW50ZXIpXG4gIHJlc3RvcmVPdmVyZmxvd0hpZGRlblNjcm9sbFRvcHMoc2Nyb2xsVG9wcylcbn1cblxuZnVuY3Rpb24gZ2V0U2Nyb2xsVG9wcyhlbF86IEVsZW1lbnQpOiBNYXA8RWxlbWVudCwgbnVtYmVyPiB7XG4gIGxldCBlbDogRWxlbWVudCB8IG51bGwgPSBlbF9cbiAgY29uc3Qgc2Nyb2xsVG9wcyA9IG5ldyBNYXA8RWxlbWVudCwgbnVtYmVyPigpXG4gIHdoaWxlIChlbCAhPT0gbnVsbCkge1xuICAgIHNjcm9sbFRvcHMuc2V0KGVsLCBlbC5zY3JvbGxUb3ApXG4gICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50XG4gIH1cbiAgcmV0dXJuIHNjcm9sbFRvcHNcbn1cblxuZnVuY3Rpb24gcmVzdG9yZU92ZXJmbG93SGlkZGVuU2Nyb2xsVG9wcyhzY3JvbGxUb3BzOiBNYXA8RWxlbWVudCwgbnVtYmVyPik6IHZvaWQge1xuICBzY3JvbGxUb3BzLmZvckVhY2goKHNjcm9sbFRvcCwgZWwpID0+IHtcbiAgICBpZiAoZWwuc2Nyb2xsVG9wICE9PSBzY3JvbGxUb3AgJiYgaXNPdmVyZmxvd0hpZGRlbihlbCkpIHtcbiAgICAgIGVsLnNjcm9sbFRvcCA9IHNjcm9sbFRvcFxuICAgIH1cbiAgfSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzT3ZlcmZsb3dIaWRkZW4oZWw6IEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudCB8IEVsZW1lbnQpOiBib29sZWFuIHtcbiAgY29uc3Qgb3ZlcmZsb3dTdHlsZSA9IChlbCBhcyBIVE1MRWxlbWVudCk/LnN0eWxlLm92ZXJmbG93XG4gIGNvbnN0IG92ZXJmbG93ID0gb3ZlcmZsb3dTdHlsZSA/PyBnZXRDb21wdXRlZFN0eWxlKGVsKS5vdmVyZmxvd1xuICByZXR1cm4gb3ZlcmZsb3cgPT09IFwiaGlkZGVuXCJcbn1cbiJdfQ==