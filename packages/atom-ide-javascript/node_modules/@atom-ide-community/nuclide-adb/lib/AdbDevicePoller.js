"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.observeAndroidDevices = observeAndroidDevices;
exports.adbDeviceForIdentifier = adbDeviceForIdentifier;

var _log4js = require("log4js");

var _collection = require("@atom-ide-community/nuclide-commons/collection");

var _SimpleCache = require("@atom-ide-community/nuclide-commons/SimpleCache");

var _shallowequal = _interopRequireDefault(require("shallowequal"));

var _rxjsCompatUmdMin = require("rxjs-compat/bundles/rxjs-compat.umd.min.js");

var _expected = require("@atom-ide-community/nuclide-commons/expected");

var _nuclideUri = _interopRequireDefault(require("@atom-ide-community/nuclide-commons/nuclideUri"));

var _analytics = require("@atom-ide-community/nuclide-commons/analytics");

var _utils = require("./utils");

var _passesGK = _interopRequireDefault(require("@atom-ide-community/nuclide-commons/passesGK"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */
function observeAndroidDevices(host) {
  const serviceUri = _nuclideUri.default.isRemote(host) ? _nuclideUri.default.createRemoteUri(_nuclideUri.default.getHostname(host), '/') : '';
  return pollersForUris.getOrCreate(serviceUri, () => {
    return _rxjsCompatUmdMin.Observable.defer(() => (0, _passesGK.default)('nuclide_device_panel_use_adb_track_devices')).concatMap(useTrackDevices => useTrackDevices ? observeDevicesViaTrackDevices(serviceUri) : observeDevicesViaPolling(serviceUri)).distinctUntilChanged((a, b) => (0, _expected.expectedEqual)(a, b, (v1, v2) => (0, _collection.arrayEqual)(v1, v2, _shallowequal.default), (e1, e2) => e1.message === e2.message)).do(async value => {
      if (value.isError) {
        const {
          error
        } = value;
        const logger = (0, _log4js.getLogger)('@atom-ide-community/nuclide-adb');
        let extras = {
          error
        };

        try {
          if ( // $FlowIgnore
          error.originalError != null && // $FlowIgnore
          error.originalError.code === 'ENOENT') {
            const infoService = await getInfoServiceByNuclideUri(serviceUri);

            if (infoService != null) {
              const rpcEnv = infoService.getServerEnvironment();
              extras = { ...extras,
                pathEnv: rpcEnv.PATH
              };
            }
          }
        } finally {
          logger.warn(value.error.message);
          (0, _analytics.track)('@atom-ide-community/nuclide-adb:device-poller:error', extras);
        }
      }
    }).publishReplay(1).refCount();
  });
}

function convertErrorToValue(error) {
  let message; // $FlowFixMe error.code

  if (error.code === 'ENOENT') {
    message = "'adb' not found in $PATH.";
  } else if ( // RPC call timed out
  error.name === 'RpcTimeoutError' || // RPC call succeeded, but the adb call itself timed out
  error.message === 'Timeout has occurred') {
    message = 'Request timed out, retrying...';
  } else if (error.message === 'Connection Closed') {
    return _rxjsCompatUmdMin.Observable.of(_expected.Expect.pending());
  } else {
    message = error.message;
  }

  const newError = new Error("Can't fetch Android devices. " + message); // $FlowIgnore

  newError.originalError = error;
  return _rxjsCompatUmdMin.Observable.of(_expected.Expect.error(newError));
}

function observeDevicesViaPolling(serviceUri) {
  return _rxjsCompatUmdMin.Observable.interval(2000).startWith(0).exhaustMap(() => {
    const service = (0, _utils.getAdbServiceByNuclideUri)(serviceUri);

    if (service == null) {
      // Gracefully handle a lost remote connection
      return _rxjsCompatUmdMin.Observable.of(_expected.Expect.pending());
    }

    return _rxjsCompatUmdMin.Observable.fromPromise(service.getDeviceList()).map(devices => _expected.Expect.value(devices)).catch(error => convertErrorToValue(error));
  });
}

function observeDevicesViaTrackDevices(serviceUri) {
  return _rxjsCompatUmdMin.Observable.defer(() => {
    const service = (0, _utils.getAdbServiceByNuclideUri)(serviceUri);

    if (service == null) {
      // Gracefully handle a lost remote connection
      return _rxjsCompatUmdMin.Observable.of(_expected.Expect.pending());
    }

    return service.trackDevices().refCount().map(devices => _expected.Expect.value(devices)).catch(error => convertErrorToValue(error));
  }) // If the process ever exits, retry after 5s
  // $FlowFixMe repeatWhen
  .repeatWhen(notifications => notifications.delay(5000)) // Also, never complete this observable, so we don't switch to a new observable
  // if the process exits, which would invalidate later caching (distinctUntilChanged/publishReplay)
  .merge(_rxjsCompatUmdMin.Observable.never());
}

function getInfoServiceByNuclideUri(uri) {
  let rpcService = null; // Atom's service hub is synchronous.

  atom.packages.serviceHub.consume('nuclide-rpc-services', '0.0.0', provider => {
    rpcService = provider;
  }).dispose();

  if (rpcService == null) {
    return null;
  }

  return rpcService.getServiceByNuclideUri('InfoService', uri);
} // This is a convenient way for any device panel plugins of type Android to get from Device to
// to the strongly typed AdbDevice.


async function adbDeviceForIdentifier(host, identifier) {
  const devices = await observeAndroidDevices(host).take(1).toPromise();
  return devices.getOrDefault([]).find(d => d.serial === identifier);
}

const pollersForUris = new _SimpleCache.SimpleCache();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL251Y2xpZGUvbnVjbGlkZS1hZGIvbGliL0FkYkRldmljZVBvbGxlci5qcyJdLCJuYW1lcyI6WyJvYnNlcnZlQW5kcm9pZERldmljZXMiLCJob3N0Iiwic2VydmljZVVyaSIsIm51Y2xpZGVVcmkiLCJpc1JlbW90ZSIsImNyZWF0ZVJlbW90ZVVyaSIsImdldEhvc3RuYW1lIiwicG9sbGVyc0ZvclVyaXMiLCJnZXRPckNyZWF0ZSIsIk9ic2VydmFibGUiLCJkZWZlciIsImNvbmNhdE1hcCIsInVzZVRyYWNrRGV2aWNlcyIsIm9ic2VydmVEZXZpY2VzVmlhVHJhY2tEZXZpY2VzIiwib2JzZXJ2ZURldmljZXNWaWFQb2xsaW5nIiwiZGlzdGluY3RVbnRpbENoYW5nZWQiLCJhIiwiYiIsInYxIiwidjIiLCJzaGFsbG93RXF1YWwiLCJlMSIsImUyIiwibWVzc2FnZSIsImRvIiwidmFsdWUiLCJpc0Vycm9yIiwiZXJyb3IiLCJsb2dnZXIiLCJleHRyYXMiLCJvcmlnaW5hbEVycm9yIiwiY29kZSIsImluZm9TZXJ2aWNlIiwiZ2V0SW5mb1NlcnZpY2VCeU51Y2xpZGVVcmkiLCJycGNFbnYiLCJnZXRTZXJ2ZXJFbnZpcm9ubWVudCIsInBhdGhFbnYiLCJQQVRIIiwid2FybiIsInB1Ymxpc2hSZXBsYXkiLCJyZWZDb3VudCIsImNvbnZlcnRFcnJvclRvVmFsdWUiLCJuYW1lIiwib2YiLCJFeHBlY3QiLCJwZW5kaW5nIiwibmV3RXJyb3IiLCJFcnJvciIsImludGVydmFsIiwic3RhcnRXaXRoIiwiZXhoYXVzdE1hcCIsInNlcnZpY2UiLCJmcm9tUHJvbWlzZSIsImdldERldmljZUxpc3QiLCJtYXAiLCJkZXZpY2VzIiwiY2F0Y2giLCJ0cmFja0RldmljZXMiLCJyZXBlYXRXaGVuIiwibm90aWZpY2F0aW9ucyIsImRlbGF5IiwibWVyZ2UiLCJuZXZlciIsInVyaSIsInJwY1NlcnZpY2UiLCJhdG9tIiwicGFja2FnZXMiLCJzZXJ2aWNlSHViIiwiY29uc3VtZSIsInByb3ZpZGVyIiwiZGlzcG9zZSIsImdldFNlcnZpY2VCeU51Y2xpZGVVcmkiLCJhZGJEZXZpY2VGb3JJZGVudGlmaWVyIiwiaWRlbnRpZmllciIsInRha2UiLCJ0b1Byb21pc2UiLCJnZXRPckRlZmF1bHQiLCJmaW5kIiwiZCIsInNlcmlhbCIsIlNpbXBsZUNhY2hlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQWdCQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQXpCQTs7Ozs7Ozs7Ozs7QUEyQk8sU0FBU0EscUJBQVQsQ0FDTEMsSUFESyxFQUVtQztBQUN4QyxRQUFNQyxVQUFVLEdBQUdDLG9CQUFXQyxRQUFYLENBQW9CSCxJQUFwQixJQUNmRSxvQkFBV0UsZUFBWCxDQUEyQkYsb0JBQVdHLFdBQVgsQ0FBdUJMLElBQXZCLENBQTNCLEVBQXlELEdBQXpELENBRGUsR0FFZixFQUZKO0FBR0EsU0FBT00sY0FBYyxDQUFDQyxXQUFmLENBQTJCTixVQUEzQixFQUF1QyxNQUFNO0FBQ2xELFdBQU9PLDZCQUFXQyxLQUFYLENBQWlCLE1BQ3RCLHVCQUFTLDRDQUFULENBREssRUFHSkMsU0FISSxDQUlIQyxlQUFlLElBQ2JBLGVBQWUsR0FDWEMsNkJBQTZCLENBQUNYLFVBQUQsQ0FEbEIsR0FFWFksd0JBQXdCLENBQUNaLFVBQUQsQ0FQM0IsRUFTSmEsb0JBVEksQ0FTaUIsQ0FBQ0MsQ0FBRCxFQUFJQyxDQUFKLEtBQ3BCLDZCQUNFRCxDQURGLEVBRUVDLENBRkYsRUFHRSxDQUFDQyxFQUFELEVBQUtDLEVBQUwsS0FBWSw0QkFBV0QsRUFBWCxFQUFlQyxFQUFmLEVBQW1CQyxxQkFBbkIsQ0FIZCxFQUlFLENBQUNDLEVBQUQsRUFBS0MsRUFBTCxLQUFZRCxFQUFFLENBQUNFLE9BQUgsS0FBZUQsRUFBRSxDQUFDQyxPQUpoQyxDQVZHLEVBaUJKQyxFQWpCSSxDQWlCRCxNQUFNQyxLQUFOLElBQWU7QUFDakIsVUFBSUEsS0FBSyxDQUFDQyxPQUFWLEVBQW1CO0FBQ2pCLGNBQU07QUFBQ0MsVUFBQUE7QUFBRCxZQUFVRixLQUFoQjtBQUNBLGNBQU1HLE1BQU0sR0FBRyx1QkFBVSxpQ0FBVixDQUFmO0FBQ0EsWUFBSUMsTUFBTSxHQUFHO0FBQUNGLFVBQUFBO0FBQUQsU0FBYjs7QUFDQSxZQUFJO0FBQ0YsZUFDRTtBQUNDQSxVQUFBQSxLQUFELENBQWFHLGFBQWIsSUFBOEIsSUFBOUIsSUFDQTtBQUNDSCxVQUFBQSxLQUFELENBQWFHLGFBQWIsQ0FBMkJDLElBQTNCLEtBQW9DLFFBSnRDLEVBS0U7QUFDQSxrQkFBTUMsV0FBVyxHQUFHLE1BQU1DLDBCQUEwQixDQUFDL0IsVUFBRCxDQUFwRDs7QUFDQSxnQkFBSThCLFdBQVcsSUFBSSxJQUFuQixFQUF5QjtBQUN2QixvQkFBTUUsTUFBTSxHQUFHRixXQUFXLENBQUNHLG9CQUFaLEVBQWY7QUFDQU4sY0FBQUEsTUFBTSxHQUFHLEVBQUMsR0FBR0EsTUFBSjtBQUFZTyxnQkFBQUEsT0FBTyxFQUFFRixNQUFNLENBQUNHO0FBQTVCLGVBQVQ7QUFDRDtBQUNGO0FBQ0YsU0FiRCxTQWFVO0FBQ1JULFVBQUFBLE1BQU0sQ0FBQ1UsSUFBUCxDQUFZYixLQUFLLENBQUNFLEtBQU4sQ0FBWUosT0FBeEI7QUFDQSxnQ0FBTSxxREFBTixFQUE2RE0sTUFBN0Q7QUFDRDtBQUNGO0FBQ0YsS0F4Q0ksRUF5Q0pVLGFBekNJLENBeUNVLENBekNWLEVBMENKQyxRQTFDSSxFQUFQO0FBMkNELEdBNUNNLENBQVA7QUE2Q0Q7O0FBRUQsU0FBU0MsbUJBQVQsQ0FDRWQsS0FERixFQUUwQztBQUN4QyxNQUFJSixPQUFKLENBRHdDLENBRXhDOztBQUNBLE1BQUlJLEtBQUssQ0FBQ0ksSUFBTixLQUFlLFFBQW5CLEVBQTZCO0FBQzNCUixJQUFBQSxPQUFPLEdBQUcsMkJBQVY7QUFDRCxHQUZELE1BRU8sS0FDTDtBQUNBSSxFQUFBQSxLQUFLLENBQUNlLElBQU4sS0FBZSxpQkFBZixJQUNBO0FBQ0FmLEVBQUFBLEtBQUssQ0FBQ0osT0FBTixLQUFrQixzQkFKYixFQUtMO0FBQ0FBLElBQUFBLE9BQU8sR0FBRyxnQ0FBVjtBQUNELEdBUE0sTUFPQSxJQUFJSSxLQUFLLENBQUNKLE9BQU4sS0FBa0IsbUJBQXRCLEVBQTJDO0FBQ2hELFdBQU9kLDZCQUFXa0MsRUFBWCxDQUFjQyxpQkFBT0MsT0FBUCxFQUFkLENBQVA7QUFDRCxHQUZNLE1BRUE7QUFDTHRCLElBQUFBLE9BQU8sR0FBR0ksS0FBSyxDQUFDSixPQUFoQjtBQUNEOztBQUNELFFBQU11QixRQUFRLEdBQUcsSUFBSUMsS0FBSixDQUFVLGtDQUFrQ3hCLE9BQTVDLENBQWpCLENBakJ3QyxDQWtCeEM7O0FBQ0N1QixFQUFBQSxRQUFELENBQWdCaEIsYUFBaEIsR0FBZ0NILEtBQWhDO0FBQ0EsU0FBT2xCLDZCQUFXa0MsRUFBWCxDQUFjQyxpQkFBT2pCLEtBQVAsQ0FBYW1CLFFBQWIsQ0FBZCxDQUFQO0FBQ0Q7O0FBRUQsU0FBU2hDLHdCQUFULENBQ0VaLFVBREYsRUFFMEM7QUFDeEMsU0FBT08sNkJBQVd1QyxRQUFYLENBQW9CLElBQXBCLEVBQ0pDLFNBREksQ0FDTSxDQUROLEVBRUpDLFVBRkksQ0FFTyxNQUFNO0FBQ2hCLFVBQU1DLE9BQU8sR0FBRyxzQ0FBMEJqRCxVQUExQixDQUFoQjs7QUFDQSxRQUFJaUQsT0FBTyxJQUFJLElBQWYsRUFBcUI7QUFDbkI7QUFDQSxhQUFPMUMsNkJBQVdrQyxFQUFYLENBQWNDLGlCQUFPQyxPQUFQLEVBQWQsQ0FBUDtBQUNEOztBQUNELFdBQU9wQyw2QkFBVzJDLFdBQVgsQ0FBdUJELE9BQU8sQ0FBQ0UsYUFBUixFQUF2QixFQUNKQyxHQURJLENBQ0FDLE9BQU8sSUFBSVgsaUJBQU9uQixLQUFQLENBQWE4QixPQUFiLENBRFgsRUFFSkMsS0FGSSxDQUVFN0IsS0FBSyxJQUFJYyxtQkFBbUIsQ0FBQ2QsS0FBRCxDQUY5QixDQUFQO0FBR0QsR0FYSSxDQUFQO0FBWUQ7O0FBRUQsU0FBU2QsNkJBQVQsQ0FDRVgsVUFERixFQUUwQztBQUN4QyxTQUNFTyw2QkFBV0MsS0FBWCxDQUFpQixNQUFNO0FBQ3JCLFVBQU15QyxPQUFPLEdBQUcsc0NBQTBCakQsVUFBMUIsQ0FBaEI7O0FBQ0EsUUFBSWlELE9BQU8sSUFBSSxJQUFmLEVBQXFCO0FBQ25CO0FBQ0EsYUFBTzFDLDZCQUFXa0MsRUFBWCxDQUFjQyxpQkFBT0MsT0FBUCxFQUFkLENBQVA7QUFDRDs7QUFDRCxXQUFPTSxPQUFPLENBQ1hNLFlBREksR0FFSmpCLFFBRkksR0FHSmMsR0FISSxDQUdBQyxPQUFPLElBQUlYLGlCQUFPbkIsS0FBUCxDQUFhOEIsT0FBYixDQUhYLEVBSUpDLEtBSkksQ0FJRTdCLEtBQUssSUFBSWMsbUJBQW1CLENBQUNkLEtBQUQsQ0FKOUIsQ0FBUDtBQUtELEdBWEQsRUFZRTtBQUNBO0FBYkYsR0FjRytCLFVBZEgsQ0FjY0MsYUFBYSxJQUFJQSxhQUFhLENBQUNDLEtBQWQsQ0FBb0IsSUFBcEIsQ0FkL0IsRUFlRTtBQUNBO0FBaEJGLEdBaUJHQyxLQWpCSCxDQWlCU3BELDZCQUFXcUQsS0FBWCxFQWpCVCxDQURGO0FBb0JEOztBQUVELFNBQVM3QiwwQkFBVCxDQUNFOEIsR0FERixFQUc4QztBQUM1QyxNQUFJQyxVQUErQixHQUFHLElBQXRDLENBRDRDLENBRTVDOztBQUNBQyxFQUFBQSxJQUFJLENBQUNDLFFBQUwsQ0FBY0MsVUFBZCxDQUNHQyxPQURILENBQ1csc0JBRFgsRUFDbUMsT0FEbkMsRUFDNENDLFFBQVEsSUFBSTtBQUNwREwsSUFBQUEsVUFBVSxHQUFHSyxRQUFiO0FBQ0QsR0FISCxFQUlHQyxPQUpIOztBQUtBLE1BQUlOLFVBQVUsSUFBSSxJQUFsQixFQUF3QjtBQUN0QixXQUFPLElBQVA7QUFDRDs7QUFDRCxTQUFPQSxVQUFVLENBQUNPLHNCQUFYLENBQWtDLGFBQWxDLEVBQWlEUixHQUFqRCxDQUFQO0FBQ0QsQyxDQUVEO0FBQ0E7OztBQUNPLGVBQWVTLHNCQUFmLENBQ0x2RSxJQURLLEVBRUx3RSxVQUZLLEVBR2dCO0FBQ3JCLFFBQU1sQixPQUFPLEdBQUcsTUFBTXZELHFCQUFxQixDQUFDQyxJQUFELENBQXJCLENBQ25CeUUsSUFEbUIsQ0FDZCxDQURjLEVBRW5CQyxTQUZtQixFQUF0QjtBQUdBLFNBQU9wQixPQUFPLENBQUNxQixZQUFSLENBQXFCLEVBQXJCLEVBQXlCQyxJQUF6QixDQUE4QkMsQ0FBQyxJQUFJQSxDQUFDLENBQUNDLE1BQUYsS0FBYU4sVUFBaEQsQ0FBUDtBQUNEOztBQUVELE1BQU1sRSxjQUdMLEdBQUcsSUFBSXlFLHdCQUFKLEVBSEoiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIEBmbG93IHN0cmljdC1sb2NhbFxyXG4gKiBAZm9ybWF0XHJcbiAqL1xyXG5cclxuaW1wb3J0IHR5cGUge0V4cGVjdGVkfSBmcm9tICdAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtY29tbW9ucy9leHBlY3RlZCc7XHJcbmltcG9ydCB0eXBlIHtOdWNsaWRlVXJpfSBmcm9tICdAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtY29tbW9ucy9udWNsaWRlVXJpJztcclxuaW1wb3J0IHR5cGUge0FkYkRldmljZX0gZnJvbSAnLi90eXBlcyc7XHJcblxyXG5pbXBvcnQge2dldExvZ2dlcn0gZnJvbSAnbG9nNGpzJztcclxuaW1wb3J0IHthcnJheUVxdWFsfSBmcm9tICdAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtY29tbW9ucy9jb2xsZWN0aW9uJztcclxuaW1wb3J0IHtTaW1wbGVDYWNoZX0gZnJvbSAnQGF0b20taWRlLWNvbW11bml0eS9udWNsaWRlLWNvbW1vbnMvU2ltcGxlQ2FjaGUnO1xyXG5pbXBvcnQgc2hhbGxvd0VxdWFsIGZyb20gJ3NoYWxsb3dlcXVhbCc7XHJcbmltcG9ydCB7T2JzZXJ2YWJsZX0gZnJvbSAncnhqcy1jb21wYXQvYnVuZGxlcy9yeGpzLWNvbXBhdC51bWQubWluLmpzJztcclxuaW1wb3J0IHtFeHBlY3QsIGV4cGVjdGVkRXF1YWx9IGZyb20gJ0BhdG9tLWlkZS1jb21tdW5pdHkvbnVjbGlkZS1jb21tb25zL2V4cGVjdGVkJztcclxuaW1wb3J0IG51Y2xpZGVVcmkgZnJvbSAnQGF0b20taWRlLWNvbW11bml0eS9udWNsaWRlLWNvbW1vbnMvbnVjbGlkZVVyaSc7XHJcbmltcG9ydCB7dHJhY2t9IGZyb20gJ0BhdG9tLWlkZS1jb21tdW5pdHkvbnVjbGlkZS1jb21tb25zL2FuYWx5dGljcyc7XHJcbmltcG9ydCB7Z2V0QWRiU2VydmljZUJ5TnVjbGlkZVVyaX0gZnJvbSAnLi91dGlscyc7XHJcbmltcG9ydCBwYXNzZXNHSyBmcm9tICdAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtY29tbW9ucy9wYXNzZXNHSyc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gb2JzZXJ2ZUFuZHJvaWREZXZpY2VzKFxyXG4gIGhvc3Q6IE51Y2xpZGVVcmksXHJcbik6IE9ic2VydmFibGU8RXhwZWN0ZWQ8QXJyYXk8QWRiRGV2aWNlPj4+IHtcclxuICBjb25zdCBzZXJ2aWNlVXJpID0gbnVjbGlkZVVyaS5pc1JlbW90ZShob3N0KVxyXG4gICAgPyBudWNsaWRlVXJpLmNyZWF0ZVJlbW90ZVVyaShudWNsaWRlVXJpLmdldEhvc3RuYW1lKGhvc3QpLCAnLycpXHJcbiAgICA6ICcnO1xyXG4gIHJldHVybiBwb2xsZXJzRm9yVXJpcy5nZXRPckNyZWF0ZShzZXJ2aWNlVXJpLCAoKSA9PiB7XHJcbiAgICByZXR1cm4gT2JzZXJ2YWJsZS5kZWZlcigoKSA9PlxyXG4gICAgICBwYXNzZXNHSygnbnVjbGlkZV9kZXZpY2VfcGFuZWxfdXNlX2FkYl90cmFja19kZXZpY2VzJyksXHJcbiAgICApXHJcbiAgICAgIC5jb25jYXRNYXAoXHJcbiAgICAgICAgdXNlVHJhY2tEZXZpY2VzID0+XHJcbiAgICAgICAgICB1c2VUcmFja0RldmljZXNcclxuICAgICAgICAgICAgPyBvYnNlcnZlRGV2aWNlc1ZpYVRyYWNrRGV2aWNlcyhzZXJ2aWNlVXJpKVxyXG4gICAgICAgICAgICA6IG9ic2VydmVEZXZpY2VzVmlhUG9sbGluZyhzZXJ2aWNlVXJpKSxcclxuICAgICAgKVxyXG4gICAgICAuZGlzdGluY3RVbnRpbENoYW5nZWQoKGEsIGIpID0+XHJcbiAgICAgICAgZXhwZWN0ZWRFcXVhbChcclxuICAgICAgICAgIGEsXHJcbiAgICAgICAgICBiLFxyXG4gICAgICAgICAgKHYxLCB2MikgPT4gYXJyYXlFcXVhbCh2MSwgdjIsIHNoYWxsb3dFcXVhbCksXHJcbiAgICAgICAgICAoZTEsIGUyKSA9PiBlMS5tZXNzYWdlID09PSBlMi5tZXNzYWdlLFxyXG4gICAgICAgICksXHJcbiAgICAgIClcclxuICAgICAgLmRvKGFzeW5jIHZhbHVlID0+IHtcclxuICAgICAgICBpZiAodmFsdWUuaXNFcnJvcikge1xyXG4gICAgICAgICAgY29uc3Qge2Vycm9yfSA9IHZhbHVlO1xyXG4gICAgICAgICAgY29uc3QgbG9nZ2VyID0gZ2V0TG9nZ2VyKCdAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtYWRiJyk7XHJcbiAgICAgICAgICBsZXQgZXh0cmFzID0ge2Vycm9yfTtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAvLyAkRmxvd0lnbm9yZVxyXG4gICAgICAgICAgICAgIChlcnJvcjogYW55KS5vcmlnaW5hbEVycm9yICE9IG51bGwgJiZcclxuICAgICAgICAgICAgICAvLyAkRmxvd0lnbm9yZVxyXG4gICAgICAgICAgICAgIChlcnJvcjogYW55KS5vcmlnaW5hbEVycm9yLmNvZGUgPT09ICdFTk9FTlQnXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IGluZm9TZXJ2aWNlID0gYXdhaXQgZ2V0SW5mb1NlcnZpY2VCeU51Y2xpZGVVcmkoc2VydmljZVVyaSk7XHJcbiAgICAgICAgICAgICAgaWYgKGluZm9TZXJ2aWNlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJwY0VudiA9IGluZm9TZXJ2aWNlLmdldFNlcnZlckVudmlyb25tZW50KCk7XHJcbiAgICAgICAgICAgICAgICBleHRyYXMgPSB7Li4uZXh0cmFzLCBwYXRoRW52OiBycGNFbnYuUEFUSH07XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgICBsb2dnZXIud2Fybih2YWx1ZS5lcnJvci5tZXNzYWdlKTtcclxuICAgICAgICAgICAgdHJhY2soJ0BhdG9tLWlkZS1jb21tdW5pdHkvbnVjbGlkZS1hZGI6ZGV2aWNlLXBvbGxlcjplcnJvcicsIGV4dHJhcyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG4gICAgICAucHVibGlzaFJlcGxheSgxKVxyXG4gICAgICAucmVmQ291bnQoKTtcclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29udmVydEVycm9yVG9WYWx1ZShcclxuICBlcnJvcjogRXJyb3IsXHJcbik6IE9ic2VydmFibGU8RXhwZWN0ZWQ8QXJyYXk8QWRiRGV2aWNlPj4+IHtcclxuICBsZXQgbWVzc2FnZTtcclxuICAvLyAkRmxvd0ZpeE1lIGVycm9yLmNvZGVcclxuICBpZiAoZXJyb3IuY29kZSA9PT0gJ0VOT0VOVCcpIHtcclxuICAgIG1lc3NhZ2UgPSBcIidhZGInIG5vdCBmb3VuZCBpbiAkUEFUSC5cIjtcclxuICB9IGVsc2UgaWYgKFxyXG4gICAgLy8gUlBDIGNhbGwgdGltZWQgb3V0XHJcbiAgICBlcnJvci5uYW1lID09PSAnUnBjVGltZW91dEVycm9yJyB8fFxyXG4gICAgLy8gUlBDIGNhbGwgc3VjY2VlZGVkLCBidXQgdGhlIGFkYiBjYWxsIGl0c2VsZiB0aW1lZCBvdXRcclxuICAgIGVycm9yLm1lc3NhZ2UgPT09ICdUaW1lb3V0IGhhcyBvY2N1cnJlZCdcclxuICApIHtcclxuICAgIG1lc3NhZ2UgPSAnUmVxdWVzdCB0aW1lZCBvdXQsIHJldHJ5aW5nLi4uJztcclxuICB9IGVsc2UgaWYgKGVycm9yLm1lc3NhZ2UgPT09ICdDb25uZWN0aW9uIENsb3NlZCcpIHtcclxuICAgIHJldHVybiBPYnNlcnZhYmxlLm9mKEV4cGVjdC5wZW5kaW5nKCkpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBtZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcclxuICB9XHJcbiAgY29uc3QgbmV3RXJyb3IgPSBuZXcgRXJyb3IoXCJDYW4ndCBmZXRjaCBBbmRyb2lkIGRldmljZXMuIFwiICsgbWVzc2FnZSk7XHJcbiAgLy8gJEZsb3dJZ25vcmVcclxuICAobmV3RXJyb3I6IGFueSkub3JpZ2luYWxFcnJvciA9IGVycm9yO1xyXG4gIHJldHVybiBPYnNlcnZhYmxlLm9mKEV4cGVjdC5lcnJvcihuZXdFcnJvcikpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBvYnNlcnZlRGV2aWNlc1ZpYVBvbGxpbmcoXHJcbiAgc2VydmljZVVyaTogTnVjbGlkZVVyaSxcclxuKTogT2JzZXJ2YWJsZTxFeHBlY3RlZDxBcnJheTxBZGJEZXZpY2U+Pj4ge1xyXG4gIHJldHVybiBPYnNlcnZhYmxlLmludGVydmFsKDIwMDApXHJcbiAgICAuc3RhcnRXaXRoKDApXHJcbiAgICAuZXhoYXVzdE1hcCgoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHNlcnZpY2UgPSBnZXRBZGJTZXJ2aWNlQnlOdWNsaWRlVXJpKHNlcnZpY2VVcmkpO1xyXG4gICAgICBpZiAoc2VydmljZSA9PSBudWxsKSB7XHJcbiAgICAgICAgLy8gR3JhY2VmdWxseSBoYW5kbGUgYSBsb3N0IHJlbW90ZSBjb25uZWN0aW9uXHJcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGUub2YoRXhwZWN0LnBlbmRpbmcoKSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIE9ic2VydmFibGUuZnJvbVByb21pc2Uoc2VydmljZS5nZXREZXZpY2VMaXN0KCkpXHJcbiAgICAgICAgLm1hcChkZXZpY2VzID0+IEV4cGVjdC52YWx1ZShkZXZpY2VzKSlcclxuICAgICAgICAuY2F0Y2goZXJyb3IgPT4gY29udmVydEVycm9yVG9WYWx1ZShlcnJvcikpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG9ic2VydmVEZXZpY2VzVmlhVHJhY2tEZXZpY2VzKFxyXG4gIHNlcnZpY2VVcmk6IE51Y2xpZGVVcmksXHJcbik6IE9ic2VydmFibGU8RXhwZWN0ZWQ8QXJyYXk8QWRiRGV2aWNlPj4+IHtcclxuICByZXR1cm4gKFxyXG4gICAgT2JzZXJ2YWJsZS5kZWZlcigoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHNlcnZpY2UgPSBnZXRBZGJTZXJ2aWNlQnlOdWNsaWRlVXJpKHNlcnZpY2VVcmkpO1xyXG4gICAgICBpZiAoc2VydmljZSA9PSBudWxsKSB7XHJcbiAgICAgICAgLy8gR3JhY2VmdWxseSBoYW5kbGUgYSBsb3N0IHJlbW90ZSBjb25uZWN0aW9uXHJcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGUub2YoRXhwZWN0LnBlbmRpbmcoKSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHNlcnZpY2VcclxuICAgICAgICAudHJhY2tEZXZpY2VzKClcclxuICAgICAgICAucmVmQ291bnQoKVxyXG4gICAgICAgIC5tYXAoZGV2aWNlcyA9PiBFeHBlY3QudmFsdWUoZGV2aWNlcykpXHJcbiAgICAgICAgLmNhdGNoKGVycm9yID0+IGNvbnZlcnRFcnJvclRvVmFsdWUoZXJyb3IpKTtcclxuICAgIH0pXHJcbiAgICAgIC8vIElmIHRoZSBwcm9jZXNzIGV2ZXIgZXhpdHMsIHJldHJ5IGFmdGVyIDVzXHJcbiAgICAgIC8vICRGbG93Rml4TWUgcmVwZWF0V2hlblxyXG4gICAgICAucmVwZWF0V2hlbihub3RpZmljYXRpb25zID0+IG5vdGlmaWNhdGlvbnMuZGVsYXkoNTAwMCkpXHJcbiAgICAgIC8vIEFsc28sIG5ldmVyIGNvbXBsZXRlIHRoaXMgb2JzZXJ2YWJsZSwgc28gd2UgZG9uJ3Qgc3dpdGNoIHRvIGEgbmV3IG9ic2VydmFibGVcclxuICAgICAgLy8gaWYgdGhlIHByb2Nlc3MgZXhpdHMsIHdoaWNoIHdvdWxkIGludmFsaWRhdGUgbGF0ZXIgY2FjaGluZyAoZGlzdGluY3RVbnRpbENoYW5nZWQvcHVibGlzaFJlcGxheSlcclxuICAgICAgLm1lcmdlKE9ic2VydmFibGUubmV2ZXIoKSlcclxuICApO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRJbmZvU2VydmljZUJ5TnVjbGlkZVVyaShcclxuICB1cmk6IE51Y2xpZGVVcmksXHJcbiAgLy8gJEZsb3dJZ25vcmUgZW52IGNhbiBjb250YWluIGFueXRoaW5nXHJcbik6ID97Z2V0U2VydmVyRW52aXJvbm1lbnQoKTogUHJvbWlzZTxPYmplY3Q+fSB7XHJcbiAgbGV0IHJwY1NlcnZpY2U6ID9udWNsaWRlJFJwY1NlcnZpY2UgPSBudWxsO1xyXG4gIC8vIEF0b20ncyBzZXJ2aWNlIGh1YiBpcyBzeW5jaHJvbm91cy5cclxuICBhdG9tLnBhY2thZ2VzLnNlcnZpY2VIdWJcclxuICAgIC5jb25zdW1lKCdudWNsaWRlLXJwYy1zZXJ2aWNlcycsICcwLjAuMCcsIHByb3ZpZGVyID0+IHtcclxuICAgICAgcnBjU2VydmljZSA9IHByb3ZpZGVyO1xyXG4gICAgfSlcclxuICAgIC5kaXNwb3NlKCk7XHJcbiAgaWYgKHJwY1NlcnZpY2UgPT0gbnVsbCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIHJldHVybiBycGNTZXJ2aWNlLmdldFNlcnZpY2VCeU51Y2xpZGVVcmkoJ0luZm9TZXJ2aWNlJywgdXJpKTtcclxufVxyXG5cclxuLy8gVGhpcyBpcyBhIGNvbnZlbmllbnQgd2F5IGZvciBhbnkgZGV2aWNlIHBhbmVsIHBsdWdpbnMgb2YgdHlwZSBBbmRyb2lkIHRvIGdldCBmcm9tIERldmljZSB0b1xyXG4vLyB0byB0aGUgc3Ryb25nbHkgdHlwZWQgQWRiRGV2aWNlLlxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYWRiRGV2aWNlRm9ySWRlbnRpZmllcihcclxuICBob3N0OiBOdWNsaWRlVXJpLFxyXG4gIGlkZW50aWZpZXI6IHN0cmluZyxcclxuKTogUHJvbWlzZTw/QWRiRGV2aWNlPiB7XHJcbiAgY29uc3QgZGV2aWNlcyA9IGF3YWl0IG9ic2VydmVBbmRyb2lkRGV2aWNlcyhob3N0KVxyXG4gICAgLnRha2UoMSlcclxuICAgIC50b1Byb21pc2UoKTtcclxuICByZXR1cm4gZGV2aWNlcy5nZXRPckRlZmF1bHQoW10pLmZpbmQoZCA9PiBkLnNlcmlhbCA9PT0gaWRlbnRpZmllcik7XHJcbn1cclxuXHJcbmNvbnN0IHBvbGxlcnNGb3JVcmlzOiBTaW1wbGVDYWNoZTxcclxuICBzdHJpbmcsXHJcbiAgT2JzZXJ2YWJsZTxFeHBlY3RlZDxBcnJheTxBZGJEZXZpY2U+Pj4sXHJcbj4gPSBuZXcgU2ltcGxlQ2FjaGUoKTtcclxuIl19