"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.registerOnWillSave = registerOnWillSave;
exports.observeTextEditors = observeTextEditors;

var _rxjsCompatUmdMin = require("rxjs-compat/bundles/rxjs-compat.umd.min.js");

var _analytics = require("@atom-ide-community/nuclide-commons/analytics");

var _ProviderRegistry = _interopRequireDefault(require("./ProviderRegistry"));

var _textEdit = require("./text-edit");

var _UniversalDisposable = _interopRequireDefault(require("@atom-ide-community/nuclide-commons/UniversalDisposable"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */
// Timeouts if providers don't all finish in 5 seconds.
const GLOBAL_SAVE_TIMEOUT_MS = 5000;
const onWillSaveProviders = new _ProviderRegistry.default(); // Returns an observable of booleans, each of which indicates whether the
// formatting text edits from a given provider was successfully applied or not.

function onWillSave(editor) {
  if (editor.getPath() == null) {
    return _rxjsCompatUmdMin.Observable.empty();
  }

  const providers = Array.from(onWillSaveProviders.getAllProvidersForEditor(editor)); // NOTE: concat() is used here to subscribe to providers sequentially and
  // apply their text edits in order.

  return _rxjsCompatUmdMin.Observable.concat(...providers.map(provider => provider.callback(editor).toArray().race(_rxjsCompatUmdMin.Observable.of([]).delay(provider.timeout)).map(edits => {
    const success = (0, _textEdit.applyTextEditsToBuffer)(editor.getBuffer(), edits);
    return success;
  })));
} // HACK: intercept the real TextEditor.save and handle it ourselves.
// Atom has no way of injecting content into the buffer asynchronously
// before a save operation.
// If we try to format after the save, and then save again,
// it's a poor user experience (and also races the text buffer's reload).


function patchEditorSave(editor) {
  const realSave = editor.save;
  const editor_ = editor;

  editor_.save = async () => {
    const timeout = new Date();
    timeout.setTime(timeout.getTime() + GLOBAL_SAVE_TIMEOUT_MS);

    try {
      await onWillSave(editor_).timeout(timeout).toPromise();
    } catch (e) {
      const providers = Array.from(onWillSaveProviders.getAllProvidersForEditor(editor_));
      (0, _analytics.track)('timeout-on-save', {
        uri: editor.getPath(),
        providers
      });
    } finally {
      await realSave.call(editor);
    }
  };

  return new _UniversalDisposable.default(() => {
    editor_.save = realSave;
  });
}

function registerOnWillSave(provider) {
  return onWillSaveProviders.addProvider(provider);
}

function observeTextEditors() {
  const disposables = new _UniversalDisposable.default();
  disposables.add(atom.workspace.observeTextEditors(editor => {
    disposables.add(patchEditorSave(editor));
  }));
  return disposables;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zLWF0b20vRmlsZUV2ZW50SGFuZGxlcnMuanMiXSwibmFtZXMiOlsiR0xPQkFMX1NBVkVfVElNRU9VVF9NUyIsIm9uV2lsbFNhdmVQcm92aWRlcnMiLCJQcm92aWRlclJlZ2lzdHJ5Iiwib25XaWxsU2F2ZSIsImVkaXRvciIsImdldFBhdGgiLCJPYnNlcnZhYmxlIiwiZW1wdHkiLCJwcm92aWRlcnMiLCJBcnJheSIsImZyb20iLCJnZXRBbGxQcm92aWRlcnNGb3JFZGl0b3IiLCJjb25jYXQiLCJtYXAiLCJwcm92aWRlciIsImNhbGxiYWNrIiwidG9BcnJheSIsInJhY2UiLCJvZiIsImRlbGF5IiwidGltZW91dCIsImVkaXRzIiwic3VjY2VzcyIsImdldEJ1ZmZlciIsInBhdGNoRWRpdG9yU2F2ZSIsInJlYWxTYXZlIiwic2F2ZSIsImVkaXRvcl8iLCJEYXRlIiwic2V0VGltZSIsImdldFRpbWUiLCJ0b1Byb21pc2UiLCJlIiwidXJpIiwiY2FsbCIsIlVuaXZlcnNhbERpc3Bvc2FibGUiLCJyZWdpc3Rlck9uV2lsbFNhdmUiLCJhZGRQcm92aWRlciIsIm9ic2VydmVUZXh0RWRpdG9ycyIsImRpc3Bvc2FibGVzIiwiYWRkIiwiYXRvbSIsIndvcmtzcGFjZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFlQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQW5CQTs7Ozs7Ozs7Ozs7QUFnQ0E7QUFDQSxNQUFNQSxzQkFBc0IsR0FBRyxJQUEvQjtBQUNBLE1BQU1DLG1CQUVMLEdBQUcsSUFBSUMseUJBQUosRUFGSixDLENBSUE7QUFDQTs7QUFDQSxTQUFTQyxVQUFULENBQW9CQyxNQUFwQixFQUFrRTtBQUNoRSxNQUFJQSxNQUFNLENBQUNDLE9BQVAsTUFBb0IsSUFBeEIsRUFBOEI7QUFDNUIsV0FBT0MsNkJBQVdDLEtBQVgsRUFBUDtBQUNEOztBQUVELFFBQU1DLFNBQVMsR0FBR0MsS0FBSyxDQUFDQyxJQUFOLENBQ2hCVCxtQkFBbUIsQ0FBQ1Usd0JBQXBCLENBQTZDUCxNQUE3QyxDQURnQixDQUFsQixDQUxnRSxDQVFoRTtBQUNBOztBQUNBLFNBQU9FLDZCQUFXTSxNQUFYLENBQ0wsR0FBR0osU0FBUyxDQUFDSyxHQUFWLENBQWVDLFFBQUQsSUFDZkEsUUFBUSxDQUNMQyxRQURILENBQ1lYLE1BRFosRUFFR1ksT0FGSCxHQUdHQyxJQUhILENBR1FYLDZCQUFXWSxFQUFYLENBQWMsRUFBZCxFQUFrQkMsS0FBbEIsQ0FBd0JMLFFBQVEsQ0FBQ00sT0FBakMsQ0FIUixFQUlHUCxHQUpILENBSU9RLEtBQUssSUFBSTtBQUNaLFVBQU1DLE9BQU8sR0FBRyxzQ0FBdUJsQixNQUFNLENBQUNtQixTQUFQLEVBQXZCLEVBQTJDRixLQUEzQyxDQUFoQjtBQUNBLFdBQU9DLE9BQVA7QUFDRCxHQVBILENBREMsQ0FERSxDQUFQO0FBWUQsQyxDQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVNFLGVBQVQsQ0FBeUJwQixNQUF6QixFQUErRDtBQUM3RCxRQUFNcUIsUUFBUSxHQUFHckIsTUFBTSxDQUFDc0IsSUFBeEI7QUFDQSxRQUFNQyxPQUFPLEdBQUl2QixNQUFqQjs7QUFDQXVCLEVBQUFBLE9BQU8sQ0FBQ0QsSUFBUixHQUFlLFlBQVk7QUFDekIsVUFBTU4sT0FBTyxHQUFHLElBQUlRLElBQUosRUFBaEI7QUFDQVIsSUFBQUEsT0FBTyxDQUFDUyxPQUFSLENBQWdCVCxPQUFPLENBQUNVLE9BQVIsS0FBb0I5QixzQkFBcEM7O0FBQ0EsUUFBSTtBQUNGLFlBQU1HLFVBQVUsQ0FBQ3dCLE9BQUQsQ0FBVixDQUNIUCxPQURHLENBQ0tBLE9BREwsRUFFSFcsU0FGRyxFQUFOO0FBR0QsS0FKRCxDQUlFLE9BQU9DLENBQVAsRUFBVTtBQUNWLFlBQU14QixTQUFTLEdBQUdDLEtBQUssQ0FBQ0MsSUFBTixDQUNoQlQsbUJBQW1CLENBQUNVLHdCQUFwQixDQUE2Q2dCLE9BQTdDLENBRGdCLENBQWxCO0FBR0EsNEJBQU0saUJBQU4sRUFBeUI7QUFDdkJNLFFBQUFBLEdBQUcsRUFBRTdCLE1BQU0sQ0FBQ0MsT0FBUCxFQURrQjtBQUV2QkcsUUFBQUE7QUFGdUIsT0FBekI7QUFJRCxLQVpELFNBWVU7QUFDUixZQUFNaUIsUUFBUSxDQUFDUyxJQUFULENBQWM5QixNQUFkLENBQU47QUFDRDtBQUNGLEdBbEJEOztBQW1CQSxTQUFPLElBQUkrQiw0QkFBSixDQUF3QixNQUFNO0FBQ25DUixJQUFBQSxPQUFPLENBQUNELElBQVIsR0FBZUQsUUFBZjtBQUNELEdBRk0sQ0FBUDtBQUdEOztBQUVNLFNBQVNXLGtCQUFULENBQTRCdEIsUUFBNUIsRUFBdUU7QUFDNUUsU0FBT2IsbUJBQW1CLENBQUNvQyxXQUFwQixDQUFnQ3ZCLFFBQWhDLENBQVA7QUFDRDs7QUFFTSxTQUFTd0Isa0JBQVQsR0FBMkM7QUFDaEQsUUFBTUMsV0FBVyxHQUFHLElBQUlKLDRCQUFKLEVBQXBCO0FBQ0FJLEVBQUFBLFdBQVcsQ0FBQ0MsR0FBWixDQUNFQyxJQUFJLENBQUNDLFNBQUwsQ0FBZUosa0JBQWYsQ0FBa0NsQyxNQUFNLElBQUk7QUFDMUNtQyxJQUFBQSxXQUFXLENBQUNDLEdBQVosQ0FBZ0JoQixlQUFlLENBQUNwQixNQUFELENBQS9CO0FBQ0QsR0FGRCxDQURGO0FBS0EsU0FBT21DLFdBQVA7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTctcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogQGZsb3dcclxuICogQGZvcm1hdFxyXG4gKi9cclxuXHJcbmltcG9ydCB0eXBlIHtQcm92aWRlcn0gZnJvbSAnLi9Qcm92aWRlclJlZ2lzdHJ5JztcclxuaW1wb3J0IHR5cGUge1RleHRFZGl0fSBmcm9tICcuL3RleHQtZWRpdCc7XHJcblxyXG5pbXBvcnQge09ic2VydmFibGV9IGZyb20gJ3J4anMtY29tcGF0L2J1bmRsZXMvcnhqcy1jb21wYXQudW1kLm1pbi5qcyc7XHJcbmltcG9ydCB7dHJhY2t9IGZyb20gJ0BhdG9tLWlkZS1jb21tdW5pdHkvbnVjbGlkZS1jb21tb25zL2FuYWx5dGljcyc7XHJcbmltcG9ydCBQcm92aWRlclJlZ2lzdHJ5IGZyb20gJy4vUHJvdmlkZXJSZWdpc3RyeSc7XHJcbmltcG9ydCB7YXBwbHlUZXh0RWRpdHNUb0J1ZmZlcn0gZnJvbSAnLi90ZXh0LWVkaXQnO1xyXG5pbXBvcnQgVW5pdmVyc2FsRGlzcG9zYWJsZSBmcm9tICdAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtY29tbW9ucy9Vbml2ZXJzYWxEaXNwb3NhYmxlJztcclxuXHJcbmV4cG9ydCB0eXBlIEZpbGVFdmVudEhhbmRsZXJzQ29uZmlnID0ge3xcclxuICBzdXBwb3J0c09uV2lsbFNhdmU6IGJvb2xlYW4sXHJcbiAgb25XaWxsU2F2ZVRpbWVvdXQ/OiBudW1iZXIsXHJcbiAgb25XaWxsU2F2ZVByaW9yaXR5PzogbnVtYmVyLFxyXG58fTtcclxuXHJcbnR5cGUgT25XaWxsU2F2ZVByb3ZpZGVyID0gUHJvdmlkZXIgJiB7XHJcbiAgdGltZW91dDogbnVtYmVyLFxyXG4gIGNhbGxiYWNrOiAoZTogYXRvbSRUZXh0RWRpdG9yKSA9PiBPYnNlcnZhYmxlPFRleHRFZGl0PixcclxufTtcclxuXHJcbi8vIFRpbWVvdXRzIGlmIHByb3ZpZGVycyBkb24ndCBhbGwgZmluaXNoIGluIDUgc2Vjb25kcy5cclxuY29uc3QgR0xPQkFMX1NBVkVfVElNRU9VVF9NUyA9IDUwMDA7XHJcbmNvbnN0IG9uV2lsbFNhdmVQcm92aWRlcnM6IFByb3ZpZGVyUmVnaXN0cnk8XHJcbiAgT25XaWxsU2F2ZVByb3ZpZGVyLFxyXG4+ID0gbmV3IFByb3ZpZGVyUmVnaXN0cnkoKTtcclxuXHJcbi8vIFJldHVybnMgYW4gb2JzZXJ2YWJsZSBvZiBib29sZWFucywgZWFjaCBvZiB3aGljaCBpbmRpY2F0ZXMgd2hldGhlciB0aGVcclxuLy8gZm9ybWF0dGluZyB0ZXh0IGVkaXRzIGZyb20gYSBnaXZlbiBwcm92aWRlciB3YXMgc3VjY2Vzc2Z1bGx5IGFwcGxpZWQgb3Igbm90LlxyXG5mdW5jdGlvbiBvbldpbGxTYXZlKGVkaXRvcjogYXRvbSRUZXh0RWRpdG9yKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XHJcbiAgaWYgKGVkaXRvci5nZXRQYXRoKCkgPT0gbnVsbCkge1xyXG4gICAgcmV0dXJuIE9ic2VydmFibGUuZW1wdHkoKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHByb3ZpZGVycyA9IEFycmF5LmZyb20oXHJcbiAgICBvbldpbGxTYXZlUHJvdmlkZXJzLmdldEFsbFByb3ZpZGVyc0ZvckVkaXRvcihlZGl0b3IpLFxyXG4gICk7XHJcbiAgLy8gTk9URTogY29uY2F0KCkgaXMgdXNlZCBoZXJlIHRvIHN1YnNjcmliZSB0byBwcm92aWRlcnMgc2VxdWVudGlhbGx5IGFuZFxyXG4gIC8vIGFwcGx5IHRoZWlyIHRleHQgZWRpdHMgaW4gb3JkZXIuXHJcbiAgcmV0dXJuIE9ic2VydmFibGUuY29uY2F0KFxyXG4gICAgLi4ucHJvdmlkZXJzLm1hcCgocHJvdmlkZXI6IE9uV2lsbFNhdmVQcm92aWRlcikgPT5cclxuICAgICAgcHJvdmlkZXJcclxuICAgICAgICAuY2FsbGJhY2soZWRpdG9yKVxyXG4gICAgICAgIC50b0FycmF5KClcclxuICAgICAgICAucmFjZShPYnNlcnZhYmxlLm9mKFtdKS5kZWxheShwcm92aWRlci50aW1lb3V0KSlcclxuICAgICAgICAubWFwKGVkaXRzID0+IHtcclxuICAgICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBhcHBseVRleHRFZGl0c1RvQnVmZmVyKGVkaXRvci5nZXRCdWZmZXIoKSwgZWRpdHMpO1xyXG4gICAgICAgICAgcmV0dXJuIHN1Y2Nlc3M7XHJcbiAgICAgICAgfSksXHJcbiAgICApLFxyXG4gICk7XHJcbn1cclxuXHJcbi8vIEhBQ0s6IGludGVyY2VwdCB0aGUgcmVhbCBUZXh0RWRpdG9yLnNhdmUgYW5kIGhhbmRsZSBpdCBvdXJzZWx2ZXMuXHJcbi8vIEF0b20gaGFzIG5vIHdheSBvZiBpbmplY3RpbmcgY29udGVudCBpbnRvIHRoZSBidWZmZXIgYXN5bmNocm9ub3VzbHlcclxuLy8gYmVmb3JlIGEgc2F2ZSBvcGVyYXRpb24uXHJcbi8vIElmIHdlIHRyeSB0byBmb3JtYXQgYWZ0ZXIgdGhlIHNhdmUsIGFuZCB0aGVuIHNhdmUgYWdhaW4sXHJcbi8vIGl0J3MgYSBwb29yIHVzZXIgZXhwZXJpZW5jZSAoYW5kIGFsc28gcmFjZXMgdGhlIHRleHQgYnVmZmVyJ3MgcmVsb2FkKS5cclxuZnVuY3Rpb24gcGF0Y2hFZGl0b3JTYXZlKGVkaXRvcjogYXRvbSRUZXh0RWRpdG9yKTogSURpc3Bvc2FibGUge1xyXG4gIGNvbnN0IHJlYWxTYXZlID0gZWRpdG9yLnNhdmU7XHJcbiAgY29uc3QgZWRpdG9yXyA9IChlZGl0b3I6IGFueSk7XHJcbiAgZWRpdG9yXy5zYXZlID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgY29uc3QgdGltZW91dCA9IG5ldyBEYXRlKCk7XHJcbiAgICB0aW1lb3V0LnNldFRpbWUodGltZW91dC5nZXRUaW1lKCkgKyBHTE9CQUxfU0FWRV9USU1FT1VUX01TKTtcclxuICAgIHRyeSB7XHJcbiAgICAgIGF3YWl0IG9uV2lsbFNhdmUoZWRpdG9yXylcclxuICAgICAgICAudGltZW91dCh0aW1lb3V0KVxyXG4gICAgICAgIC50b1Byb21pc2UoKTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgY29uc3QgcHJvdmlkZXJzID0gQXJyYXkuZnJvbShcclxuICAgICAgICBvbldpbGxTYXZlUHJvdmlkZXJzLmdldEFsbFByb3ZpZGVyc0ZvckVkaXRvcihlZGl0b3JfKSxcclxuICAgICAgKTtcclxuICAgICAgdHJhY2soJ3RpbWVvdXQtb24tc2F2ZScsIHtcclxuICAgICAgICB1cmk6IGVkaXRvci5nZXRQYXRoKCksXHJcbiAgICAgICAgcHJvdmlkZXJzLFxyXG4gICAgICB9KTtcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIGF3YWl0IHJlYWxTYXZlLmNhbGwoZWRpdG9yKTtcclxuICAgIH1cclxuICB9O1xyXG4gIHJldHVybiBuZXcgVW5pdmVyc2FsRGlzcG9zYWJsZSgoKSA9PiB7XHJcbiAgICBlZGl0b3JfLnNhdmUgPSByZWFsU2F2ZTtcclxuICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyT25XaWxsU2F2ZShwcm92aWRlcjogT25XaWxsU2F2ZVByb3ZpZGVyKTogSURpc3Bvc2FibGUge1xyXG4gIHJldHVybiBvbldpbGxTYXZlUHJvdmlkZXJzLmFkZFByb3ZpZGVyKHByb3ZpZGVyKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG9ic2VydmVUZXh0RWRpdG9ycygpOiBJRGlzcG9zYWJsZSB7XHJcbiAgY29uc3QgZGlzcG9zYWJsZXMgPSBuZXcgVW5pdmVyc2FsRGlzcG9zYWJsZSgpO1xyXG4gIGRpc3Bvc2FibGVzLmFkZChcclxuICAgIGF0b20ud29ya3NwYWNlLm9ic2VydmVUZXh0RWRpdG9ycyhlZGl0b3IgPT4ge1xyXG4gICAgICBkaXNwb3NhYmxlcy5hZGQocGF0Y2hFZGl0b3JTYXZlKGVkaXRvcikpO1xyXG4gICAgfSksXHJcbiAgKTtcclxuICByZXR1cm4gZGlzcG9zYWJsZXM7XHJcbn1cclxuIl19