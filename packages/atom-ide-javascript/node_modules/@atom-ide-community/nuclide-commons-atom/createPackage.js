"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createPackage;

var _assert = _interopRequireDefault(require("assert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */

/**
 * Create an Atom package from an Activation constructor.
 *
 * Atom packages are obstensibly singletons, however they contain `activate()` and `deactivate()`
 * lifecycle methods which can be called multiple times. There's no use-case (so far as we know) for
 * invoking any other package methods while a package is not activated. Therefore, it makes more
 * sense to build packages as instances, constructed when a package is activated and destroyed when
 * the package is deactivated.
 *
 * Atom uses a plain `require` to load the module, and not babel's `require` interop. So if
 * `createPackage` were used as `export default createPackage(..)`, then Atom wouldn't be
 * able to find any package methods because the ES Module transform would output
 * `module.exports.default = {..};`. To workaround this, the module's `module.exports` is passed
 * to `createPackage` so we can attach whatever properties to it.
 *
 * It was a conscious decision to use `createPackage(module.exports, Activation)` instead of
 * `module.exports = createPackage(Activation)`, to avoid code style misunderstandings wrt
 * CommonJS vs ES Modules.
 */
function createPackage(moduleExports, Activation) {
  let activation = null; // Proxy method calls on the package to the activation object.

  for (const property of getPropertyList(Activation.prototype)) {
    if (typeof Activation.prototype[property] !== 'function') {
      continue;
    }

    if (property === 'constructor') {
      continue;
    }

    if (property === 'initialize') {
      throw new Error('Your activation class contains an "initialize" method, but that work should be done in the' + ' constructor.');
    }

    if (property === 'deactivate') {
      throw new Error('Your activation class contains an "deactivate" method. Please use "dispose" instead.');
    }

    moduleExports[property] = function (...args) {
      (0, _assert.default)(activation != null, 'Package not initialized');
      return activation[property](...args);
    };
  }
  /**
   * Calling `initialize()` creates a new instance.
   */


  moduleExports.initialize = initialState => {
    (0, _assert.default)(activation == null, 'Package already initialized');
    activation = new Activation(initialState);
  };
  /**
   * The `deactivate()` method is special-cased to null our activation instance reference.
   */


  moduleExports.deactivate = () => {
    (0, _assert.default)(activation != null, 'Package not initialized');

    if (typeof activation.dispose === 'function') {
      activation.dispose();
    }

    activation = null;
  };
}

function getPrototypeChain(prototype) {
  let currentPrototype = prototype;
  const prototypes = [];

  while (currentPrototype != null) {
    prototypes.push(currentPrototype);
    currentPrototype = Object.getPrototypeOf(currentPrototype);
  }

  return prototypes;
}
/**
 * List the properties (including inherited ones) of the provided prototype, excluding the ones
 * inherited from `Object`.
 */


function getPropertyList(prototype) {
  const properties = [];

  for (const proto of getPrototypeChain(prototype)) {
    if (proto === Object.prototype) {
      break;
    }

    for (const property of Object.getOwnPropertyNames(proto)) {
      properties.push(property);
    }
  }

  return properties;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zLWF0b20vY3JlYXRlUGFja2FnZS5qcyJdLCJuYW1lcyI6WyJjcmVhdGVQYWNrYWdlIiwibW9kdWxlRXhwb3J0cyIsIkFjdGl2YXRpb24iLCJhY3RpdmF0aW9uIiwicHJvcGVydHkiLCJnZXRQcm9wZXJ0eUxpc3QiLCJwcm90b3R5cGUiLCJFcnJvciIsImFyZ3MiLCJpbml0aWFsaXplIiwiaW5pdGlhbFN0YXRlIiwiZGVhY3RpdmF0ZSIsImRpc3Bvc2UiLCJnZXRQcm90b3R5cGVDaGFpbiIsImN1cnJlbnRQcm90b3R5cGUiLCJwcm90b3R5cGVzIiwicHVzaCIsIk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwicHJvcGVydGllcyIsInByb3RvIiwiZ2V0T3duUHJvcGVydHlOYW1lcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQVlBOzs7O0FBWkE7Ozs7Ozs7Ozs7OztBQWNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJlLFNBQVNBLGFBQVQsQ0FDYkMsYUFEYSxFQUViQyxVQUZhLEVBR1A7QUFDTixNQUFJQyxVQUFVLEdBQUcsSUFBakIsQ0FETSxDQUdOOztBQUNBLE9BQUssTUFBTUMsUUFBWCxJQUF1QkMsZUFBZSxDQUFDSCxVQUFVLENBQUNJLFNBQVosQ0FBdEMsRUFBOEQ7QUFDNUQsUUFBSSxPQUFPSixVQUFVLENBQUNJLFNBQVgsQ0FBcUJGLFFBQXJCLENBQVAsS0FBMEMsVUFBOUMsRUFBMEQ7QUFDeEQ7QUFDRDs7QUFDRCxRQUFJQSxRQUFRLEtBQUssYUFBakIsRUFBZ0M7QUFDOUI7QUFDRDs7QUFDRCxRQUFJQSxRQUFRLEtBQUssWUFBakIsRUFBK0I7QUFDN0IsWUFBTSxJQUFJRyxLQUFKLENBQ0osK0ZBQ0UsZUFGRSxDQUFOO0FBSUQ7O0FBQ0QsUUFBSUgsUUFBUSxLQUFLLFlBQWpCLEVBQStCO0FBQzdCLFlBQU0sSUFBSUcsS0FBSixDQUNKLHNGQURJLENBQU47QUFHRDs7QUFFRE4sSUFBQUEsYUFBYSxDQUFDRyxRQUFELENBQWIsR0FBMEIsVUFBUyxHQUFHSSxJQUFaLEVBQWtCO0FBQzFDLDJCQUFVTCxVQUFVLElBQUksSUFBeEIsRUFBOEIseUJBQTlCO0FBQ0EsYUFBT0EsVUFBVSxDQUFDQyxRQUFELENBQVYsQ0FBcUIsR0FBR0ksSUFBeEIsQ0FBUDtBQUNELEtBSEQ7QUFJRDtBQUVEOzs7OztBQUdBUCxFQUFBQSxhQUFhLENBQUNRLFVBQWQsR0FBNEJDLFlBQUQsSUFBaUM7QUFDMUQseUJBQVVQLFVBQVUsSUFBSSxJQUF4QixFQUE4Qiw2QkFBOUI7QUFDQUEsSUFBQUEsVUFBVSxHQUFHLElBQUlELFVBQUosQ0FBZVEsWUFBZixDQUFiO0FBQ0QsR0FIRDtBQUtBOzs7OztBQUdBVCxFQUFBQSxhQUFhLENBQUNVLFVBQWQsR0FBMkIsTUFBWTtBQUNyQyx5QkFBVVIsVUFBVSxJQUFJLElBQXhCLEVBQThCLHlCQUE5Qjs7QUFDQSxRQUFJLE9BQU9BLFVBQVUsQ0FBQ1MsT0FBbEIsS0FBOEIsVUFBbEMsRUFBOEM7QUFDNUNULE1BQUFBLFVBQVUsQ0FBQ1MsT0FBWDtBQUNEOztBQUNEVCxJQUFBQSxVQUFVLEdBQUcsSUFBYjtBQUNELEdBTkQ7QUFPRDs7QUFFRCxTQUFTVSxpQkFBVCxDQUEyQlAsU0FBM0IsRUFBcUU7QUFDbkUsTUFBSVEsZ0JBQWdCLEdBQUdSLFNBQXZCO0FBQ0EsUUFBTVMsVUFBVSxHQUFHLEVBQW5COztBQUNBLFNBQU9ELGdCQUFnQixJQUFJLElBQTNCLEVBQWlDO0FBQy9CQyxJQUFBQSxVQUFVLENBQUNDLElBQVgsQ0FBZ0JGLGdCQUFoQjtBQUNBQSxJQUFBQSxnQkFBZ0IsR0FBR0csTUFBTSxDQUFDQyxjQUFQLENBQXNCSixnQkFBdEIsQ0FBbkI7QUFDRDs7QUFDRCxTQUFPQyxVQUFQO0FBQ0Q7QUFFRDs7Ozs7O0FBSUEsU0FBU1YsZUFBVCxDQUF5QkMsU0FBekIsRUFBK0Q7QUFDN0QsUUFBTWEsVUFBVSxHQUFHLEVBQW5COztBQUNBLE9BQUssTUFBTUMsS0FBWCxJQUFvQlAsaUJBQWlCLENBQUNQLFNBQUQsQ0FBckMsRUFBa0Q7QUFDaEQsUUFBSWMsS0FBSyxLQUFNSCxNQUFELENBQWNYLFNBQTVCLEVBQXVDO0FBQ3JDO0FBQ0Q7O0FBQ0QsU0FBSyxNQUFNRixRQUFYLElBQXVCYSxNQUFNLENBQUNJLG1CQUFQLENBQTJCRCxLQUEzQixDQUF2QixFQUEwRDtBQUN4REQsTUFBQUEsVUFBVSxDQUFDSCxJQUFYLENBQWdCWixRQUFoQjtBQUNEO0FBQ0Y7O0FBQ0QsU0FBT2UsVUFBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBAZmxvd1xyXG4gKiBAZm9ybWF0XHJcbiAqL1xyXG5cclxuaW1wb3J0IGludmFyaWFudCBmcm9tICdhc3NlcnQnO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZSBhbiBBdG9tIHBhY2thZ2UgZnJvbSBhbiBBY3RpdmF0aW9uIGNvbnN0cnVjdG9yLlxyXG4gKlxyXG4gKiBBdG9tIHBhY2thZ2VzIGFyZSBvYnN0ZW5zaWJseSBzaW5nbGV0b25zLCBob3dldmVyIHRoZXkgY29udGFpbiBgYWN0aXZhdGUoKWAgYW5kIGBkZWFjdGl2YXRlKClgXHJcbiAqIGxpZmVjeWNsZSBtZXRob2RzIHdoaWNoIGNhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMuIFRoZXJlJ3Mgbm8gdXNlLWNhc2UgKHNvIGZhciBhcyB3ZSBrbm93KSBmb3JcclxuICogaW52b2tpbmcgYW55IG90aGVyIHBhY2thZ2UgbWV0aG9kcyB3aGlsZSBhIHBhY2thZ2UgaXMgbm90IGFjdGl2YXRlZC4gVGhlcmVmb3JlLCBpdCBtYWtlcyBtb3JlXHJcbiAqIHNlbnNlIHRvIGJ1aWxkIHBhY2thZ2VzIGFzIGluc3RhbmNlcywgY29uc3RydWN0ZWQgd2hlbiBhIHBhY2thZ2UgaXMgYWN0aXZhdGVkIGFuZCBkZXN0cm95ZWQgd2hlblxyXG4gKiB0aGUgcGFja2FnZSBpcyBkZWFjdGl2YXRlZC5cclxuICpcclxuICogQXRvbSB1c2VzIGEgcGxhaW4gYHJlcXVpcmVgIHRvIGxvYWQgdGhlIG1vZHVsZSwgYW5kIG5vdCBiYWJlbCdzIGByZXF1aXJlYCBpbnRlcm9wLiBTbyBpZlxyXG4gKiBgY3JlYXRlUGFja2FnZWAgd2VyZSB1c2VkIGFzIGBleHBvcnQgZGVmYXVsdCBjcmVhdGVQYWNrYWdlKC4uKWAsIHRoZW4gQXRvbSB3b3VsZG4ndCBiZVxyXG4gKiBhYmxlIHRvIGZpbmQgYW55IHBhY2thZ2UgbWV0aG9kcyBiZWNhdXNlIHRoZSBFUyBNb2R1bGUgdHJhbnNmb3JtIHdvdWxkIG91dHB1dFxyXG4gKiBgbW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IHsuLn07YC4gVG8gd29ya2Fyb3VuZCB0aGlzLCB0aGUgbW9kdWxlJ3MgYG1vZHVsZS5leHBvcnRzYCBpcyBwYXNzZWRcclxuICogdG8gYGNyZWF0ZVBhY2thZ2VgIHNvIHdlIGNhbiBhdHRhY2ggd2hhdGV2ZXIgcHJvcGVydGllcyB0byBpdC5cclxuICpcclxuICogSXQgd2FzIGEgY29uc2Npb3VzIGRlY2lzaW9uIHRvIHVzZSBgY3JlYXRlUGFja2FnZShtb2R1bGUuZXhwb3J0cywgQWN0aXZhdGlvbilgIGluc3RlYWQgb2ZcclxuICogYG1vZHVsZS5leHBvcnRzID0gY3JlYXRlUGFja2FnZShBY3RpdmF0aW9uKWAsIHRvIGF2b2lkIGNvZGUgc3R5bGUgbWlzdW5kZXJzdGFuZGluZ3Mgd3J0XHJcbiAqIENvbW1vbkpTIHZzIEVTIE1vZHVsZXMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVQYWNrYWdlKFxyXG4gIG1vZHVsZUV4cG9ydHM6IE9iamVjdCxcclxuICBBY3RpdmF0aW9uOiBDbGFzczxhbnk+LFxyXG4pOiB2b2lkIHtcclxuICBsZXQgYWN0aXZhdGlvbiA9IG51bGw7XHJcblxyXG4gIC8vIFByb3h5IG1ldGhvZCBjYWxscyBvbiB0aGUgcGFja2FnZSB0byB0aGUgYWN0aXZhdGlvbiBvYmplY3QuXHJcbiAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiBnZXRQcm9wZXJ0eUxpc3QoQWN0aXZhdGlvbi5wcm90b3R5cGUpKSB7XHJcbiAgICBpZiAodHlwZW9mIEFjdGl2YXRpb24ucHJvdG90eXBlW3Byb3BlcnR5XSAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIGlmIChwcm9wZXJ0eSA9PT0gJ2NvbnN0cnVjdG9yJykge1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIGlmIChwcm9wZXJ0eSA9PT0gJ2luaXRpYWxpemUnKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAnWW91ciBhY3RpdmF0aW9uIGNsYXNzIGNvbnRhaW5zIGFuIFwiaW5pdGlhbGl6ZVwiIG1ldGhvZCwgYnV0IHRoYXQgd29yayBzaG91bGQgYmUgZG9uZSBpbiB0aGUnICtcclxuICAgICAgICAgICcgY29uc3RydWN0b3IuJyxcclxuICAgICAgKTtcclxuICAgIH1cclxuICAgIGlmIChwcm9wZXJ0eSA9PT0gJ2RlYWN0aXZhdGUnKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAnWW91ciBhY3RpdmF0aW9uIGNsYXNzIGNvbnRhaW5zIGFuIFwiZGVhY3RpdmF0ZVwiIG1ldGhvZC4gUGxlYXNlIHVzZSBcImRpc3Bvc2VcIiBpbnN0ZWFkLicsXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgbW9kdWxlRXhwb3J0c1twcm9wZXJ0eV0gPSBmdW5jdGlvbiguLi5hcmdzKSB7XHJcbiAgICAgIGludmFyaWFudChhY3RpdmF0aW9uICE9IG51bGwsICdQYWNrYWdlIG5vdCBpbml0aWFsaXplZCcpO1xyXG4gICAgICByZXR1cm4gYWN0aXZhdGlvbltwcm9wZXJ0eV0oLi4uYXJncyk7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsbGluZyBgaW5pdGlhbGl6ZSgpYCBjcmVhdGVzIGEgbmV3IGluc3RhbmNlLlxyXG4gICAqL1xyXG4gIG1vZHVsZUV4cG9ydHMuaW5pdGlhbGl6ZSA9IChpbml0aWFsU3RhdGU6ID9PYmplY3QpOiB2b2lkID0+IHtcclxuICAgIGludmFyaWFudChhY3RpdmF0aW9uID09IG51bGwsICdQYWNrYWdlIGFscmVhZHkgaW5pdGlhbGl6ZWQnKTtcclxuICAgIGFjdGl2YXRpb24gPSBuZXcgQWN0aXZhdGlvbihpbml0aWFsU3RhdGUpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBgZGVhY3RpdmF0ZSgpYCBtZXRob2QgaXMgc3BlY2lhbC1jYXNlZCB0byBudWxsIG91ciBhY3RpdmF0aW9uIGluc3RhbmNlIHJlZmVyZW5jZS5cclxuICAgKi9cclxuICBtb2R1bGVFeHBvcnRzLmRlYWN0aXZhdGUgPSAoKTogdm9pZCA9PiB7XHJcbiAgICBpbnZhcmlhbnQoYWN0aXZhdGlvbiAhPSBudWxsLCAnUGFja2FnZSBub3QgaW5pdGlhbGl6ZWQnKTtcclxuICAgIGlmICh0eXBlb2YgYWN0aXZhdGlvbi5kaXNwb3NlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIGFjdGl2YXRpb24uZGlzcG9zZSgpO1xyXG4gICAgfVxyXG4gICAgYWN0aXZhdGlvbiA9IG51bGw7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0UHJvdG90eXBlQ2hhaW4ocHJvdG90eXBlOiBDbGFzczxhbnk+KTogQXJyYXk8Q2xhc3M8YW55Pj4ge1xyXG4gIGxldCBjdXJyZW50UHJvdG90eXBlID0gcHJvdG90eXBlO1xyXG4gIGNvbnN0IHByb3RvdHlwZXMgPSBbXTtcclxuICB3aGlsZSAoY3VycmVudFByb3RvdHlwZSAhPSBudWxsKSB7XHJcbiAgICBwcm90b3R5cGVzLnB1c2goY3VycmVudFByb3RvdHlwZSk7XHJcbiAgICBjdXJyZW50UHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGN1cnJlbnRQcm90b3R5cGUpO1xyXG4gIH1cclxuICByZXR1cm4gcHJvdG90eXBlcztcclxufVxyXG5cclxuLyoqXHJcbiAqIExpc3QgdGhlIHByb3BlcnRpZXMgKGluY2x1ZGluZyBpbmhlcml0ZWQgb25lcykgb2YgdGhlIHByb3ZpZGVkIHByb3RvdHlwZSwgZXhjbHVkaW5nIHRoZSBvbmVzXHJcbiAqIGluaGVyaXRlZCBmcm9tIGBPYmplY3RgLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UHJvcGVydHlMaXN0KHByb3RvdHlwZTogQ2xhc3M8YW55Pik6IEFycmF5PHN0cmluZz4ge1xyXG4gIGNvbnN0IHByb3BlcnRpZXMgPSBbXTtcclxuICBmb3IgKGNvbnN0IHByb3RvIG9mIGdldFByb3RvdHlwZUNoYWluKHByb3RvdHlwZSkpIHtcclxuICAgIGlmIChwcm90byA9PT0gKE9iamVjdDogYW55KS5wcm90b3R5cGUpIHtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvKSkge1xyXG4gICAgICBwcm9wZXJ0aWVzLnB1c2gocHJvcGVydHkpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gcHJvcGVydGllcztcclxufVxyXG4iXX0=