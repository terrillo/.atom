"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _log4js = require("log4js");

var _collection = require("@atom-ide-community/nuclide-commons/collection");

var _rxjsCompatUmdMin = require("rxjs-compat/bundles/rxjs-compat.umd.min.js");

var jsonrpc = _interopRequireWildcard(require("vscode-jsonrpc"));

var _messageReader = require("vscode-jsonrpc/lib/messageReader");

var _messageWriter = require("vscode-jsonrpc/lib/messageWriter");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */

/**
 * In the new package model, communication between packages will be modeled as sockets.
 * For each producer <-> consumer pair, we will create a socket:
 * the consumer gets one end of the socket, while the producer gets the other end.
 */
class MessageRouter {
  constructor() {
    this._curSocketID = 1;
    this._sockets = new Map();
    this._buffer = new _collection.DefaultMap(Array);
  }

  /**
   * Returns a pair of sockets.
   */
  getSocket() {
    const socket = [this._curSocketID, -this._curSocketID];
    this._curSocketID++;
    return socket;
  }

  reverseSocket(socket) {
    return -socket;
  }

  send(message) {
    const {
      socket
    } = message;

    const subject = this._sockets.get(socket);

    if (subject == null) {
      this._buffer.get(socket).push(message);
    } else {
      subject.next(message);
    }
  }

  getMessages(socket) {
    let subject = this._sockets.get(socket);

    if (subject == null) {
      subject = new _rxjsCompatUmdMin.Subject();

      this._sockets.set(socket, subject);

      const buffered = this._buffer.get(socket);

      this._buffer.delete(socket);

      return _rxjsCompatUmdMin.Observable.from(buffered).concat(subject);
    }

    return subject;
  }

  createConnection(socket, config) {
    const connection = jsonrpc.createMessageConnection( // Messages intended for socket actually come through -socket.
    new SimpleReader(cb => this.getMessages(this.reverseSocket(socket)).subscribe(cb)), // Tag each message with the socket it originated from.
    new SimpleWriter(msg => this.send({ ...msg,
      socket
    })), (0, _log4js.getLogger)('ExperimentalMessageRouter-jsonrpc'));
    connection.config = config || {};
    connection.listen();
    return connection;
  }

}

exports.default = MessageRouter;

class SimpleReader extends _messageReader.AbstractMessageReader {
  constructor(subscribe) {
    super();
    this._subscribe = void 0;
    this._subscribe = subscribe;
  }

  listen(callback) {
    this._subscribe(callback);
  }

}

class SimpleWriter extends _messageWriter.AbstractMessageWriter {
  constructor(write) {
    super();
    this._write = void 0;
    this._write = write;
  }

  write(message) {
    this._write(message);
  }

}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zLWF0b20vZXhwZXJpbWVudGFsLXBhY2thZ2VzL01lc3NhZ2VSb3V0ZXIuanMiXSwibmFtZXMiOlsiTWVzc2FnZVJvdXRlciIsIl9jdXJTb2NrZXRJRCIsIl9zb2NrZXRzIiwiTWFwIiwiX2J1ZmZlciIsIkRlZmF1bHRNYXAiLCJBcnJheSIsImdldFNvY2tldCIsInNvY2tldCIsInJldmVyc2VTb2NrZXQiLCJzZW5kIiwibWVzc2FnZSIsInN1YmplY3QiLCJnZXQiLCJwdXNoIiwibmV4dCIsImdldE1lc3NhZ2VzIiwiU3ViamVjdCIsInNldCIsImJ1ZmZlcmVkIiwiZGVsZXRlIiwiT2JzZXJ2YWJsZSIsImZyb20iLCJjb25jYXQiLCJjcmVhdGVDb25uZWN0aW9uIiwiY29uZmlnIiwiY29ubmVjdGlvbiIsImpzb25ycGMiLCJjcmVhdGVNZXNzYWdlQ29ubmVjdGlvbiIsIlNpbXBsZVJlYWRlciIsImNiIiwic3Vic2NyaWJlIiwiU2ltcGxlV3JpdGVyIiwibXNnIiwibGlzdGVuIiwiQWJzdHJhY3RNZXNzYWdlUmVhZGVyIiwiY29uc3RydWN0b3IiLCJfc3Vic2NyaWJlIiwiY2FsbGJhY2siLCJBYnN0cmFjdE1lc3NhZ2VXcml0ZXIiLCJ3cml0ZSIsIl93cml0ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQWNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7QUFuQkE7Ozs7Ozs7Ozs7OztBQTRCQTs7Ozs7QUFLZSxNQUFNQSxhQUFOLENBQW9CO0FBQUE7QUFBQSxTQUNqQ0MsWUFEaUMsR0FDbEIsQ0FEa0I7QUFBQSxTQUVqQ0MsUUFGaUMsR0FFYyxJQUFJQyxHQUFKLEVBRmQ7QUFBQSxTQU1qQ0MsT0FOaUMsR0FNa0IsSUFBSUMsc0JBQUosQ0FBZUMsS0FBZixDQU5sQjtBQUFBOztBQVFqQzs7O0FBR0FDLEVBQUFBLFNBQVMsR0FBcUI7QUFDNUIsVUFBTUMsTUFBTSxHQUFHLENBQUMsS0FB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ZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIEBmbG93XHJcbiAqIEBmb3JtYXRcclxuICovXHJcblxyXG5pbXBvcnQgdHlwZSB7UGlwZWRNZXNzYWdlLCBTZXJ2aWNlQ29ubmVjdGlvbn0gZnJvbSAnLi90eXBlcyc7XHJcblxyXG5pbXBvcnQge2dldExvZ2dlcn0gZnJvbSAnbG9nNGpzJztcclxuaW1wb3J0IHtEZWZhdWx0TWFwfSBmcm9tICdAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtY29tbW9ucy9jb2xsZWN0aW9uJztcclxuaW1wb3J0IHtPYnNlcnZhYmxlLCBTdWJqZWN0fSBmcm9tICdyeGpzLWNvbXBhdC9idW5kbGVzL3J4anMtY29tcGF0LnVtZC5taW4uanMnO1xyXG5pbXBvcnQgKiBhcyBqc29ucnBjIGZyb20gJ3ZzY29kZS1qc29ucnBjJztcclxuaW1wb3J0IHtBYnN0cmFjdE1lc3NhZ2VSZWFkZXJ9IGZyb20gJ3ZzY29kZS1qc29ucnBjL2xpYi9tZXNzYWdlUmVhZGVyJztcclxuaW1wb3J0IHtBYnN0cmFjdE1lc3NhZ2VXcml0ZXJ9IGZyb20gJ3ZzY29kZS1qc29ucnBjL2xpYi9tZXNzYWdlV3JpdGVyJztcclxuXHJcbi8vIFdlJ2xsIHJlcHJlc2VudCBzb2NrZXRzIGluIHBhaXJzIChudW1iZXJzIGFuZCB0aGVpciBuZWdhdGl2ZXMpLlxyXG4vLyBBZnRlciB3cml0aW5nIHRvIGEgc29ja2V0LCB0aGUgbWVzc2FnZSBtYXkgYmUgcmVhZCB0aHJvdWdoIGl0cyBuZWdhdGl2ZS5cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXHJcbmV4cG9ydCBvcGFxdWUgdHlwZSBTb2NrZXQgPSBudW1iZXI7XHJcblxyXG50eXBlIERhdGFDYWxsYmFjayA9IChkYXRhOiBQaXBlZE1lc3NhZ2UpID0+IG1peGVkO1xyXG5cclxuLyoqXHJcbiAqIEluIHRoZSBuZXcgcGFja2FnZSBtb2RlbCwgY29tbXVuaWNhdGlvbiBiZXR3ZWVuIHBhY2thZ2VzIHdpbGwgYmUgbW9kZWxlZCBhcyBzb2NrZXRzLlxyXG4gKiBGb3IgZWFjaCBwcm9kdWNlciA8LT4gY29uc3VtZXIgcGFpciwgd2Ugd2lsbCBjcmVhdGUgYSBzb2NrZXQ6XHJcbiAqIHRoZSBjb25zdW1lciBnZXRzIG9uZSBlbmQgb2YgdGhlIHNvY2tldCwgd2hpbGUgdGhlIHByb2R1Y2VyIGdldHMgdGhlIG90aGVyIGVuZC5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1lc3NhZ2VSb3V0ZXIge1xyXG4gIF9jdXJTb2NrZXRJRCA9IDE7XHJcbiAgX3NvY2tldHM6IE1hcDxTb2NrZXQsIFN1YmplY3Q8UGlwZWRNZXNzYWdlPj4gPSBuZXcgTWFwKCk7XHJcblxyXG4gIC8vIElmIG1lc3NhZ2VzIGFyZSBzZW50IHRvIGEgc29ja2V0IGJlZm9yZSBhIGxpc3RlbmVyIGdldHMgYXR0YWNoZWQsXHJcbiAgLy8gYnVmZmVyIGl0IHVwIGhlcmUuIFRoZSBidWZmZXIgd2lsbCBiZSBjbGVhcmVkIGFmdGVyIHRoZSBmaXJzdCBnZXRNZXNzYWdlcyBjYWxsLlxyXG4gIF9idWZmZXI6IERlZmF1bHRNYXA8U29ja2V0LCBBcnJheTxQaXBlZE1lc3NhZ2U+PiA9IG5ldyBEZWZhdWx0TWFwKEFycmF5KTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhIHBhaXIgb2Ygc29ja2V0cy5cclxuICAgKi9cclxuICBnZXRTb2NrZXQoKTogW1NvY2tldCwgU29ja2V0XSB7XHJcbiAgICBjb25zdCBzb2NrZXQgPSBbdGhpcy5fY3VyU29ja2V0SUQsIC10aGlzLl9jdXJTb2NrZXRJRF07XHJcbiAgICB0aGlzLl9jdXJTb2NrZXRJRCsrO1xyXG4gICAgcmV0dXJuIHNvY2tldDtcclxuICB9XHJcblxyXG4gIHJldmVyc2VTb2NrZXQoc29ja2V0OiBTb2NrZXQpOiBTb2NrZXQge1xyXG4gICAgcmV0dXJuIC1zb2NrZXQ7XHJcbiAgfVxyXG5cclxuICBzZW5kKG1lc3NhZ2U6IFBpcGVkTWVzc2FnZSk6IHZvaWQge1xyXG4gICAgY29uc3Qge3NvY2tldH0gPSBtZXNzYWdlO1xyXG4gICAgY29uc3Qgc3ViamVjdCA9IHRoaXMuX3NvY2tldHMuZ2V0KHNvY2tldCk7XHJcbiAgICBpZiAoc3ViamVjdCA9PSBudWxsKSB7XHJcbiAgICAgIHRoaXMuX2J1ZmZlci5nZXQoc29ja2V0KS5wdXNoKG1lc3NhZ2UpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc3ViamVjdC5uZXh0KG1lc3NhZ2UpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZ2V0TWVzc2FnZXMoc29ja2V0OiBTb2NrZXQpOiBPYnNlcnZhYmxlPFBpcGVkTWVzc2FnZT4ge1xyXG4gICAgbGV0IHN1YmplY3QgPSB0aGlzLl9zb2NrZXRzLmdldChzb2NrZXQpO1xyXG4gICAgaWYgKHN1YmplY3QgPT0gbnVsbCkge1xyXG4gICAgICBzdWJqZWN0ID0gbmV3IFN1YmplY3QoKTtcclxuICAgICAgdGhpcy5fc29ja2V0cy5zZXQoc29ja2V0LCBzdWJqZWN0KTtcclxuICAgICAgY29uc3QgYnVmZmVyZWQgPSB0aGlzLl9idWZmZXIuZ2V0KHNvY2tldCk7XHJcbiAgICAgIHRoaXMuX2J1ZmZlci5kZWxldGUoc29ja2V0KTtcclxuICAgICAgcmV0dXJuIE9ic2VydmFibGUuZnJvbShidWZmZXJlZCkuY29uY2F0KHN1YmplY3QpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN1YmplY3Q7XHJcbiAgfVxyXG5cclxuICBjcmVhdGVDb25uZWN0aW9uKHNvY2tldDogU29ja2V0LCBjb25maWc6ID9PYmplY3QpOiBTZXJ2aWNlQ29ubmVjdGlvbiB7XHJcbiAgICBjb25zdCBjb25uZWN0aW9uOiBTZXJ2aWNlQ29ubmVjdGlvbiA9IChqc29ucnBjLmNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uKFxyXG4gICAgICAvLyBNZXNzYWdlcyBpbnRlbmRlZCBmb3Igc29ja2V0IGFjdHVhbGx5IGNvbWUgdGhyb3VnaCAtc29ja2V0LlxyXG4gICAgICBuZXcgU2ltcGxlUmVhZGVyKGNiID0+XHJcbiAgICAgICAgdGhpcy5nZXRNZXNzYWdlcyh0aGlzLnJldmVyc2VTb2NrZXQoc29ja2V0KSkuc3Vic2NyaWJlKGNiKSxcclxuICAgICAgKSxcclxuICAgICAgLy8gVGFnIGVhY2ggbWVzc2FnZSB3aXRoIHRoZSBzb2NrZXQgaXQgb3JpZ2luYXRlZCBmcm9tLlxyXG4gICAgICBuZXcgU2ltcGxlV3JpdGVyKG1zZyA9PiB0aGlzLnNlbmQoey4uLm1zZywgc29ja2V0fSkpLFxyXG4gICAgICBnZXRMb2dnZXIoJ0V4cGVyaW1lbnRhbE1lc3NhZ2VSb3V0ZXItanNvbnJwYycpLFxyXG4gICAgKTogYW55KTtcclxuICAgIGNvbm5lY3Rpb24uY29uZmlnID0gY29uZmlnIHx8IHt9O1xyXG4gICAgY29ubmVjdGlvbi5saXN0ZW4oKTtcclxuICAgIHJldHVybiBjb25uZWN0aW9uO1xyXG4gIH1cclxufVxyXG5cclxuY2xhc3MgU2ltcGxlUmVhZGVyIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlUmVhZGVyIHtcclxuICBfc3Vic2NyaWJlOiAoY2FsbGJhY2s6IERhdGFDYWxsYmFjaykgPT4gbWl4ZWQ7XHJcblxyXG4gIGNvbnN0cnVjdG9yKHN1YnNjcmliZTogKGNhbGxiYWNrOiBEYXRhQ2FsbGJhY2spID0+IG1peGVkKTogdm9pZCB7XHJcbiAgICBzdXBlcigpO1xyXG4gICAgdGhpcy5fc3Vic2NyaWJlID0gc3Vic2NyaWJlO1xyXG4gIH1cclxuXHJcbiAgbGlzdGVuKGNhbGxiYWNrOiAoZGF0YTogUGlwZWRNZXNzYWdlKSA9PiBtaXhlZCk6IHZvaWQge1xyXG4gICAgdGhpcy5fc3Vic2NyaWJlKGNhbGxiYWNrKTtcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIFNpbXBsZVdyaXRlciBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVdyaXRlciB7XHJcbiAgX3dyaXRlOiAobWVzc2FnZTogUGlwZWRNZXNzYWdlKSA9PiBtaXhlZDtcclxuXHJcbiAgY29uc3RydWN0b3Iod3JpdGU6IChtZXNzYWdlOiBQaXBlZE1lc3NhZ2UpID0+IG1peGVkKSB7XHJcbiAgICBzdXBlcigpO1xyXG4gICAgdGhpcy5fd3JpdGUgPSB3cml0ZTtcclxuICB9XHJcblxyXG4gIHdyaXRlKG1lc3NhZ2U6IFBpcGVkTWVzc2FnZSk6IHZvaWQge1xyXG4gICAgdGhpcy5fd3JpdGUobWVzc2FnZSk7XHJcbiAgfVxyXG59XHJcbiJdfQ==