"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AtomPackageRunner = exports.ProcessPackageRunner = void 0;

var _process = require("@atom-ide-community/nuclide-commons/process");

var _UniversalDisposable = _interopRequireDefault(require("@atom-ide-community/nuclide-commons/UniversalDisposable"));

var _rxjsCompatUmdMin = require("rxjs-compat/bundles/rxjs-compat.umd.min.js");

var _MessageRouter = _interopRequireDefault(require("./MessageRouter"));

var _activatePackage = _interopRequireDefault(require("./activatePackage"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */
class ProcessPackageRunner {
  // $FlowFixMe (>=0.85.0) (T35986896) Flow upgrade suppress
  constructor(packages, messageRouter) {
    this._processStream = void 0;
    this._outputStream = void 0;
    this._disposed = new _rxjsCompatUmdMin.ReplaySubject(1);
    this._processStream = (0, _process.fork)(require.resolve('./run-package-entry.js'), [], {
      silent: true
    }).takeUntil(this._disposed).do(proc => {
      proc.on('message', msg => {
        messageRouter.send(msg);
      });
      const exposedSockets = getExposedSockets(packages, messageRouter);
      proc.send({
        packages,
        exposedSockets
      });
      exposedSockets.forEach(socket => {
        // Intercept incoming messages for each exposed socket.
        messageRouter.getMessages(messageRouter.reverseSocket(socket)).takeUntil(this._disposed).subscribe(msg => proc.send(msg));
      });
    }) // TODO: Error on early completion.
    .share().publishReplay(1); // Note: this won't start emitting anything activate() gets called.

    this._outputStream = this._processStream.switchMap(proc => (0, _process.getOutputStream)(proc)).publish();
  }

  activate() {
    this._processStream.connect();
  }

  onDidError(callback) {
    return new _UniversalDisposable.default(this._outputStream.refCount().subscribe({
      error: err => {
        callback(err);
      }
    }));
  }

  dispose() {
    this._disposed.next();
  }

} // Atom packages have to run in the same process.


exports.ProcessPackageRunner = ProcessPackageRunner;

class AtomPackageRunner {
  constructor(packages, messageRouter) {
    this._packages = void 0;
    this._messageRouter = void 0;
    this._disposables = void 0;
    this._packages = packages;
    this._messageRouter = messageRouter;
    this._disposables = new _UniversalDisposable.default();
  }

  activate() {
    this._disposables.add(...this._packages.map(params => {
      const pkg = (0, _activatePackage.default)(params, this._messageRouter);
      return () => {
        if (pkg.dispose != null) {
          pkg.dispose();
        }
      };
    }));
  }

  dispose() {
    this._disposables.dispose();
  }

  onDidError(callback) {
    return new _UniversalDisposable.default();
  }

}

exports.AtomPackageRunner = AtomPackageRunner;

function getExposedSockets(packages, messageRouter) {
  // Exposed sockets are those that are either:
  // 1) provided here but not consumed
  // 2) consumed here but not provided.
  const allSockets = new Set();
  packages.forEach(pkg => {
    Object.keys(pkg.consumedServices).forEach(key => {
      const {
        socket
      } = pkg.consumedServices[key];
      allSockets.add(socket);
    });
    Object.keys(pkg.providedServices).forEach(key => {
      pkg.providedServices[key].rawConnections.forEach(({
        socket
      }) => {
        allSockets.add(socket);
      });
    });
  });
  return Array.from(allSockets).filter(socket => !allSockets.has(messageRouter.reverseSocket(socket)));
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zLWF0b20vZXhwZXJpbWVudGFsLXBhY2thZ2VzL1BhY2thZ2VSdW5uZXJzLmpzIl0sIm5hbWVzIjpbIlByb2Nlc3NQYWNrYWdlUnVubmVyIiwiY29uc3RydWN0b3IiLCJwYWNrYWdlcyIsIm1lc3NhZ2VSb3V0ZXIiLCJfcHJvY2Vzc1N0cmVhbSIsIl9vdXRwdXRTdHJlYW0iLCJfZGlzcG9zZWQiLCJSZXBsYXlTdWJqZWN0IiwicmVxdWlyZSIsInJlc29sdmUiLCJzaWxlbnQiLCJ0YWtlVW50aWwiLCJkbyIsInByb2MiLCJvbiIsIm1zZyIsInNlbmQiLCJleHBvc2VkU29ja2V0cyIsImdldEV4cG9zZWRTb2NrZXRzIiwiZm9yRWFjaCIsInNvY2tldCIsImdldE1lc3NhZ2VzIiwicmV2ZXJzZVNvY2tldCIsInN1YnNjcmliZSIsInNoYXJlIiwicHVibGlzaFJlcGxheSIsInN3aXRjaE1hcCIsInB1Ymxpc2giLCJhY3RpdmF0ZSIsImNvbm5lY3QiLCJvbkRpZEVycm9yIiwiY2FsbGJhY2siLCJVbml2ZXJzYWxEaXNwb3NhYmxlIiwicmVmQ291bnQiLCJlcnJvciIsImVyciIsImRpc3Bvc2UiLCJuZXh0IiwiQXRvbVBhY2thZ2VSdW5uZXIiLCJfcGFja2FnZXMiLCJfbWVzc2FnZVJvdXRlciIsIl9kaXNwb3NhYmxlcyIsImFkZCIsIm1hcCIsInBhcmFtcyIsInBrZyIsImFsbFNvY2tldHMiLCJTZXQiLCJPYmplY3QiLCJrZXlzIiwiY29uc3VtZWRTZXJ2aWNlcyIsImtleSIsInByb3ZpZGVkU2VydmljZXMiLCJyYXdDb25uZWN0aW9ucyIsIkFycmF5IiwiZnJvbSIsImZpbHRlciIsImhhcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQXFCQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQXpCQTs7Ozs7Ozs7Ozs7QUEyQk8sTUFBTUEsb0JBQU4sQ0FBb0Q7QUFHekQ7QUFHQUMsRUFBQUEsV0FBVyxDQUNU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c0NvbnRlbnQiOlsiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBAZmxvd1xyXG4gKiBAZm9ybWF0XHJcbiAqL1xyXG5cclxuaW1wb3J0IHR5cGUge1Byb2Nlc3NNZXNzYWdlfSBmcm9tICdAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtY29tbW9ucy9wcm9jZXNzJztcclxuaW1wb3J0IHR5cGUge0Nvbm5lY3RhYmxlT2JzZXJ2YWJsZX0gZnJvbSAncnhqcy1jb21wYXQvYnVuZGxlcy9yeGpzLWNvbXBhdC51bWQubWluLmpzJztcclxuaW1wb3J0IHR5cGUge1xyXG4gIEluaXRpYWxpemVNZXNzYWdlLFxyXG4gIFBhY2thZ2VQYXJhbXMsXHJcbiAgUGFja2FnZVJ1bm5lcixcclxuICBTb2NrZXQsXHJcbn0gZnJvbSAnLi90eXBlcyc7XHJcblxyXG5pbXBvcnQge2ZvcmssIGdldE91dHB1dFN0cmVhbX0gZnJvbSAnQGF0b20taWRlLWNvbW11bml0eS9udWNsaWRlLWNvbW1vbnMvcHJvY2Vzcyc7XHJcbmltcG9ydCBVbml2ZXJzYWxEaXNwb3NhYmxlIGZyb20gJ0BhdG9tLWlkZS1jb21tdW5pdHkvbnVjbGlkZS1jb21tb25zL1VuaXZlcnNhbERpc3Bvc2FibGUnO1xyXG5pbXBvcnQge1JlcGxheVN1YmplY3R9IGZyb20gJ3J4anMtY29tcGF0L2J1bmRsZXMvcnhqcy1jb21wYXQudW1kLm1pbi5qcyc7XHJcbmltcG9ydCBNZXNzYWdlUm91dGVyIGZyb20gJy4vTWVzc2FnZVJvdXRlcic7XHJcbmltcG9ydCBhY3RpdmF0ZVBhY2thZ2UgZnJvbSAnLi9hY3RpdmF0ZVBhY2thZ2UnO1xyXG5cclxuZXhwb3J0IGNsYXNzIFByb2Nlc3NQYWNrYWdlUnVubmVyIGltcGxlbWVudHMgUGFja2FnZVJ1bm5lciB7XHJcbiAgX3Byb2Nlc3NTdHJlYW06IENvbm5lY3RhYmxlT2JzZXJ2YWJsZTxjaGlsZF9wcm9jZXNzJENoaWxkUHJvY2Vzcz47XHJcbiAgX291dHB1dFN0cmVhbTogQ29ubmVjdGFibGVPYnNlcnZhYmxlPFByb2Nlc3NNZXNzYWdlPjtcclxuICAvLyAkRmxvd0ZpeE1lICg+PTAuODUuMCkgKFQzNTk4Njg5NikgRmxvdyB1cGdyYWRlIHN1cHByZXNzXHJcbiAgX2Rpc3Bvc2VkID0gbmV3IFJlcGxheVN1YmplY3QoMSk7XHJcblxyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgcGFja2FnZXM6IEFycmF5PFBhY2thZ2VQYXJhbXM+LFxyXG4gICAgbWVzc2FnZVJvdXRlcjogTWVzc2FnZVJvdXRlcixcclxuICApOiB2b2lkIHtcclxuICAgIHRoaXMuX3Byb2Nlc3NTdHJlYW0gPSBmb3JrKHJlcXVpcmUucmVzb2x2ZSgnLi9ydW4tcGFja2FnZS1lbnRyeS5qcycpLCBbXSwge1xyXG4gICAgICBzaWxlbnQ6IHRydWUsXHJcbiAgICB9KVxyXG4gICAgICAudGFrZVVudGlsKHRoaXMuX2Rpc3Bvc2VkKVxyXG4gICAgICAuZG8ocHJvYyA9PiB7XHJcbiAgICAgICAgcHJvYy5vbignbWVzc2FnZScsIG1zZyA9PiB7XHJcbiAgICAgICAgICBtZXNzYWdlUm91dGVyLnNlbmQobXNnKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBleHBvc2VkU29ja2V0cyA9IGdldEV4cG9zZWRTb2NrZXRzKHBhY2thZ2VzLCBtZXNzYWdlUm91dGVyKTtcclxuICAgICAgICBwcm9jLnNlbmQoKHtwYWNrYWdlcywgZXhwb3NlZFNvY2tldHN9OiBJbml0aWFsaXplTWVzc2FnZSkpO1xyXG4gICAgICAgIGV4cG9zZWRTb2NrZXRzLmZvckVhY2goc29ja2V0ID0+IHtcclxuICAgICAgICAgIC8vIEludGVyY2VwdCBpbmNvbWluZyBtZXNzYWdlcyBmb3IgZWFjaCBleHBvc2VkIHNvY2tldC5cclxuICAgICAgICAgIG1lc3NhZ2VSb3V0ZXJcclxuICAgICAgICAgICAgLmdldE1lc3NhZ2VzKG1lc3NhZ2VSb3V0ZXIucmV2ZXJzZVNvY2tldChzb2NrZXQpKVxyXG4gICAgICAgICAgICAudGFrZVVudGlsKHRoaXMuX2Rpc3Bvc2VkKVxyXG4gICAgICAgICAgICAuc3Vic2NyaWJlKG1zZyA9PiBwcm9jLnNlbmQobXNnKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pXHJcbiAgICAgIC8vIFRPRE86IEVycm9yIG9uIGVhcmx5IGNvbXBsZXRpb24uXHJcbiAgICAgIC5zaGFyZSgpXHJcbiAgICAgIC5wdWJsaXNoUmVwbGF5KDEpO1xyXG5cclxuICAgIC8vIE5vdGU6IHRoaXMgd29uJ3Qgc3RhcnQgZW1pdHRpbmcgYW55dGhpbmcgYWN0aXZhdGUoKSBnZXRzIGNhbGxlZC5cclxuICAgIHRoaXMuX291dHB1dFN0cmVhbSA9IHRoaXMuX3Byb2Nlc3NTdHJlYW1cclxuICAgICAgLnN3aXRjaE1hcChwcm9jID0+IGdldE91dHB1dFN0cmVhbShwcm9jKSlcclxuICAgICAgLnB1Ymxpc2goKTtcclxuICB9XHJcblxyXG4gIGFjdGl2YXRlKCk6IHZvaWQge1xyXG4gICAgdGhpcy5fcHJvY2Vzc1N0cmVhbS5jb25uZWN0KCk7XHJcbiAgfVxyXG5cclxuICBvbkRpZEVycm9yKGNhbGxiYWNrOiAoZXJyb3I6IEVycm9yKSA9PiBtaXhlZCk6IElEaXNwb3NhYmxlIHtcclxuICAgIHJldHVybiBuZXcgVW5pdmVyc2FsRGlzcG9zYWJsZShcclxuICAgICAgdGhpcy5fb3V0cHV0U3RyZWFtLnJlZkNvdW50KCkuc3Vic2NyaWJlKHtcclxuICAgICAgICBlcnJvcjogZXJyID0+IHtcclxuICAgICAgICAgIGNhbGxiYWNrKGVycik7XHJcbiAgICAgICAgfSxcclxuICAgICAgfSksXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgZGlzcG9zZSgpOiB2b2lkIHtcclxuICAgIHRoaXMuX2Rpc3Bvc2VkLm5leHQoKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIEF0b20gcGFja2FnZXMgaGF2ZSB0byBydW4gaW4gdGhlIHNhbWUgcHJvY2Vzcy5cclxuZXhwb3J0IGNsYXNzIEF0b21QYWNrYWdlUnVubmVyIGltcGxlbWVudHMgUGFja2FnZVJ1bm5lciB7XHJcbiAgX3BhY2thZ2VzOiBBcnJheTxQYWNrYWdlUGFyYW1zPjtcclxuICBfbWVzc2FnZVJvdXRlcjogTWVzc2FnZVJvdXRlcjtcclxuICBfZGlzcG9zYWJsZXM6IFVuaXZlcnNhbERpc3Bvc2FibGU7XHJcblxyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgcGFja2FnZXM6IEFycmF5PFBhY2thZ2VQYXJhbXM+LFxyXG4gICAgbWVzc2FnZVJvdXRlcjogTWVzc2FnZVJvdXRlcixcclxuICApOiB2b2lkIHtcclxuICAgIHRoaXMuX3BhY2thZ2VzID0gcGFja2FnZXM7XHJcbiAgICB0aGlzLl9tZXNzYWdlUm91dGVyID0gbWVzc2FnZVJvdXRlcjtcclxuICAgIHRoaXMuX2Rpc3Bvc2FibGVzID0gbmV3IFVuaXZlcnNhbERpc3Bvc2FibGUoKTtcclxuICB9XHJcblxyXG4gIGFjdGl2YXRlKCk6IHZvaWQge1xyXG4gICAgdGhpcy5fZGlzcG9zYWJsZXMuYWRkKFxyXG4gICAgICAuLi50aGlzLl9wYWNrYWdlcy5tYXAocGFyYW1zID0+IHtcclxuICAgICAgICBjb25zdCBwa2cgPSBhY3RpdmF0ZVBhY2thZ2UocGFyYW1zLCB0aGlzLl9tZXNzYWdlUm91dGVyKTtcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgaWYgKHBrZy5kaXNwb3NlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcGtnLmRpc3Bvc2UoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICB9KSxcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBkaXNwb3NlKCkge1xyXG4gICAgdGhpcy5fZGlzcG9zYWJsZXMuZGlzcG9zZSgpO1xyXG4gIH1cclxuXHJcbiAgb25EaWRFcnJvcihjYWxsYmFjazogKGVycm9yOiBFcnJvcikgPT4gbWl4ZWQpOiBJRGlzcG9zYWJsZSB7XHJcbiAgICByZXR1cm4gbmV3IFVuaXZlcnNhbERpc3Bvc2FibGUoKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEV4cG9zZWRTb2NrZXRzKFxyXG4gIHBhY2thZ2VzOiBBcnJheTxQYWNrYWdlUGFyYW1zPixcclxuICBtZXNzYWdlUm91dGVyOiBNZXNzYWdlUm91dGVyLFxyXG4pOiBBcnJheTxTb2NrZXQ+IHtcclxuICAvLyBFeHBvc2VkIHNvY2tldHMgYXJlIHRob3NlIHRoYXQgYXJlIGVpdGhlcjpcclxuICAvLyAxKSBwcm92aWRlZCBoZXJlIGJ1dCBub3QgY29uc3VtZWRcclxuICAvLyAyKSBjb25zdW1lZCBoZXJlIGJ1dCBub3QgcHJvdmlkZWQuXHJcbiAgY29uc3QgYWxsU29ja2V0cyA9IG5ldyBTZXQoKTtcclxuICBwYWNrYWdlcy5mb3JFYWNoKHBrZyA9PiB7XHJcbiAgICBPYmplY3Qua2V5cyhwa2cuY29uc3VtZWRTZXJ2aWNlcykuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICBjb25zdCB7c29ja2V0fSA9IHBrZy5jb25zdW1lZFNlcnZpY2VzW2tleV07XHJcbiAgICAgIGFsbFNvY2tldHMuYWRkKHNvY2tldCk7XHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5rZXlzKHBrZy5wcm92aWRlZFNlcnZpY2VzKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgIHBrZy5wcm92aWRlZFNlcnZpY2VzW2tleV0ucmF3Q29ubmVjdGlvbnMuZm9yRWFjaCgoe3NvY2tldH0pID0+IHtcclxuICAgICAgICBhbGxTb2NrZXRzLmFkZChzb2NrZXQpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG4gIHJldHVybiBBcnJheS5mcm9tKGFsbFNvY2tldHMpLmZpbHRlcihcclxuICAgIHNvY2tldCA9PiAhYWxsU29ja2V0cy5oYXMobWVzc2FnZVJvdXRlci5yZXZlcnNlU29ja2V0KHNvY2tldCkpLFxyXG4gICk7XHJcbn1cclxuIl19