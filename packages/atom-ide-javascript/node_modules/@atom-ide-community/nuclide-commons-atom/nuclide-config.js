"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__updateConfigSettingsListener = __updateConfigSettingsListener;
exports.default = void 0;

var _assert = _interopRequireDefault(require("assert"));

var _electron = require("electron");

var _fs = _interopRequireDefault(require("fs"));

var _nullthrows = _interopRequireDefault(require("nullthrows"));

var _season = _interopRequireDefault(require("season"));

var _nuclideUri = _interopRequireDefault(require("@atom-ide-community/nuclide-commons/nuclideUri"));

var _ConfigManager = _interopRequireDefault(require("./ConfigManager"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */
(0, _assert.default)(_electron.remote != null && _electron.remote.ipcMain != null && _electron.ipcRenderer != null);
/**
 * This module provides a wrapper around an atom$Config to be used for storing
 * data not intended to be accessed by Nuclide users (which should be accessed
 * using feature-config or atom.config). These config values are accessed/stored
 * on disk in the NUCLIDE_CONFIG_FILE and should only be modified via the
 * NuclideConfig / ConfigManager functions provided by this module's export
 */

const Config = atom.config.constructor;
const NUCLIDE_CONFIG_FILE = 'nuclide-config.cson';
const UPDATE_NUCLIDE_CONFIG_SETTINGS = 'nuclide-config-update-settings';

const nuclideConfigFilePath = _nuclideUri.default.join((0, _nullthrows.default)(process.env.ATOM_HOME), NUCLIDE_CONFIG_FILE);

function getConfigSettingsFromDisk() {
  let configSettings = {};

  if (_fs.default.existsSync(nuclideConfigFilePath)) {
    configSettings = _season.default.readFileSync(nuclideConfigFilePath);
  }

  return configSettings;
}

const config = new Config({
  mainSource: nuclideConfigFilePath,

  // Reuse applicationDelegate's saveCallback but with nuclideConfig's context.
  // This delegates saving to the config file to atom's main process, which
  // handles saving contention
  saveCallback() {
    atom.applicationDelegate.setUserSettings(this.settings, this.getUserConfigPath());
  }

}); // Reset the settings to match those stored in NUCLIDE_CONFIG_FILE. This sets
// settingsLoaded to true (allowing config to be saved using the saveCallback)

config.resetUserSettings(getConfigSettingsFromDisk());
/**
 * Emit nuclide-config's settings so that other processes can update their
 * config settings to reflect changes values
 */

function emitConfigSettings(settings) {
  _electron.ipcRenderer.send(UPDATE_NUCLIDE_CONFIG_SETTINGS, settings);
}
/**
 * Extend the ConfigManager to overload the set/unset functionality. This is
 * necessary for interprocess communication so that config changes in one window
 * (process) are reflected in the config objects of other windows (processes).
 * Since set/unset writes to disk, we only want one set/unset call to occur for
 * any single action done by a process. The initiating process will call set/unset
 * and then emit the event to other processes, which will update their config objects
 * without writing to disk (via resetUserSettings).
 * Instead of restricting the underlying config set/unset calls to a single "main"
 * process, we call it for any process that calls nuclideConfig.set/unset and rely
 * on Atom's main process to handle any disk writing contention
 */


class NuclideConfig extends _ConfigManager.default {
  // Set the nuclide-config value and emit event with updated config values to
  // push config changes to other processes
  set(keyPath, value, options) {
    const setSuccess = super.set(keyPath, value, options);

    if (setSuccess) {
      emitConfigSettings({
        settings: this._config.settings,
        options
      });
    }

    return setSuccess;
  } // Unset the nuclide-config key and emit event with updated config values to
  // push config changes to other processes


  unset(keyPath, options) {
    super.unset(keyPath, options);
    emitConfigSettings({
      settings: this._config.settings,
      options
    });
  }

}

const nuclideConfig = new NuclideConfig(config);
/**
 * Listen to incoming nuclide-config changes from other processes and reset
 * the current process's config to match that emitted by the emitting process.
 * Clobber the entire config settings object to have all the "latest" values,
 * instead of setting individual key/vals, which may produce a config of merged
 * values from different sources
 */

_electron.remote.ipcMain.on(UPDATE_NUCLIDE_CONFIG_SETTINGS, __updateConfigSettingsListener); // NB: This isn't described correctly in electron-flowtype-definitions, so we'll
// fake it out


// export for testing
function __updateConfigSettingsListener(event, {
  settings,
  options
}) {
  if (event.sender.getOwnerBrowserWindow().id !== _electron.remote.getCurrentWindow().id) {
    // Update all settings without saving to disk
    nuclideConfig.getConfig().resetUserSettings(settings, options);
  }
}

var _default = nuclideConfig;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zLWF0b20vbnVjbGlkZS1jb25maWcuanMiXSwibmFtZXMiOlsicmVtb3RlIiwiaXBjTWFpbiIsImlwY1JlbmRlcmVyIiwiQ29uZmlnIiwiYXRvbSIsImNvbmZpZyIsImNvbnN0cnVjdG9yIiwiTlVDTElERV9DT05GSUdfRklMRSIsIlVQREFURV9OVUNMSURFX0NPTkZJR19TRVRUSU5HUyIsIm51Y2xpZGVDb25maWdGaWxlUGF0aCIsIm51Y2xpZGVVcmkiLCJqb2luIiwicHJvY2VzcyIsImVudiIsIkFUT01fSE9NRSIsImdldENvbmZpZ1NldHRpbmdzRnJvbURpc2siLCJjb25maWdTZXR0aW5ncyIsImZzIiwiZXhpc3RzU3luYyIsIkNTT04iLCJyZWFkRmlsZVN5bmMiLCJtYWluU291cmNlIiwic2F2ZUNhbGxiYWNrIiwiYXBwbGljYXRpb25EZWxlZ2F0ZSIsInNldFVzZXJTZXR0aW5ncyIsInNldHRpbmdzIiwiZ2V0VXNlckNvbmZpZ1BhdGgiLCJyZXNldFVzZXJTZXR0aW5ncyIsImVtaXRDb25maWdTZXR0aW5ncyIsInNlbmQiLCJOdWNsaWRlQ29uZmlnIiwiQ29uZmlnTWFuYWdlciIsInNldCIsImtleVBhdGgiLCJ2YWx1ZSIsIm9wdGlvbnMiLCJzZXRTdWNjZXNzIiwiX2NvbmZpZyIsInVuc2V0IiwibnVjbGlkZUNvbmZpZyIsIm9uIiwiX191cGRhdGVDb25maWdTZXR0aW5nc0xpc3RlbmVyIiwiZXZlbnQiLCJzZW5kZXIiLCJnZXRPd25lckJyb3dzZXJXaW5kb3ciLCJpZCIsImdldEN1cnJlbnRXaW5kb3ciLCJnZXRDb25maWciXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBWUE7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFuQkE7Ozs7Ozs7Ozs7O0FBdUJBLHFCQUFVQSxvQkFBVSxJQUFWLElBQWtCQSxpQkFBT0MsT0FBUCxJQUFrQixJQUFwQyxJQUE0Q0MseUJBQWUsSUFBckU7QUFFQTs7Ozs7Ozs7QUFhQSxNQUFNQyxNQUFNLEdBQUdDLElBQUksQ0FBQ0MsTUFBTCxDQUFZQyxXQUEzQjtBQUNBLE1BQU1DLG1CQUFtQixHQUFHLHFCQUE1QjtBQUNBLE1BQU1DLDhCQUE4QixHQUFHLGdDQUF2Qzs7QUFFQSxNQUFNQyxxQkFBcUIsR0FBR0Msb0JBQVdDLElBQVgsQ0FDNUIseUJBQVdDLE9BQU8sQ0FBQ0MsR0FBUixDQUFZQyxTQUF2QixDQUQ0QixFQUU1QlAsbUJBRjRCLENBQTlCOztBQUtBLFNBQVNRLHlCQUFULEdBQXFDO0FBQ25DLE1BQUlDLGNBQWMsR0FBRyxFQUFyQjs7QUFFQSxNQUFJQyxZQUFHQyxVQUFILENBQWNULHFCQUFkLENBQUosRUFBMEM7QUFDeENPLElBQUFBLGNBQWMsR0FBR0csZ0JBQUtDLFlBQUwsQ0FBa0JYLHFCQUFsQixDQUFqQjtBQUNEOztBQUNELFNBQU9PLGNBQVA7QUFDRDs7QUFFRCxNQUFNWCxNQUFNLEdBQUcsSUFBSUYsTUFBSixDQUFXO0FBQ3hCa0IsRUFBQUEsVUFBVSxFQUFFWixxQkFEWTs7QUFFeEI7QUFDQTtBQUNBO0FBQ0FhLEVBQUFBLFlBQVksR0FBRztBQUNibEIsSUFBQUEsSUFBSSxDQUFDbUIsbUJBQUwsQ0FBeUJDLGVBQXpCLENBQ0UsS0FBS0MsUUFEUCxFQUVFLEtBQUtDLGlCQUFMLEVBRkY7QUFJRDs7QUFWdUIsQ0FBWCxDQUFmLEMsQ0FhQTtBQUNBOztBQUNBckIsTUFBTSxDQUFDc0IsaUJBQVAsQ0FBeUJaLHlCQUF5QixFQUFsRDtBQUVBOzs7OztBQUlBLFNBQVNhLGtCQUFULENBQTRCSCxRQUE1QixFQUE0RDtBQUMxRHZCLHdCQUFZMkIsSUFBWixDQUNFckIsOEJBREYsRUFFR2lCLFFBRkg7QUFJRDtBQUVEOzs7Ozs7Ozs7Ozs7OztBQVlBLE1BQU1LLGFBQU4sU0FBNEJDLHNCQUE1QixDQUEwQztBQUN4QztBQUNBO0FBQ0FDLEVBQUFBLEdBQUcsQ0FDREMsT0FEQyxFQUVEQyxLQUZDLEVBR0RDLE9BSEMsRUFPUTtBQUNULFVBQU1DLFVBQVUsR0FBRyxNQUFNSixHQUFOLENBQVVDLE9BQVYsRUFBbUJDLEtBQW5CLEVBQTBCQyxPQUExQixDQUFuQjs7QUFDQSxRQUFJQyxVQUFKLEVBQWdCO0FBQ2RSLE1BQUFBLGtCQUFrQixDQUFDO0FBQ2pCSCxRQUFBQSxRQUFRLEVBQUUsS0FBS1ksT0FBTCxDQUFhWixRQUROO0FBRWpCVSxRQUFBQTtBQUZpQixPQUFELENBQWxCO0FBSUQ7O0FBQ0QsV0FBT0MsVUFBUDtBQUNELEdBbkJ1QyxDQXFCeEM7QUFDQTs7O0FBQ0FFLEVBQUFBLEtBQUssQ0FDSEwsT0FERyxFQUVIRSxPQUZHLEVBTUc7QUFDTixVQUFNRyxLQUFOLENBQVlMLE9BQVosRUFBcUJFLE9BQXJCO0FBQ0FQLElBQUFBLGtCQUFrQixDQUFDO0FBQ2pCSCxNQUFBQSxRQUFRLEVBQUUsS0FBS1ksT0FBTCxDQUFhWixRQUROO0FBRWpCVSxNQUFBQTtBQUZpQixLQUFELENBQWxCO0FBSUQ7O0FBbkN1Qzs7QUFzQzFDLE1BQU1JLGFBQWEsR0FBRyxJQUFJVCxhQUFKLENBQWtCekIsTUFBbEIsQ0FBdEI7QUFFQTs7Ozs7Ozs7QUFPQUwsaUJBQU9DLE9BQVAsQ0FBZXVDLEVBQWYsQ0FDRWhDLDhCQURGLEVBRUVpQyw4QkFGRixFLENBS0E7QUFDQTs7O0FBS0E7QUFDTyxTQUFTQSw4QkFBVCxDQUNMQyxLQURLLEVBRUw7QUFBQ2pCLEVBQUFBLFFBQUQ7QUFBV1UsRUFBQUE7QUFBWCxDQUZLLEVBR0w7QUFDQSxNQUNFTyxLQUFLLENBQUNDLE1BQU4sQ0FBYUMscUJBQWIsR0FBcUNDLEVBQXJDLEtBQTRDN0MsaUJBQU84QyxnQkFBUCxHQUEwQkQsRUFEeEUsRUFFRTtBQUNBO0FBQ0FOLElBQUFBLGFBQWEsQ0FBQ1EsU0FBZCxHQUEwQnBCLGlCQUExQixDQUE0Q0YsUUFBNUMsRUFBc0RVLE9BQXREO0FBQ0Q7QUFDRjs7ZUFFY0ksYSIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTctcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogQGZsb3dcclxuICogQGZvcm1hdFxyXG4gKi9cclxuXHJcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnYXNzZXJ0JztcclxuaW1wb3J0IHtyZW1vdGUsIGlwY1JlbmRlcmVyfSBmcm9tICdlbGVjdHJvbic7XHJcblxyXG5pbXBvcnQgZnMgZnJvbSAnZnMnO1xyXG5pbXBvcnQgbnVsbHRocm93cyBmcm9tICdudWxsdGhyb3dzJztcclxuaW1wb3J0IENTT04gZnJvbSAnc2Vhc29uJztcclxuaW1wb3J0IG51Y2xpZGVVcmkgZnJvbSAnQGF0b20taWRlLWNvbW11bml0eS9udWNsaWRlLWNvbW1vbnMvbnVjbGlkZVVyaSc7XHJcbmltcG9ydCBDb25maWdNYW5hZ2VyIGZyb20gJy4vQ29uZmlnTWFuYWdlcic7XHJcblxyXG5pbXBvcnQgdHlwZSB7QnJvd3NlcldpbmRvdywgV2ViQ29udGVudHN9IGZyb20gJ0BhdG9tLWlkZS1jb21tdW5pdHkvbnVjbGlkZS1jb21tb25zL2VsZWN0cm9uLXJlbW90ZSc7XHJcblxyXG5pbnZhcmlhbnQocmVtb3RlICE9IG51bGwgJiYgcmVtb3RlLmlwY01haW4gIT0gbnVsbCAmJiBpcGNSZW5kZXJlciAhPSBudWxsKTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIG1vZHVsZSBwcm92aWRlcyBhIHdyYXBwZXIgYXJvdW5kIGFuIGF0b20kQ29uZmlnIHRvIGJlIHVzZWQgZm9yIHN0b3JpbmdcclxuICogZGF0YSBub3QgaW50ZW5kZWQgdG8gYmUgYWNjZXNzZWQgYnkgTnVjbGlkZSB1c2VycyAod2hpY2ggc2hvdWxkIGJlIGFjY2Vzc2VkXHJcbiAqIHVzaW5nIGZlYXR1cmUtY29uZmlnIG9yIGF0b20uY29uZmlnKS4gVGhlc2UgY29uZmlnIHZhbHVlcyBhcmUgYWNjZXNzZWQvc3RvcmVkXHJcbiAqIG9uIGRpc2sgaW4gdGhlIE5VQ0xJREVfQ09ORklHX0ZJTEUgYW5kIHNob3VsZCBvbmx5IGJlIG1vZGlmaWVkIHZpYSB0aGVcclxuICogTnVjbGlkZUNvbmZpZyAvIENvbmZpZ01hbmFnZXIgZnVuY3Rpb25zIHByb3ZpZGVkIGJ5IHRoaXMgbW9kdWxlJ3MgZXhwb3J0XHJcbiAqL1xyXG5cclxudHlwZSBOdWNsaWRlQ29uZmlnU2V0QXJncyA9IHtcclxuICBzZXR0aW5nczogT2JqZWN0LFxyXG4gIG9wdGlvbnM/OiB7c291cmNlPzogc3RyaW5nfSxcclxufTtcclxuXHJcbmNvbnN0IENvbmZpZyA9IGF0b20uY29uZmlnLmNvbnN0cnVjdG9yO1xyXG5jb25zdCBOVUNMSURFX0NPTkZJR19GSUxFID0gJ251Y2xpZGUtY29uZmlnLmNzb24nO1xyXG5jb25zdCBVUERBVEVfTlVDTElERV9DT05GSUdfU0VUVElOR1MgPSAnbnVjbGlkZS1jb25maWctdXBkYXRlLXNldHRpbmdzJztcclxuXHJcbmNvbnN0IG51Y2xpZGVDb25maWdGaWxlUGF0aCA9IG51Y2xpZGVVcmkuam9pbihcclxuICBudWxsdGhyb3dzKHByb2Nlc3MuZW52LkFUT01fSE9NRSksXHJcbiAgTlVDTElERV9DT05GSUdfRklMRSxcclxuKTtcclxuXHJcbmZ1bmN0aW9uIGdldENvbmZpZ1NldHRpbmdzRnJvbURpc2soKSB7XHJcbiAgbGV0IGNvbmZpZ1NldHRpbmdzID0ge307XHJcblxyXG4gIGlmIChmcy5leGlzdHNTeW5jKG51Y2xpZGVDb25maWdGaWxlUGF0aCkpIHtcclxuICAgIGNvbmZpZ1NldHRpbmdzID0gQ1NPTi5yZWFkRmlsZVN5bmMobnVjbGlkZUNvbmZpZ0ZpbGVQYXRoKTtcclxuICB9XHJcbiAgcmV0dXJuIGNvbmZpZ1NldHRpbmdzO1xyXG59XHJcblxyXG5jb25zdCBjb25maWcgPSBuZXcgQ29uZmlnKHtcclxuICBtYWluU291cmNlOiBudWNsaWRlQ29uZmlnRmlsZVBhdGgsXHJcbiAgLy8gUmV1c2UgYXBwbGljYXRpb25EZWxlZ2F0ZSdzIHNhdmVDYWxsYmFjayBidXQgd2l0aCBudWNsaWRlQ29uZmlnJ3MgY29udGV4dC5cclxuICAvLyBUaGlzIGRlbGVnYXRlcyBzYXZpbmcgdG8gdGhlIGNvbmZpZyBmaWxlIHRvIGF0b20ncyBtYWluIHByb2Nlc3MsIHdoaWNoXHJcbiAgLy8gaGFuZGxlcyBzYXZpbmcgY29udGVudGlvblxyXG4gIHNhdmVDYWxsYmFjaygpIHtcclxuICAgIGF0b20uYXBwbGljYXRpb25EZWxlZ2F0ZS5zZXRVc2VyU2V0dGluZ3MoXHJcbiAgICAgIHRoaXMuc2V0dGluZ3MsXHJcbiAgICAgIHRoaXMuZ2V0VXNlckNvbmZpZ1BhdGgoKSxcclxuICAgICk7XHJcbiAgfSxcclxufSk7XHJcblxyXG4vLyBSZXNldCB0aGUgc2V0dGluZ3MgdG8gbWF0Y2ggdGhvc2Ugc3RvcmVkIGluIE5VQ0xJREVfQ09ORklHX0ZJTEUuIFRoaXMgc2V0c1xyXG4vLyBzZXR0aW5nc0xvYWRlZCB0byB0cnVlIChhbGxvd2luZyBjb25maWcgdG8gYmUgc2F2ZWQgdXNpbmcgdGhlIHNhdmVDYWxsYmFjaylcclxuY29uZmlnLnJlc2V0VXNlclNldHRpbmdzKGdldENvbmZpZ1NldHRpbmdzRnJvbURpc2soKSk7XHJcblxyXG4vKipcclxuICogRW1pdCBudWNsaWRlLWNvbmZpZydzIHNldHRpbmdzIHNvIHRoYXQgb3RoZXIgcHJvY2Vzc2VzIGNhbiB1cGRhdGUgdGhlaXJcclxuICogY29uZmlnIHNldHRpbmdzIHRvIHJlZmxlY3QgY2hhbmdlcyB2YWx1ZXNcclxuICovXHJcbmZ1bmN0aW9uIGVtaXRDb25maWdTZXR0aW5ncyhzZXR0aW5nczogTnVjbGlkZUNvbmZpZ1NldEFyZ3MpIHtcclxuICBpcGNSZW5kZXJlci5zZW5kKFxyXG4gICAgVVBEQVRFX05VQ0xJREVfQ09ORklHX1NFVFRJTkdTLFxyXG4gICAgKHNldHRpbmdzOiBOdWNsaWRlQ29uZmlnU2V0QXJncyksXHJcbiAgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEV4dGVuZCB0aGUgQ29uZmlnTWFuYWdlciB0byBvdmVybG9hZCB0aGUgc2V0L3Vuc2V0IGZ1bmN0aW9uYWxpdHkuIFRoaXMgaXNcclxuICogbmVjZXNzYXJ5IGZvciBpbnRlcnByb2Nlc3MgY29tbXVuaWNhdGlvbiBzbyB0aGF0IGNvbmZpZyBjaGFuZ2VzIGluIG9uZSB3aW5kb3dcclxuICogKHByb2Nlc3MpIGFyZSByZWZsZWN0ZWQgaW4gdGhlIGNvbmZpZyBvYmplY3RzIG9mIG90aGVyIHdpbmRvd3MgKHByb2Nlc3NlcykuXHJcbiAqIFNpbmNlIHNldC91bnNldCB3cml0ZXMgdG8gZGlzaywgd2Ugb25seSB3YW50IG9uZSBzZXQvdW5zZXQgY2FsbCB0byBvY2N1ciBmb3JcclxuICogYW55IHNpbmdsZSBhY3Rpb24gZG9uZSBieSBhIHByb2Nlc3MuIFRoZSBpbml0aWF0aW5nIHByb2Nlc3Mgd2lsbCBjYWxsIHNldC91bnNldFxyXG4gKiBhbmQgdGhlbiBlbWl0IHRoZSBldmVudCB0byBvdGhlciBwcm9jZXNzZXMsIHdoaWNoIHdpbGwgdXBkYXRlIHRoZWlyIGNvbmZpZyBvYmplY3RzXHJcbiAqIHdpdGhvdXQgd3JpdGluZyB0byBkaXNrICh2aWEgcmVzZXRVc2VyU2V0dGluZ3MpLlxyXG4gKiBJbnN0ZWFkIG9mIHJlc3RyaWN0aW5nIHRoZSB1bmRlcmx5aW5nIGNvbmZpZyBzZXQvdW5zZXQgY2FsbHMgdG8gYSBzaW5nbGUgXCJtYWluXCJcclxuICogcHJvY2Vzcywgd2UgY2FsbCBpdCBmb3IgYW55IHByb2Nlc3MgdGhhdCBjYWxscyBudWNsaWRlQ29uZmlnLnNldC91bnNldCBhbmQgcmVseVxyXG4gKiBvbiBBdG9tJ3MgbWFpbiBwcm9jZXNzIHRvIGhhbmRsZSBhbnkgZGlzayB3cml0aW5nIGNvbnRlbnRpb25cclxuICovXHJcbmNsYXNzIE51Y2xpZGVDb25maWcgZXh0ZW5kcyBDb25maWdNYW5hZ2VyIHtcclxuICAvLyBTZXQgdGhlIG51Y2xpZGUtY29uZmlnIHZhbHVlIGFuZCBlbWl0IGV2ZW50IHdpdGggdXBkYXRlZCBjb25maWcgdmFsdWVzIHRvXHJcbiAgLy8gcHVzaCBjb25maWcgY2hhbmdlcyB0byBvdGhlciBwcm9jZXNzZXNcclxuICBzZXQoXHJcbiAgICBrZXlQYXRoOiBzdHJpbmcsXHJcbiAgICB2YWx1ZTogP21peGVkLFxyXG4gICAgb3B0aW9ucz86IHtcclxuICAgICAgc2NvcGVTZWxlY3Rvcj86IHN0cmluZyxcclxuICAgICAgc291cmNlPzogc3RyaW5nLFxyXG4gICAgfSxcclxuICApOiBib29sZWFuIHtcclxuICAgIGNvbnN0IHNldFN1Y2Nlc3MgPSBzdXBlci5zZXQoa2V5UGF0aCwgdmFsdWUsIG9wdGlvbnMpO1xyXG4gICAgaWYgKHNldFN1Y2Nlc3MpIHtcclxuICAgICAgZW1pdENvbmZpZ1NldHRpbmdzKHtcclxuICAgICAgICBzZXR0aW5nczogdGhpcy5fY29uZmlnLnNldHRpbmdzLFxyXG4gICAgICAgIG9wdGlvbnMsXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNldFN1Y2Nlc3M7XHJcbiAgfVxyXG5cclxuICAvLyBVbnNldCB0aGUgbnVjbGlkZS1jb25maWcga2V5IGFuZCBlbWl0IGV2ZW50IHdpdGggdXBkYXRlZCBjb25maWcgdmFsdWVzIHRvXHJcbiAgLy8gcHVzaCBjb25maWcgY2hhbmdlcyB0byBvdGhlciBwcm9jZXNzZXNcclxuICB1bnNldChcclxuICAgIGtleVBhdGg6IHN0cmluZyxcclxuICAgIG9wdGlvbnM/OiB7XHJcbiAgICAgIHNjb3BlU2VsZWN0b3I/OiBzdHJpbmcsXHJcbiAgICAgIHNvdXJjZT86IHN0cmluZyxcclxuICAgIH0sXHJcbiAgKTogdm9pZCB7XHJcbiAgICBzdXBlci51bnNldChrZXlQYXRoLCBvcHRpb25zKTtcclxuICAgIGVtaXRDb25maWdTZXR0aW5ncyh7XHJcbiAgICAgIHNldHRpbmdzOiB0aGlzLl9jb25maWcuc2V0dGluZ3MsXHJcbiAgICAgIG9wdGlvbnMsXHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IG51Y2xpZGVDb25maWcgPSBuZXcgTnVjbGlkZUNvbmZpZyhjb25maWcpO1xyXG5cclxuLyoqXHJcbiAqIExpc3RlbiB0byBpbmNvbWluZyBudWNsaWRlLWNvbmZpZyBjaGFuZ2VzIGZyb20gb3RoZXIgcHJvY2Vzc2VzIGFuZCByZXNldFxyXG4gKiB0aGUgY3VycmVudCBwcm9jZXNzJ3MgY29uZmlnIHRvIG1hdGNoIHRoYXQgZW1pdHRlZCBieSB0aGUgZW1pdHRpbmcgcHJvY2Vzcy5cclxuICogQ2xvYmJlciB0aGUgZW50aXJlIGNvbmZpZyBzZXR0aW5ncyBvYmplY3QgdG8gaGF2ZSBhbGwgdGhlIFwibGF0ZXN0XCIgdmFsdWVzLFxyXG4gKiBpbnN0ZWFkIG9mIHNldHRpbmcgaW5kaXZpZHVhbCBrZXkvdmFscywgd2hpY2ggbWF5IHByb2R1Y2UgYSBjb25maWcgb2YgbWVyZ2VkXHJcbiAqIHZhbHVlcyBmcm9tIGRpZmZlcmVudCBzb3VyY2VzXHJcbiAqL1xyXG5yZW1vdGUuaXBjTWFpbi5vbihcclxuICBVUERBVEVfTlVDTElERV9DT05GSUdfU0VUVElOR1MsXHJcbiAgX191cGRhdGVDb25maWdTZXR0aW5nc0xpc3RlbmVyLFxyXG4pO1xyXG5cclxuLy8gTkI6IFRoaXMgaXNuJ3QgZGVzY3JpYmVkIGNvcnJlY3RseSBpbiBlbGVjdHJvbi1mbG93dHlwZS1kZWZpbml0aW9ucywgc28gd2UnbGxcclxuLy8gZmFrZSBpdCBvdXRcclxudHlwZSBTZW5kZXJHZXRCcm93c2VyV2luZG93ID0ge3xcclxuICBnZXRPd25lckJyb3dzZXJXaW5kb3c6ICgpID0+IEJyb3dzZXJXaW5kb3csXHJcbnx9O1xyXG5cclxuLy8gZXhwb3J0IGZvciB0ZXN0aW5nXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3VwZGF0ZUNvbmZpZ1NldHRpbmdzTGlzdGVuZXIoXHJcbiAgZXZlbnQ6IHtyZXR1cm5WYWx1ZTogbWl4ZWQsIHNlbmRlcjogV2ViQ29udGVudHMgJiBTZW5kZXJHZXRCcm93c2VyV2luZG93fSxcclxuICB7c2V0dGluZ3MsIG9wdGlvbnN9OiBOdWNsaWRlQ29uZmlnU2V0QXJncyxcclxuKSB7XHJcbiAgaWYgKFxyXG4gICAgZXZlbnQuc2VuZGVyLmdldE93bmVyQnJvd3NlcldpbmRvdygpLmlkICE9PSByZW1vdGUuZ2V0Q3VycmVudFdpbmRvdygpLmlkXHJcbiAgKSB7XHJcbiAgICAvLyBVcGRhdGUgYWxsIHNldHRpbmdzIHdpdGhvdXQgc2F2aW5nIHRvIGRpc2tcclxuICAgIG51Y2xpZGVDb25maWcuZ2V0Q29uZmlnKCkucmVzZXRVc2VyU2V0dGluZ3Moc2V0dGluZ3MsIG9wdGlvbnMpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgbnVjbGlkZUNvbmZpZztcclxuIl19