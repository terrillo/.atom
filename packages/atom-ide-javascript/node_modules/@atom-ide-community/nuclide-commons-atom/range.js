"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.wordAtPosition = wordAtPosition;
exports.trimRange = trimRange;
exports.getWordFromMouseEvent = getWordFromMouseEvent;
exports.getWordFromCursorOrSelection = getWordFromCursorOrSelection;

var _atom = require("atom");

var _assert = _interopRequireDefault(require("assert"));

var _range = require("@atom-ide-community/nuclide-commons/range");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */

/**
 * Finds the word at the position. You can either provide a word regex yourself,
 * or have Atom use the word regex in force at the scopes at that position,
 * in which case it uses the optional includeNonWordCharacters, default true.
 * (I know that's a weird default but it follows Atom's convention...)
 */
function wordAtPosition(editor, position, wordRegex) {
  let wordRegex_;

  if (wordRegex instanceof RegExp) {
    wordRegex_ = wordRegex;
  } else {
    // What is the word regex associated with the position? We'd like to use
    // atom$Cursor.wordRegExp, except that function gets the regex associated
    // with the editor's current cursor while we want the regex associated with
    // the specific position. So we re-implement it ourselves...
    const nonWordChars = editor.getNonWordCharacters(position);
    const escaped = nonWordChars.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&'); // We copied this escaping regex from atom$Cursor.wordRegexp, rather than
    // using the library function 'escapeStringRegExp'. That's because the
    // library function doesn't escape the hyphen character and so is
    // unsuitable for use inside a range.

    let r = `^[\t ]*$|[^\\s${escaped}]+`;

    if (wordRegex == null || wordRegex.includeNonWordCharacters) {
      r += `|[${escaped}]+`;
    }

    wordRegex_ = new RegExp(r, 'g');
  }

  return (0, _range.wordAtPositionFromBuffer)(editor.getBuffer(), position, wordRegex_);
}
/**
 * Gets the trimmed range from a given range, i.e. moves the start and end points
 * to the first and last non-whitespace characters (or specified regex)
 * within the range respectively.
 *
 * @param editor       the editor containing the range
 * @param rangeToTrim  the range to trim
 * @param stopRegex    stop trimming when the first match is found for this regex,
 *   defaults to first non-whitespace character
 * @return atom$Range  the trimmed range
 */


function trimRange(editor, rangeToTrim, stopRegex = /\S/) {
  const buffer = editor.getBuffer();
  let {
    start,
    end
  } = rangeToTrim;
  buffer.scanInRange(stopRegex, rangeToTrim, ({
    range,
    stop
  }) => {
    start = range.start;
    stop();
  });
  buffer.backwardsScanInRange(stopRegex, rangeToTrim, ({
    range,
    stop
  }) => {
    end = range.end;
    stop();
  });
  return new _atom.Range(start, end);
}

function getSingleWordAtPosition(editor, position) {
  const match = wordAtPosition(editor, position); // We should only receive a single identifier from a single point.

  if (match == null || match.wordMatch.length !== 1) {
    return null;
  }

  return match.wordMatch[0];
}
/**
 * Gets the word being right-clicked on in a MouseEvent. A good use case for
 * this is performing an action on a word from a context menu.
 *
 * @param editor  the editor containing the word where the MouseEvent occurred
 *   from
 * @param event   the MouseEvent containing the screen position of the click
 */


function getWordFromMouseEvent(editor, event) {
  // We can't immediately get the identifier right-clicked on from
  // the MouseEvent. Using its target element content would work in
  // some cases but wouldn't work if there was additional content
  // in the same element, such as in a comment.
  const component = editor.getElement().component;
  (0, _assert.default)(component); // This solution doesn't feel ideal but it is the way hyperclick does it.

  const point = component.screenPositionForMouseEvent(event);
  return getSingleWordAtPosition(editor, point);
}
/**
 * Attempts to get a word from the last selection or cursor. A good use case for
 * this is performing an action on an 'active' word after a command is triggered
 * via a keybinding.
 *
 * @param editor  the editor containing the 'active' word when the keybinding is
 *   triggered
 */


function getWordFromCursorOrSelection(editor) {
  const selection = editor.getSelectedText();

  if (selection && selection.length > 0) {
    return selection;
  } // There was no selection so we can go ahead and try the cursor position.


  const point = editor.getCursorScreenPosition();
  return getSingleWordAtPosition(editor, point);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zLWF0b20vcmFuZ2UuanMiXSwibmFtZXMiOlsid29yZEF0UG9zaXRpb24iLCJlZGl0b3IiLCJwb3NpdGlvbiIsIndvcmRSZWdleCIsIndvcmRSZWdleF8iLCJSZWdFeHAiLCJub25Xb3JkQ2hhcnMiLCJnZXROb25Xb3JkQ2hhcmFjdGVycyIsImVzY2FwZWQiLCJyZXBsYWNlIiwiciIsImluY2x1ZGVOb25Xb3JkQ2hhcmFjdGVycyIsImdldEJ1ZmZlciIsInRyaW1SYW5nZSIsInJhbmdlVG9UcmltIiwic3RvcFJlZ2V4IiwiYnVmZmVyIiwic3RhcnQiLCJlbmQiLCJzY2FuSW5SYW5nZSIsInJhbmdlIiwic3RvcCIsImJhY2t3YXJkc1NjYW5JblJhbmdlIiwiUmFuZ2UiLCJnZXRTaW5nbGVXb3JkQXRQb3NpdGlvbiIsIm1hdGNoIiwid29yZE1hdGNoIiwibGVuZ3RoIiwiZ2V0V29yZEZyb21Nb3VzZUV2ZW50IiwiZXZlbnQiLCJjb21wb25lbnQiLCJnZXRFbGVtZW50IiwicG9pbnQiLCJzY3JlZW5Qb3NpdGlvbkZvck1vdXNlRXZlbnQiLCJnZXRXb3JkRnJvbUN1cnNvck9yU2VsZWN0aW9uIiwic2VsZWN0aW9uIiwiZ2V0U2VsZWN0ZWRUZXh0IiwiZ2V0Q3Vyc29yU2NyZWVuUG9zaXRpb24iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFZQTs7QUFDQTs7QUFDQTs7OztBQWRBOzs7Ozs7Ozs7Ozs7QUFnQkE7Ozs7OztBQU1PLFNBQVNBLGNBQVQsQ0FDTEMsTUFESyxFQUVMQyxRQUZLLEVBR0xDLFNBSEssRUFJMkM7QUFDaEQsTUFBSUMsVUFBSjs7QUFDQSxNQUFJRCxTQUFTLFlBQVlFLE1BQXpCLEVBQWlDO0FBQy9CRCxJQUFBQSxVQUFVLEdBQUdELFNBQWI7QUFDRCxHQUZELE1BRU87QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQU1HLFlBQVksR0FBR0wsTUFBTSxDQUFDTSxvQkFBUCxDQUE0QkwsUUFB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OUI7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTctcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogQGZsb3cgc3RyaWN0LWxvY2FsXHJcbiAqIEBmb3JtYXRcclxuICovXHJcblxyXG5pbXBvcnQge1JhbmdlfSBmcm9tICdhdG9tJztcclxuaW1wb3J0IGludmFyaWFudCBmcm9tICdhc3NlcnQnO1xyXG5pbXBvcnQge3dvcmRBdFBvc2l0aW9uRnJvbUJ1ZmZlcn0gZnJvbSAnQGF0b20taWRlLWNvbW11bml0eS9udWNsaWRlLWNvbW1vbnMvcmFuZ2UnO1xyXG5cclxuLyoqXHJcbiAqIEZpbmRzIHRoZSB3b3JkIGF0IHRoZSBwb3NpdGlvbi4gWW91IGNhbiBlaXRoZXIgcHJvdmlkZSBhIHdvcmQgcmVnZXggeW91cnNlbGYsXHJcbiAqIG9yIGhhdmUgQXRvbSB1c2UgdGhlIHdvcmQgcmVnZXggaW4gZm9yY2UgYXQgdGhlIHNjb3BlcyBhdCB0aGF0IHBvc2l0aW9uLFxyXG4gKiBpbiB3aGljaCBjYXNlIGl0IHVzZXMgdGhlIG9wdGlvbmFsIGluY2x1ZGVOb25Xb3JkQ2hhcmFjdGVycywgZGVmYXVsdCB0cnVlLlxyXG4gKiAoSSBrbm93IHRoYXQncyBhIHdlaXJkIGRlZmF1bHQgYnV0IGl0IGZvbGxvd3MgQXRvbSdzIGNvbnZlbnRpb24uLi4pXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gd29yZEF0UG9zaXRpb24oXHJcbiAgZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IsXHJcbiAgcG9zaXRpb246IGF0b20kUG9pbnRPYmplY3QsXHJcbiAgd29yZFJlZ2V4PzogUmVnRXhwIHwge2luY2x1ZGVOb25Xb3JkQ2hhcmFjdGVyczogYm9vbGVhbn0sXHJcbik6ID97d29yZE1hdGNoOiBBcnJheTxzdHJpbmc+LCByYW5nZTogYXRvbSRSYW5nZX0ge1xyXG4gIGxldCB3b3JkUmVnZXhfO1xyXG4gIGlmICh3b3JkUmVnZXggaW5zdGFuY2VvZiBSZWdFeHApIHtcclxuICAgIHdvcmRSZWdleF8gPSB3b3JkUmVnZXg7XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIFdoYXQgaXMgdGhlIHdvcmQgcmVnZXggYXNzb2NpYXRlZCB3aXRoIHRoZSBwb3NpdGlvbj8gV2UnZCBsaWtlIHRvIHVzZVxyXG4gICAgLy8gYXRvbSRDdXJzb3Iud29yZFJlZ0V4cCwgZXhjZXB0IHRoYXQgZnVuY3Rpb24gZ2V0cyB0aGUgcmVnZXggYXNzb2NpYXRlZFxyXG4gICAgLy8gd2l0aCB0aGUgZWRpdG9yJ3MgY3VycmVudCBjdXJzb3Igd2hpbGUgd2Ugd2FudCB0aGUgcmVnZXggYXNzb2NpYXRlZCB3aXRoXHJcbiAgICAvLyB0aGUgc3BlY2lmaWMgcG9zaXRpb24uIFNvIHdlIHJlLWltcGxlbWVudCBpdCBvdXJzZWx2ZXMuLi5cclxuICAgIGNvbnN0IG5vbldvcmRDaGFycyA9IGVkaXRvci5nZXROb25Xb3JkQ2hhcmFjdGVycyhwb3NpdGlvbik7XHJcbiAgICBjb25zdCBlc2NhcGVkID0gbm9uV29yZENoYXJzLnJlcGxhY2UoL1stL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKTtcclxuICAgIC8vIFdlIGNvcGllZCB0aGlzIGVzY2FwaW5nIHJlZ2V4IGZyb20gYXRvbSRDdXJzb3Iud29yZFJlZ2V4cCwgcmF0aGVyIHRoYW5cclxuICAgIC8vIHVzaW5nIHRoZSBsaWJyYXJ5IGZ1bmN0aW9uICdlc2NhcGVTdHJpbmdSZWdFeHAnLiBUaGF0J3MgYmVjYXVzZSB0aGVcclxuICAgIC8vIGxpYnJhcnkgZnVuY3Rpb24gZG9lc24ndCBlc2NhcGUgdGhlIGh5cGhlbiBjaGFyYWN0ZXIgYW5kIHNvIGlzXHJcbiAgICAvLyB1bnN1aXRhYmxlIGZvciB1c2UgaW5zaWRlIGEgcmFuZ2UuXHJcbiAgICBsZXQgciA9IGBeW1xcdCBdKiR8W15cXFxccyR7ZXNjYXBlZH1dK2A7XHJcbiAgICBpZiAod29yZFJlZ2V4ID09IG51bGwgfHwgd29yZFJlZ2V4LmluY2x1ZGVOb25Xb3JkQ2hhcmFjdGVycykge1xyXG4gICAgICByICs9IGB8WyR7ZXNjYXBlZH1dK2A7XHJcbiAgICB9XHJcbiAgICB3b3JkUmVnZXhfID0gbmV3IFJlZ0V4cChyLCAnZycpO1xyXG4gIH1cclxuICByZXR1cm4gd29yZEF0UG9zaXRpb25Gcm9tQnVmZmVyKGVkaXRvci5nZXRCdWZmZXIoKSwgcG9zaXRpb24sIHdvcmRSZWdleF8pO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgdHJpbW1lZCByYW5nZSBmcm9tIGEgZ2l2ZW4gcmFuZ2UsIGkuZS4gbW92ZXMgdGhlIHN0YXJ0IGFuZCBlbmQgcG9pbnRzXHJcbiAqIHRvIHRoZSBmaXJzdCBhbmQgbGFzdCBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzIChvciBzcGVjaWZpZWQgcmVnZXgpXHJcbiAqIHdpdGhpbiB0aGUgcmFuZ2UgcmVzcGVjdGl2ZWx5LlxyXG4gKlxyXG4gKiBAcGFyYW0gZWRpdG9yICAgICAgIHRoZSBlZGl0b3IgY29udGFpbmluZyB0aGUgcmFuZ2VcclxuICogQHBhcmFtIHJhbmdlVG9UcmltICB0aGUgcmFuZ2UgdG8gdHJpbVxyXG4gKiBAcGFyYW0gc3RvcFJlZ2V4ICAgIHN0b3AgdHJpbW1pbmcgd2hlbiB0aGUgZmlyc3QgbWF0Y2ggaXMgZm91bmQgZm9yIHRoaXMgcmVnZXgsXHJcbiAqICAgZGVmYXVsdHMgdG8gZmlyc3Qgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyXHJcbiAqIEByZXR1cm4gYXRvbSRSYW5nZSAgdGhlIHRyaW1tZWQgcmFuZ2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB0cmltUmFuZ2UoXHJcbiAgZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IsXHJcbiAgcmFuZ2VUb1RyaW06IGF0b20kUmFuZ2UsXHJcbiAgc3RvcFJlZ2V4OiBSZWdFeHAgPSAvXFxTLyxcclxuKTogYXRvbSRSYW5nZSB7XHJcbiAgY29uc3QgYnVmZmVyID0gZWRpdG9yLmdldEJ1ZmZlcigpO1xyXG4gIGxldCB7c3RhcnQsIGVuZH0gPSByYW5nZVRvVHJpbTtcclxuICBidWZmZXIuc2NhbkluUmFuZ2Uoc3RvcFJlZ2V4LCByYW5nZVRvVHJpbSwgKHtyYW5nZSwgc3RvcH0pID0+IHtcclxuICAgIHN0YXJ0ID0gcmFuZ2Uuc3RhcnQ7XHJcbiAgICBzdG9wKCk7XHJcbiAgfSk7XHJcbiAgYnVmZmVyLmJhY2t3YXJkc1NjYW5JblJhbmdlKHN0b3BSZWdleCwgcmFuZ2VUb1RyaW0sICh7cmFuZ2UsIHN0b3B9KSA9PiB7XHJcbiAgICBlbmQgPSByYW5nZS5lbmQ7XHJcbiAgICBzdG9wKCk7XHJcbiAgfSk7XHJcbiAgcmV0dXJuIG5ldyBSYW5nZShzdGFydCwgZW5kKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0U2luZ2xlV29yZEF0UG9zaXRpb24oXHJcbiAgZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IsXHJcbiAgcG9zaXRpb246IGF0b20kUG9pbnQsXHJcbik6ID9zdHJpbmcge1xyXG4gIGNvbnN0IG1hdGNoID0gd29yZEF0UG9zaXRpb24oZWRpdG9yLCBwb3NpdGlvbik7XHJcbiAgLy8gV2Ugc2hvdWxkIG9ubHkgcmVjZWl2ZSBhIHNpbmdsZSBpZGVudGlmaWVyIGZyb20gYSBzaW5nbGUgcG9pbnQuXHJcbiAgaWYgKG1hdGNoID09IG51bGwgfHwgbWF0Y2gud29yZE1hdGNoLmxlbmd0aCAhPT0gMSkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbWF0Y2gud29yZE1hdGNoWzBdO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgd29yZCBiZWluZyByaWdodC1jbGlja2VkIG9uIGluIGEgTW91c2VFdmVudC4gQSBnb29kIHVzZSBjYXNlIGZvclxyXG4gKiB0aGlzIGlzIHBlcmZvcm1pbmcgYW4gYWN0aW9uIG9uIGEgd29yZCBmcm9tIGEgY29udGV4dCBtZW51LlxyXG4gKlxyXG4gKiBAcGFyYW0gZWRpdG9yICB0aGUgZWRpdG9yIGNvbnRhaW5pbmcgdGhlIHdvcmQgd2hlcmUgdGhlIE1vdXNlRXZlbnQgb2NjdXJyZWRcclxuICogICBmcm9tXHJcbiAqIEBwYXJhbSBldmVudCAgIHRoZSBNb3VzZUV2ZW50IGNvbnRhaW5pbmcgdGhlIHNjcmVlbiBwb3NpdGlvbiBvZiB0aGUgY2xpY2tcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRXb3JkRnJvbU1vdXNlRXZlbnQoXHJcbiAgZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IsXHJcbiAgZXZlbnQ6IE1vdXNlRXZlbnQsXHJcbik6ID9zdHJpbmcge1xyXG4gIC8vIFdlIGNhbid0IGltbWVkaWF0ZWx5IGdldCB0aGUgaWRlbnRpZmllciByaWdodC1jbGlja2VkIG9uIGZyb21cclxuICAvLyB0aGUgTW91c2VFdmVudC4gVXNpbmcgaXRzIHRhcmdldCBlbGVtZW50IGNvbnRlbnQgd291bGQgd29yayBpblxyXG4gIC8vIHNvbWUgY2FzZXMgYnV0IHdvdWxkbid0IHdvcmsgaWYgdGhlcmUgd2FzIGFkZGl0aW9uYWwgY29udGVudFxyXG4gIC8vIGluIHRoZSBzYW1lIGVsZW1lbnQsIHN1Y2ggYXMgaW4gYSBjb21tZW50LlxyXG4gIGNvbnN0IGNvbXBvbmVudCA9IGVkaXRvci5nZXRFbGVtZW50KCkuY29tcG9uZW50O1xyXG4gIGludmFyaWFudChjb21wb25lbnQpO1xyXG4gIC8vIFRoaXMgc29sdXRpb24gZG9lc24ndCBmZWVsIGlkZWFsIGJ1dCBpdCBpcyB0aGUgd2F5IGh5cGVyY2xpY2sgZG9lcyBpdC5cclxuICBjb25zdCBwb2ludCA9IGNvbXBvbmVudC5zY3JlZW5Qb3NpdGlvbkZvck1vdXNlRXZlbnQoZXZlbnQpO1xyXG4gIHJldHVybiBnZXRTaW5nbGVXb3JkQXRQb3NpdGlvbihlZGl0b3IsIHBvaW50KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEF0dGVtcHRzIHRvIGdldCBhIHdvcmQgZnJvbSB0aGUgbGFzdCBzZWxlY3Rpb24gb3IgY3Vyc29yLiBBIGdvb2QgdXNlIGNhc2UgZm9yXHJcbiAqIHRoaXMgaXMgcGVyZm9ybWluZyBhbiBhY3Rpb24gb24gYW4gJ2FjdGl2ZScgd29yZCBhZnRlciBhIGNvbW1hbmQgaXMgdHJpZ2dlcmVkXHJcbiAqIHZpYSBhIGtleWJpbmRpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSBlZGl0b3IgIHRoZSBlZGl0b3IgY29udGFpbmluZyB0aGUgJ2FjdGl2ZScgd29yZCB3aGVuIHRoZSBrZXliaW5kaW5nIGlzXHJcbiAqICAgdHJpZ2dlcmVkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0V29yZEZyb21DdXJzb3JPclNlbGVjdGlvbihlZGl0b3I6IGF0b20kVGV4dEVkaXRvcik6ID9zdHJpbmcge1xyXG4gIGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3RlZFRleHQoKTtcclxuICBpZiAoc2VsZWN0aW9uICYmIHNlbGVjdGlvbi5sZW5ndGggPiAwKSB7XHJcbiAgICByZXR1cm4gc2VsZWN0aW9uO1xyXG4gIH1cclxuXHJcbiAgLy8gVGhlcmUgd2FzIG5vIHNlbGVjdGlvbiBzbyB3ZSBjYW4gZ28gYWhlYWQgYW5kIHRyeSB0aGUgY3Vyc29yIHBvc2l0aW9uLlxyXG4gIGNvbnN0IHBvaW50ID0gZWRpdG9yLmdldEN1cnNvclNjcmVlblBvc2l0aW9uKCk7XHJcbiAgcmV0dXJuIGdldFNpbmdsZVdvcmRBdFBvc2l0aW9uKGVkaXRvciwgcG9pbnQpO1xyXG59XHJcbiJdfQ==