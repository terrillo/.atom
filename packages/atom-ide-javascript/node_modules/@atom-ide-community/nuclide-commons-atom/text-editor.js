"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.existingEditorForUri = existingEditorForUri;
exports.existingEditorForBuffer = existingEditorForBuffer;
exports.getViewOfEditor = getViewOfEditor;
exports.getScrollTop = getScrollTop;
exports.setScrollTop = setScrollTop;
exports.setPositionAndScroll = setPositionAndScroll;
exports.getCursorPositions = getCursorPositions;
exports.observeEditorDestroy = observeEditorDestroy;
exports.enforceReadOnlyEditor = enforceReadOnlyEditor;
exports.enforceSoftWrap = enforceSoftWrap;
exports.isValidTextEditor = isValidTextEditor;
exports.centerScrollToBufferLine = centerScrollToBufferLine;

var _assert = _interopRequireDefault(require("assert"));

var _atom = require("atom");

var _rxjsCompatUmdMin = require("rxjs-compat/bundles/rxjs-compat.umd.min.js");

var _event = require("@atom-ide-community/nuclide-commons/event");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */

/**
 * Returns a text editor that has the given path open, or null if none exists. If there are multiple
 * text editors for this path, one is chosen arbitrarily.
 */
function existingEditorForUri(path) {
  // This isn't ideal but realistically iterating through even a few hundred editors shouldn't be a
  // real problem. And if you have more than a few hundred you probably have bigger problems.
  for (const editor of atom.workspace.getTextEditors()) {
    if (editor.getPath() === path) {
      return editor;
    }
  }

  return null;
}
/**
 * Returns a text editor that has the given buffer open, or null if none exists. If there are
 * multiple text editors for this buffer, one is chosen arbitrarily.
 */


function existingEditorForBuffer(buffer) {
  // This isn't ideal but realistically iterating through even a few hundred editors shouldn't be a
  // real problem. And if you have more than a few hundred you probably have bigger problems.
  for (const editor of atom.workspace.getTextEditors()) {
    if (editor.getBuffer() === buffer) {
      return editor;
    }
  }

  return null;
}

function getViewOfEditor(editor) {
  return atom.views.getView(editor);
}

function getScrollTop(editor) {
  return getViewOfEditor(editor).getScrollTop();
}

function setScrollTop(editor, scrollTop) {
  getViewOfEditor(editor).setScrollTop(scrollTop);
}
/**
 * Does a best effort to set an editor pane to a given cursor position & scroll.
 * Does not ensure that the current cursor position is visible.
 *
 * Can be used with editor.getCursorBufferPosition() & getScrollTop() to restore
 * an editors cursor and scroll.
 */


function setPositionAndScroll(editor, position, scrollTop) {
  editor.setCursorBufferPosition(position, {
    autoscroll: false
  });
  setScrollTop(editor, scrollTop);
}

function getCursorPositions(editor) {
  return _rxjsCompatUmdMin.Observable.defer(() => {
    // This will behave strangely in the face of multiple cursors. Consider supporting multiple
    // cursors in the future.
    const cursor = editor.getCursors()[0];
    (0, _assert.default)(cursor != null);
    return _rxjsCompatUmdMin.Observable.merge(_rxjsCompatUmdMin.Observable.of(cursor.getBufferPosition()), (0, _event.observableFromSubscribeFunction)(cursor.onDidChangePosition.bind(cursor)).map(event => event.newBufferPosition));
  });
}

function observeEditorDestroy(editor) {
  return (0, _event.observableFromSubscribeFunction)(editor.onDidDestroy.bind(editor)).map(event => editor).take(1);
} // Use atom readOnly attribute to set read-only state.


function enforceReadOnlyEditor(textEditor, readOnlyExceptions = ['append', 'setText']) {
  textEditor.getElement().setAttribute('readonly', '');
  return {
    dispose() {
      textEditor.getElement().removeAttribute('readonly');
    }

  };
} // Turn off soft wrap setting for these editors so diffs properly align.
// Some text editor register sometimes override the set soft wrapping
// after mounting an editor to the workspace - here, that's watched and reset to `false`.


function enforceSoftWrap(editor, enforcedSoftWrap) {
  editor.setSoftWrapped(enforcedSoftWrap);
  return editor.onDidChangeSoftWrapped(softWrapped => {
    if (softWrapped !== enforcedSoftWrap) {
      // Reset the overridden softWrap to `false` once the operation completes.
      process.nextTick(() => {
        if (!editor.isDestroyed()) {
          editor.setSoftWrapped(enforcedSoftWrap);
        }
      });
    }
  });
}
/**
 * Checks if an object (typically an Atom pane) is a TextEditor.
 * Could be replaced with atom.workspace.isValidTextEditor,
 * but Flow doesn't support %checks in methods yet.
 */


function isValidTextEditor(item) {
  return item instanceof _atom.TextEditor;
}

function centerScrollToBufferLine(textEditorElement, bufferLineNumber) {
  const textEditor = textEditorElement.getModel();
  const pixelPositionTop = textEditorElement.pixelPositionForBufferPosition([bufferLineNumber, 0]).top; // Manually calculate the scroll location, instead of using
  // `textEditor.scrollToBufferPosition([lineNumber, 0], {center: true})`
  // because that API to wouldn't center the line if it was in the visible screen range.

  const scrollTop = pixelPositionTop + textEditor.getLineHeightInPixels() / 2 - textEditorElement.clientHeight / 2;
  textEditorElement.setScrollTop(Math.max(scrollTop, 1));
  textEditorElement.focus();
  textEditor.setCursorBufferPosition([bufferLineNumber, 0], {
    autoscroll: false
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zLWF0b20vdGV4dC1lZGl0b3IuanMiXSwibmFtZXMiOlsiZXhpc3RpbmdFZGl0b3JGb3JVcmkiLCJwYXRoIiwiZWRpdG9yIiwiYXRvbSIsIndvcmtzcGFjZSIsImdldFRleHRFZGl0b3JzIiwiZ2V0UGF0aCIsImV4aXN0aW5nRWRpdG9yRm9yQnVmZmVyIiwiYnVmZmVyIiwiZ2V0QnVmZmVyIiwiZ2V0Vmlld09mRWRpdG9yIiwidmlld3MiLCJnZXRWaWV3IiwiZ2V0U2Nyb2xsVG9wIiwic2V0U2Nyb2xsVG9wIiwic2Nyb2xsVG9wIiwic2V0UG9zaXRpb25BbmRTY3JvbGwiLCJwb3NpdGlvbiIsInNldEN1cnNvckJ1ZmZlclBvc2l0aW9uIiwiYXV0b3Njcm9sbCIsImdldEN1cnNvclBvc2l0aW9ucyIsIk9ic2VydmFibGUiLCJkZWZlciIsImN1cnNvciIsImdldEN1cnNvcnMiLCJtZXJnZSIsIm9mIiwiZ2V0QnVmZmVyUG9zaXRpb24iLCJvbkRpZENoYW5nZVBvc2l0aW9uIiwiYmluZCIsIm1hcCIsImV2ZW50IiwibmV3QnVmZmVyUG9zaXRpb24iLCJvYnNlcnZlRWRpdG9yRGVzdHJveSIsIm9uRGlkRGVzdHJveSIsInRha2UiLCJlbmZvcmNlUmVhZE9ubHlFZGl0b3IiLCJ0ZXh0RWRpdG9yIiwicmVhZE9ubHlFeGNlcHRpb25zIiwiZ2V0RWxlbWVudCIsInNldEF0dHJpYnV0ZSIsImRpc3Bvc2UiLCJyZW1vdmVBdHRyaWJ1dGUiLCJlbmZvcmNlU29mdFdyYXAiLCJlbmZvcmNlZFNvZnRXcmFwIiwic2V0U29mdFdyYXBwZWQiLCJvbkRpZENoYW5nZVNvZnRXcmFwcGVkIiwic29mdFdyYXBwZWQiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJpc0Rlc3Ryb3llZCIsImlzVmFsaWRUZXh0RWRpdG9yIiwiaXRlbSIsIlRleHRFZGl0b3IiLCJjZW50ZXJTY3JvbGxUb0J1ZmZlckxpbmUiLCJ0ZXh0RWRpdG9yRWxlbWVudCIsImJ1ZmZlckxpbmVOdW1iZXIiLCJnZXRNb2RlbCIsInBpeGVsUG9zaXRpb25Ub3AiLCJwaXhlbFBvc2l0aW9uRm9yQnVmZmVyUG9zaXRpb24iLCJ0b3AiLCJnZXRMaW5lSGVpZ2h0SW5QaXhlbHMiLCJjbGllbnRIZWlnaHQiLCJNYXRoIiwibWF4IiwiZm9jdXMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWNBOztBQUNBOztBQUNBOztBQUVBOzs7O0FBbEJBOzs7Ozs7Ozs7Ozs7QUFvQkE7Ozs7QUFJTyxTQUFTQSxvQkFBVCxDQUE4QkMsSUFBOUIsRUFBa0U7QUFDdkU7QUFDQTtBQUNBLE9BQUssTUFBTUMsTUFBWCxJQUFxQkMsSUFBSSxDQUFDQyxTQUFMLENBQWVDLGNBQWYsRUFBckIsRUFBc0Q7QUFDcEQsUUFBSUgsTUFBTSxDQUFDSSxPQUFQLE9BQXFCTCxJQUF6QixFQUErQjtBQUM3QixhQUFPQyxNQUFQO0FBQ0Q7QUFDRjs7QUFFRCxTQUFPLElBQVA7QUFDRDtBQUVEOzs7Ozs7QUFJTyxTQUFTSyx1QkFBVCxDQUNMQyxNQURLLEVBRWE7QUFDbEI7QUFDQTtBQUNBLE9BQUssTUFBTU4sTUFBWCxJQUFxQkMsSUFBSSxDQUFDQyxTQUFMLENBQWVDLGNBQWYsRUFBckIsRUFBc0Q7QUFDcEQsUUFBSUgsTUFBTSxDQUFDTyxTQUFQLE9BQXVCRCxNQUEzQixFQUFtQztBQUNqQyxhQUFPTixNQUFQO0FBQ0Q7QUFDRjs7QUFFRCxTQUFPLElBQVA7QUFDRDs7QUFFTSxTQUFTUSxlQUFULENBQ0xSLE1BREssRUFFbUI7QUFDeEIsU0FBT0MsSUFBSSxDQUFDUSxLQUFMLENBQVdDLE9BQVgsQ0FBbUJWLE1BQW5CLENBQVA7QUFDRDs7QUFFTSxTQUFTVyxZQUFULENBQXNCWCxNQUF0QixFQUF1RDtBQUM1RCxTQUFPUSxlQUFlLENBQUNSLE1BQUQsQ0FBZixDQUF3QlcsWUFBeEIsRUFBUDtBQUNEOztBQUVNLFNBQVNDLFlBQVQsQ0FBc0JaLE1BQXRCLEVBQStDYSxTQUEvQyxFQUF3RTtBQUM3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QU4saUJBQWlCLENBQUNPLFlBQWxCLEdBQWlDLENBSG5DO0FBSUFQLEVBQUFBLGlCQUFpQixDQUFDekMsWUFBbEIsQ0FBK0JpRCxJQUFJLENBQUNDLEdBQUwsQ0FBU2pELFNBQVQsRUFBb0IsQ0FBcEIsQ0FBL0I7QUFFQXdDLEVBQUFBLGlCQUFpQixDQUFDVSxLQUFsQjtBQUVBNUIsRUFBQUEsVUFBVSxDQUFDbkIsdUJBQVgsQ0FBbUMsQ0FBQ3NDLGdCQUFELEVBQW1CLENBQW5CLENBQW5DLEVBQTBEO0FBQ3hEckMsSUFBQUEsVUFBVSxFQUFFO0FBRDRDLEdBQTFEO0FBR0QiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIEBmbG93XHJcbiAqIEBmb3JtYXRcclxuICovXHJcblxyXG5pbXBvcnQgdHlwZSB7TnVjbGlkZVVyaX0gZnJvbSAnQGF0b20taWRlLWNvbW11bml0eS9udWNsaWRlLWNvbW1vbnMvbnVjbGlkZVVyaSc7XHJcblxyXG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2Fzc2VydCc7XHJcbmltcG9ydCB7VGV4dEVkaXRvcn0gZnJvbSAnYXRvbSc7XHJcbmltcG9ydCB7T2JzZXJ2YWJsZX0gZnJvbSAncnhqcy1jb21wYXQvYnVuZGxlcy9yeGpzLWNvbXBhdC51bWQubWluLmpzJztcclxuXHJcbmltcG9ydCB7b2JzZXJ2YWJsZUZyb21TdWJzY3JpYmVGdW5jdGlvbn0gZnJvbSAnQGF0b20taWRlLWNvbW11bml0eS9udWNsaWRlLWNvbW1vbnMvZXZlbnQnO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSB0ZXh0IGVkaXRvciB0aGF0IGhhcyB0aGUgZ2l2ZW4gcGF0aCBvcGVuLCBvciBudWxsIGlmIG5vbmUgZXhpc3RzLiBJZiB0aGVyZSBhcmUgbXVsdGlwbGVcclxuICogdGV4dCBlZGl0b3JzIGZvciB0aGlzIHBhdGgsIG9uZSBpcyBjaG9zZW4gYXJiaXRyYXJpbHkuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZXhpc3RpbmdFZGl0b3JGb3JVcmkocGF0aDogTnVjbGlkZVVyaSk6ID9hdG9tJFRleHRFZGl0b3Ige1xyXG4gIC8vIFRoaXMgaXNuJ3QgaWRlYWwgYnV0IHJlYWxpc3RpY2FsbHkgaXRlcmF0aW5nIHRocm91Z2ggZXZlbiBhIGZldyBodW5kcmVkIGVkaXRvcnMgc2hvdWxkbid0IGJlIGFcclxuICAvLyByZWFsIHByb2JsZW0uIEFuZCBpZiB5b3UgaGF2ZSBtb3JlIHRoYW4gYSBmZXcgaHVuZHJlZCB5b3UgcHJvYmFibHkgaGF2ZSBiaWdnZXIgcHJvYmxlbXMuXHJcbiAgZm9yIChjb25zdCBlZGl0b3Igb2YgYXRvbS53b3Jrc3BhY2UuZ2V0VGV4dEVkaXRvcnMoKSkge1xyXG4gICAgaWYgKGVkaXRvci5nZXRQYXRoKCkgPT09IHBhdGgpIHtcclxuICAgICAgcmV0dXJuIGVkaXRvcjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBudWxsO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIHRleHQgZWRpdG9yIHRoYXQgaGFzIHRoZSBnaXZlbiBidWZmZXIgb3Blbiwgb3IgbnVsbCBpZiBub25lIGV4aXN0cy4gSWYgdGhlcmUgYXJlXHJcbiAqIG11bHRpcGxlIHRleHQgZWRpdG9ycyBmb3IgdGhpcyBidWZmZXIsIG9uZSBpcyBjaG9zZW4gYXJiaXRyYXJpbHkuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZXhpc3RpbmdFZGl0b3JGb3JCdWZmZXIoXHJcbiAgYnVmZmVyOiBhdG9tJFRleHRCdWZmZXIsXHJcbik6ID9hdG9tJFRleHRFZGl0b3Ige1xyXG4gIC8vIFRoaXMgaXNuJ3QgaWRlYWwgYnV0IHJlYWxpc3RpY2FsbHkgaXRlcmF0aW5nIHRocm91Z2ggZXZlbiBhIGZldyBodW5kcmVkIGVkaXRvcnMgc2hvdWxkbid0IGJlIGFcclxuICAvLyByZWFsIHByb2JsZW0uIEFuZCBpZiB5b3UgaGF2ZSBtb3JlIHRoYW4gYSBmZXcgaHVuZHJlZCB5b3UgcHJvYmFibHkgaGF2ZSBiaWdnZXIgcHJvYmxlbXMuXHJcbiAgZm9yIChjb25zdCBlZGl0b3Igb2YgYXRvbS53b3Jrc3BhY2UuZ2V0VGV4dEVkaXRvcnMoKSkge1xyXG4gICAgaWYgKGVkaXRvci5nZXRCdWZmZXIoKSA9PT0gYnVmZmVyKSB7XHJcbiAgICAgIHJldHVybiBlZGl0b3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFZpZXdPZkVkaXRvcihcclxuICBlZGl0b3I6IGF0b20kVGV4dEVkaXRvcixcclxuKTogYXRvbSRUZXh0RWRpdG9yRWxlbWVudCB7XHJcbiAgcmV0dXJuIGF0b20udmlld3MuZ2V0VmlldyhlZGl0b3IpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2Nyb2xsVG9wKGVkaXRvcjogYXRvbSRUZXh0RWRpdG9yKTogbnVtYmVyIHtcclxuICByZXR1cm4gZ2V0Vmlld09mRWRpdG9yKGVkaXRvcikuZ2V0U2Nyb2xsVG9wKCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRTY3JvbGxUb3AoZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IsIHNjcm9sbFRvcDogbnVtYmVyKTogdm9pZCB7XHJcbiAgZ2V0Vmlld09mRWRpdG9yKGVkaXRvcikuc2V0U2Nyb2xsVG9wKHNjcm9sbFRvcCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEb2VzIGEgYmVzdCBlZmZvcnQgdG8gc2V0IGFuIGVkaXRvciBwYW5lIHRvIGEgZ2l2ZW4gY3Vyc29yIHBvc2l0aW9uICYgc2Nyb2xsLlxyXG4gKiBEb2VzIG5vdCBlbnN1cmUgdGhhdCB0aGUgY3VycmVudCBjdXJzb3IgcG9zaXRpb24gaXMgdmlzaWJsZS5cclxuICpcclxuICogQ2FuIGJlIHVzZWQgd2l0aCBlZGl0b3IuZ2V0Q3Vyc29yQnVmZmVyUG9zaXRpb24oKSAmIGdldFNjcm9sbFRvcCgpIHRvIHJlc3RvcmVcclxuICogYW4gZWRpdG9ycyBjdXJzb3IgYW5kIHNjcm9sbC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRQb3NpdGlvbkFuZFNjcm9sbChcclxuICBlZGl0b3I6IGF0b20kVGV4dEVkaXRvcixcclxuICBwb3NpdGlvbjogYXRvbSRQb2ludCxcclxuICBzY3JvbGxUb3A6IG51bWJlcixcclxuKTogdm9pZCB7XHJcbiAgZWRpdG9yLnNldEN1cnNvckJ1ZmZlclBvc2l0aW9uKHBvc2l0aW9uLCB7YXV0b3Njcm9sbDogZmFsc2V9KTtcclxuICBzZXRTY3JvbGxUb3AoZWRpdG9yLCBzY3JvbGxUb3ApO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3Vyc29yUG9zaXRpb25zKFxyXG4gIGVkaXRvcjogYXRvbSRUZXh0RWRpdG9yLFxyXG4pOiBPYnNlcnZhYmxlPGF0b20kUG9pbnQ+IHtcclxuICByZXR1cm4gT2JzZXJ2YWJsZS5kZWZlcigoKSA9PiB7XHJcbiAgICAvLyBUaGlzIHdpbGwgYmVoYXZlIHN0cmFuZ2VseSBpbiB0aGUgZmFjZSBvZiBtdWx0aXBsZSBjdXJzb3JzLiBDb25zaWRlciBzdXBwb3J0aW5nIG11bHRpcGxlXHJcbiAgICAvLyBjdXJzb3JzIGluIHRoZSBmdXR1cmUuXHJcbiAgICBjb25zdCBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29ycygpWzBdO1xyXG4gICAgaW52YXJpYW50KGN1cnNvciAhPSBudWxsKTtcclxuICAgIHJldHVybiBPYnNlcnZhYmxlLm1lcmdlKFxyXG4gICAgICBPYnNlcnZhYmxlLm9mKGN1cnNvci5nZXRCdWZmZXJQb3NpdGlvbigpKSxcclxuICAgICAgb2JzZXJ2YWJsZUZyb21TdWJzY3JpYmVGdW5jdGlvbihcclxuICAgICAgICBjdXJzb3Iub25EaWRDaGFuZ2VQb3NpdGlvbi5iaW5kKGN1cnNvciksXHJcbiAgICAgICkubWFwKGV2ZW50ID0+IGV2ZW50Lm5ld0J1ZmZlclBvc2l0aW9uKSxcclxuICAgICk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBvYnNlcnZlRWRpdG9yRGVzdHJveShcclxuICBlZGl0b3I6IGF0b20kVGV4dEVkaXRvcixcclxuKTogT2JzZXJ2YWJsZTxhdG9tJFRleHRFZGl0b3I+IHtcclxuICByZXR1cm4gb2JzZXJ2YWJsZUZyb21TdWJzY3JpYmVGdW5jdGlvbihlZGl0b3Iub25EaWREZXN0cm95LmJpbmQoZWRpdG9yKSlcclxuICAgIC5tYXAoZXZlbnQgPT4gZWRpdG9yKVxyXG4gICAgLnRha2UoMSk7XHJcbn1cclxuXHJcbi8vIFVzZSBhdG9tIHJlYWRPbmx5IGF0dHJpYnV0ZSB0byBzZXQgcmVhZC1vbmx5IHN0YXRlLlxyXG5leHBvcnQgZnVuY3Rpb24gZW5mb3JjZVJlYWRPbmx5RWRpdG9yKFxyXG4gIHRleHRFZGl0b3I6IGF0b20kVGV4dEVkaXRvcixcclxuICByZWFkT25seUV4Y2VwdGlvbnM/OiBBcnJheTxzdHJpbmc+ID0gWydhcHBlbmQnLCAnc2V0VGV4dCddLFxyXG4pOiBJRGlzcG9zYWJsZSB7XHJcbiAgdGV4dEVkaXRvci5nZXRFbGVtZW50KCkuc2V0QXR0cmlidXRlKCdyZWFkb25seScsICcnKTtcclxuICByZXR1cm4ge1xyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgdGV4dEVkaXRvci5nZXRFbGVtZW50KCkucmVtb3ZlQXR0cmlidXRlKCdyZWFkb25seScpO1xyXG4gICAgfSxcclxuICB9O1xyXG59XHJcblxyXG4vLyBUdXJuIG9mZiBzb2Z0IHdyYXAgc2V0dGluZyBmb3IgdGhlc2UgZWRpdG9ycyBzbyBkaWZmcyBwcm9wZXJseSBhbGlnbi5cclxuLy8gU29tZSB0ZXh0IGVkaXRvciByZWdpc3RlciBzb21ldGltZXMgb3ZlcnJpZGUgdGhlIHNldCBzb2Z0IHdyYXBwaW5nXHJcbi8vIGFmdGVyIG1vdW50aW5nIGFuIGVkaXRvciB0byB0aGUgd29ya3NwYWNlIC0gaGVyZSwgdGhhdCdzIHdhdGNoZWQgYW5kIHJlc2V0IHRvIGBmYWxzZWAuXHJcbmV4cG9ydCBmdW5jdGlvbiBlbmZvcmNlU29mdFdyYXAoXHJcbiAgZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IsXHJcbiAgZW5mb3JjZWRTb2Z0V3JhcDogYm9vbGVhbixcclxuKTogSURpc3Bvc2FibGUge1xyXG4gIGVkaXRvci5zZXRTb2Z0V3JhcHBlZChlbmZvcmNlZFNvZnRXcmFwKTtcclxuICByZXR1cm4gZWRpdG9yLm9uRGlkQ2hhbmdlU29mdFdyYXBwZWQoc29mdFdyYXBwZWQgPT4ge1xyXG4gICAgaWYgKHNvZnRXcmFwcGVkICE9PSBlbmZvcmNlZFNvZnRXcmFwKSB7XHJcbiAgICAgIC8vIFJlc2V0IHRoZSBvdmVycmlkZGVuIHNvZnRXcmFwIHRvIGBmYWxzZWAgb25jZSB0aGUgb3BlcmF0aW9uIGNvbXBsZXRlcy5cclxuICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFlZGl0b3IuaXNEZXN0cm95ZWQoKSkge1xyXG4gICAgICAgICAgZWRpdG9yLnNldFNvZnRXcmFwcGVkKGVuZm9yY2VkU29mdFdyYXApO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYW4gb2JqZWN0ICh0eXBpY2FsbHkgYW4gQXRvbSBwYW5lKSBpcyBhIFRleHRFZGl0b3IuXHJcbiAqIENvdWxkIGJlIHJlcGxhY2VkIHdpdGggYXRvbS53b3Jrc3BhY2UuaXNWYWxpZFRleHRFZGl0b3IsXHJcbiAqIGJ1dCBGbG93IGRvZXNuJ3Qgc3VwcG9ydCAlY2hlY2tzIGluIG1ldGhvZHMgeWV0LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRUZXh0RWRpdG9yKGl0ZW06IG1peGVkKTogYm9vbGVhbiAlY2hlY2tzIHtcclxuICByZXR1cm4gaXRlbSBpbnN0YW5jZW9mIFRleHRFZGl0b3I7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjZW50ZXJTY3JvbGxUb0J1ZmZlckxpbmUoXHJcbiAgdGV4dEVkaXRvckVsZW1lbnQ6IGF0b20kVGV4dEVkaXRvckVsZW1lbnQsXHJcbiAgYnVmZmVyTGluZU51bWJlcjogbnVtYmVyLFxyXG4pOiB2b2lkIHtcclxuICBjb25zdCB0ZXh0RWRpdG9yID0gdGV4dEVkaXRvckVsZW1lbnQuZ2V0TW9kZWwoKTtcclxuICBjb25zdCBwaXhlbFBvc2l0aW9uVG9wID0gdGV4dEVkaXRvckVsZW1lbnQucGl4ZWxQb3NpdGlvbkZvckJ1ZmZlclBvc2l0aW9uKFtcclxuICAgIGJ1ZmZlckxpbmVOdW1iZXIsXHJcbiAgICAwLFxyXG4gIF0pLnRvcDtcclxuICAvLyBNYW51YWxseSBjYWxjdWxhdGUgdGhlIHNjcm9sbCBsb2NhdGlvbiwgaW5zdGVhZCBvZiB1c2luZ1xyXG4gIC8vIGB0ZXh0RWRpdG9yLnNjcm9sbFRvQnVmZmVyUG9zaXRpb24oW2xpbmVOdW1iZXIsIDBdLCB7Y2VudGVyOiB0cnVlfSlgXHJcbiAgLy8gYmVjYXVzZSB0aGF0IEFQSSB0byB3b3VsZG4ndCBjZW50ZXIgdGhlIGxpbmUgaWYgaXQgd2FzIGluIHRoZSB2aXNpYmxlIHNjcmVlbiByYW5nZS5cclxuICBjb25zdCBzY3JvbGxUb3AgPVxyXG4gICAgcGl4ZWxQb3NpdGlvblRvcCArXHJcbiAgICB0ZXh0RWRpdG9yLmdldExpbmVIZWlnaHRJblBpeGVscygpIC8gMiAtXHJcbiAgICB0ZXh0RWRpdG9yRWxlbWVudC5jbGllbnRIZWlnaHQgLyAyO1xyXG4gIHRleHRFZGl0b3JFbGVtZW50LnNldFNjcm9sbFRvcChNYXRoLm1heChzY3JvbGxUb3AsIDEpKTtcclxuXHJcbiAgdGV4dEVkaXRvckVsZW1lbnQuZm9jdXMoKTtcclxuXHJcbiAgdGV4dEVkaXRvci5zZXRDdXJzb3JCdWZmZXJQb3NpdGlvbihbYnVmZmVyTGluZU51bWJlciwgMF0sIHtcclxuICAgIGF1dG9zY3JvbGw6IGZhbHNlLFxyXG4gIH0pO1xyXG59XHJcbiJdfQ==