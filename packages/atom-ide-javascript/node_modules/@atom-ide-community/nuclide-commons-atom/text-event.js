"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.observeTextEditorEvents = observeTextEditorEvents;
exports.__TEST__ = exports.TextEventDispatcher = void 0;

var _assert = _interopRequireDefault(require("assert"));

var _rxjsCompatUmdMin = require("rxjs-compat/bundles/rxjs-compat.umd.min.js");

var _debounce = _interopRequireDefault(require("@atom-ide-community/nuclide-commons/debounce"));

var _event = require("@atom-ide-community/nuclide-commons/event");

var _UniversalDisposable = _interopRequireDefault(require("@atom-ide-community/nuclide-commons/UniversalDisposable"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */
// A reload changes the text in the buffer, so it should trigger a refresh.
const FILE_CHANGE_EVENTS = ['did-change', 'did-reload', 'did-open']; // A reload basically indicates that an external program saved the file, so
// it should trigger a refresh.

const FILE_SAVE_EVENTS = ['did-save', 'did-reload', 'did-open'];
/**
 * Stores callbacks keyed on grammar and event, to allow for easy retrieval when
 * we need to dispatch to all callbacks registered for a given (grammar, event)
 * pair.
 */

class TextCallbackContainer {
  // grammar -> event -> callback
  // invariant: no empty maps or sets (they should be removed instead)
  // event -> callback
  // invariant: no keys mapping to empty sets (they should be removed instead)
  constructor() {
    this._callbacks = void 0;
    this._allGrammarCallbacks = void 0;
    this._callbacks = new Map();
    this._allGrammarCallbacks = new Map();
  }

  getCallbacks(grammar, event) {
    const eventMap = this._callbacks.get(grammar);

    const callbacksForGrammar = this._getCallbacksFromEventMap(eventMap, event);

    const callbacksForAll = this._getCallbacksFromEventMap(this._allGrammarCallbacks, event);

    const resultSet = new Set();

    const add = callback => {
      resultSet.add(callback);
    };

    callbacksForGrammar.forEach(add);
    callbacksForAll.forEach(add);
    return resultSet;
  }

  isEmpty() {
    return this._callbacks.size === 0 && this._allGrammarCallbacks.size === 0;
  }

  _getCallbacksFromEventMap(eventMap, event) {
    if (!eventMap) {
      return new Set();
    }

    const callbackSet = eventMap.get(event);

    if (!callbackSet) {
      return new Set();
    }

    return callbackSet;
  }

  addCallback(grammarScopes, events, callback) {
    if (grammarScopes === 'all') {
      this._addToEventMap(this._allGrammarCallbacks, events, callback);
    } else {
      for (const grammarScope of grammarScopes) {
        let eventMap = this._callbacks.get(grammarScope);

        if (!eventMap) {
          eventMap = new Map();

          this._callbacks.set(grammarScope, eventMap);
        }

        this._addToEventMap(eventMap, events, callback);
      }
    }
  } // remove the callbacks, maintaining the invariant that there should be no
  // empty maps or sets in this._callbacks


  removeCallback(grammarScopes, events, callback) {
    if (grammarScopes === 'all') {
      this._removeFromEventMap(this._allGrammarCallbacks, events, callback);
    } else {
      for (const grammarScope of grammarScopes) {
        const eventMap = this._callbacks.get(grammarScope);

        (0, _assert.default)(eventMap);

        this._removeFromEventMap(eventMap, events, callback);

        if (eventMap.size === 0) {
          this._callbacks.delete(grammarScope);
        }
      }
    }
  }

  _addToEventMap(eventMap, events, callback) {
    for (const event of events) {
      let callbackSet = eventMap.get(event);

      if (!callbackSet) {
        callbackSet = new Set();
        eventMap.set(event, callbackSet);
      }

      callbackSet.add(callback);
    }
  }

  _removeFromEventMap(eventMap, events, callback) {
    for (const event of events) {
      const callbackSet = eventMap.get(event);
      (0, _assert.default)(callbackSet);
      callbackSet.delete(callback);

      if (callbackSet.size === 0) {
        eventMap.delete(event);
      }
    }
  }

}
/**
 * Meant to make it simple and easy for a DiagnosticProvider to subscribe to
 * relevant events. Currently provides two methods, onFileChange and onFileSave.
 * A DiagnosticProvider will typically subscribe to only one, depending on
 * whether it wants to be notified whenever a file changes or only when it is
 * saved.
 *
 * Both methods take two arguments:
 * - An Iterable of grammars for which the DiagnosticProvider can provide
 * diagnostics.
 * - The callback to be called on a text event.
 *
 * A TextEventDispatcher will be subscribed to text events if and only if it has
 * subscribers of its own. If all subscribers unsubscribe, it will unsubscribe
 * from Atom's text events.
 *
 */


class TextEventDispatcher {
  constructor() {
    this._callbackContainer = void 0;
    this._editorListenerDisposable = void 0;
    this._pendingEvents = void 0;
    this._callbackContainer = new TextCallbackContainer();
    this._editorListenerDisposable = null;
    this._pendingEvents = new WeakMap();
  }

  _onEvents(grammarScopes, events, callback) {
    if (this._callbackContainer.isEmpty()) {
      this._registerEditorListeners();
    } // Sometimes these events get triggered several times in succession
    // (particularly on startup).


    const debouncedCallback = (0, _debounce.default)(callback, 50, true);

    this._callbackContainer.addCallback(grammarScopes, events, debouncedCallback);

    const disposables = new _UniversalDisposable.default(() => {
      this._callbackContainer.removeCallback(grammarScopes, events, debouncedCallback);

      if (this._callbackContainer.isEmpty()) {
        this._deregisterEditorListeners();
      }
    });
    return disposables;
  }

  onFileChange(grammarScopes, callback) {
    return this._onEvents(grammarScopes, FILE_CHANGE_EVENTS, callback);
  }

  onAnyFileChange(callback) {
    return this._onEvents('all', FILE_CHANGE_EVENTS, callback);
  }

  onFileSave(grammarScopes, callback) {
    return this._onEvents(grammarScopes, FILE_SAVE_EVENTS, callback);
  }

  onAnyFileSave(callback) {
    return this._onEvents('all', FILE_SAVE_EVENTS, callback);
  }

  _registerEditorListeners() {
    if (!this._editorListenerDisposable) {
      this._editorListenerDisposable = new _UniversalDisposable.default();
    } // Whenever the active pane item changes, we check to see if there are any
    // pending events for the newly-focused TextEditor.


    this._getEditorListenerDisposable().add(atom.workspace.onDidChangeActivePaneItem(() => {
      const currentEditor = atom.workspace.getActiveTextEditor();

      if (currentEditor) {
        const pendingEvents = this._pendingEvents.get(currentEditor.getBuffer());

        if (pendingEvents) {
          for (const event of pendingEvents) {
            this._dispatchEvents(currentEditor, event);
          }

          this._pendingEvents.delete(currentEditor.getBuffer());
        }
      }
    }));

    this._getEditorListenerDisposable().add(atom.workspace.observeTextEditors(editor => {
      const buffer = editor.getBuffer();

      const makeDispatch = event => {
        return () => {
          this._dispatchEvents(editor, event);
        };
      };

      this._getEditorListenerDisposable().addUntilDestroyed(editor, buffer.onDidStopChanging(makeDispatch('did-change')), buffer.onDidSave(makeDispatch('did-save')), buffer.onDidReload(makeDispatch('did-reload'))); // During reload, many text editors are opened simultaneously.
      // Due to the debounce on the event callback, this means that many editors never receive
      // a 'did-open' event. To work around this, defer editor open events so that simultaneous
      // open events are properly registered as pending.


      setImmediate(() => this._dispatchEvents(editor, 'did-open'));
    }));
  }

  _deregisterEditorListeners() {
    if (this._editorListenerDisposable) {
      this._getEditorListenerDisposable().dispose();

      this._editorListenerDisposable = null;
    }
  }

  _dispatchEvents(editor, event) {
    const currentEditor = atom.workspace.getActiveTextEditor();

    if (currentEditor && editor === currentEditor) {
      const callbacks = this._callbackContainer.getCallbacks(editor.getGrammar().scopeName, event);

      for (const callback of callbacks) {
        callback(editor);
      } // We want to avoid storing pending events if this event was generated by
      // the same buffer as the current editor, to avoid duplicating events when
      // multiple panes have the same file open.

    } else if (!currentEditor || editor.getBuffer() !== currentEditor.getBuffer()) {
      // Trigger this event next time we switch to an editor with this buffer.
      const buffer = editor.getBuffer();

      let events = this._pendingEvents.get(buffer);

      if (!events) {
        events = new Set();

        this._pendingEvents.set(buffer, events);
      }

      events.add(event);
    }
  }

  _getEditorListenerDisposable() {
    const disposable = this._editorListenerDisposable;
    (0, _assert.default)(disposable, 'TextEventDispatcher disposable is not initialized');
    return disposable;
  }

}

exports.TextEventDispatcher = TextEventDispatcher;

function observeTextEditorEvents(grammarScopes, events) {
  return _rxjsCompatUmdMin.Observable.defer(() => {
    const dispatcher = new TextEventDispatcher();

    if (events === 'changes') {
      if (grammarScopes === 'all') {
        return (0, _event.observableFromSubscribeFunction)(cb => dispatcher.onAnyFileChange(cb));
      } else {
        return (0, _event.observableFromSubscribeFunction)(cb => dispatcher.onFileChange(grammarScopes, cb));
      }
    } else {
      if (grammarScopes === 'all') {
        return (0, _event.observableFromSubscribeFunction)(cb => dispatcher.onAnyFileSave(cb));
      } else {
        return (0, _event.observableFromSubscribeFunction)(cb => dispatcher.onFileSave(grammarScopes, cb));
      }
    }
  });
}

const __TEST__ = {
  TextCallbackContainer
};
exports.__TEST__ = __TEST__;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zLWF0b20vdGV4dC1ldmVudC5qcyJdLCJuYW1lcyI6WyJGSUxFX0NIQU5HRV9FVkVOVFMiLCJGSUxFX1NBVkVfRVZFTlRTIiwiVGV4dENhbGxiYWNrQ29udGFpbmVyIiwiY29uc3RydWN0b3IiLCJfY2FsbGJhY2tzIiwiX2FsbEdyYW1tYXJDYWxsYmFja3MiLCJNYXAiLCJnZXRDYWxsYmFja3MiLCJncmFtbWFyIiwiZXZlbnQiLCJldmVudE1hcCIsImdldCIsImNhbGxiYWNrc0ZvckdyYW1tYXIiLCJfZ2V0Q2FsbGJhY2tzRnJvbUV2ZW50TWFwIiwiY2FsbGJhY2tzRm9yQWxsIiwicmVzdWx0U2V0IiwiU2V0IiwiYWRkIiwiY2FsbGJhY2siLCJmb3JFYWNoIiwiaXNFbXB0eSIsInNpemUiLCJjYWxsYmFja1NldCIsImFkZENhbGxiYWNrIiwiZ3JhbW1hclNjb3BlcyIsImV2ZW50cyIsIl9hZGRUb0V2ZW50TWFwIiwiZ3JhbW1hclNjb3BlIiwic2V0IiwicmVtb3ZlQ2FsbGJhY2siLCJfcmVtb3ZlRnJvbUV2ZW50TWFwIiwiZGVsZXRlIiwiVGV4dEV2ZW50RGlzcGF0Y2hlciIsIl9jYWxsYmFja0NvbnRhaW5lciIsIl9lZGl0b3JMaXN0ZW5lckRpc3Bvc2FibGUiLCJfcGVuZGluZ0V2ZW50cyIsIldlYWtNYXAiLCJfb25FdmVudHMiLCJfcmVnaXN0ZXJFZGl0b3JMaXN0ZW5lcnMiLCJkZWJvdW5jZWRDYWxsYmFjayIsImRpc3Bvc2FibGVzIiwiVW5pdmVyc2FsRGlzcG9zYWJsZSIsIl9kZXJlZ2lzdGVyRWRpdG9yTGlzdGVuZXJzIiwib25GaWxlQ2hhbmdlIiwib25BbnlGaWxlQ2hhbmdlIiwib25GaWxlU2F2ZSIsIm9uQW55RmlsZVNhdmUiLCJfZ2V0RWRpdG9yTGlzdGVuZXJEaXNwb3NhYmxlIiwiYXRvbSIsIndvcmtzcGFjZSIsIm9uRGlkQ2hhbmdlQWN0aXZlUGFuZUl0ZW0iLCJjdXJyZW50RWRpdG9yIiwiZ2V0QWN0aXZlVGV4dEVkaXRvciIsInBlbmRpbmdFdmVudHMiLCJnZXRCdWZmZXIiLCJfZGlzcGF0Y2hFdmVudHMiLCJvYnNlcnZlVGV4dEVkaXRvcnMiLCJlZGl0b3IiLCJidWZmZXIiLCJtYWtlRGlzcGF0Y2giLCJhZGRVbnRpbERlc3Ryb3llZCIsIm9uRGlkU3RvcENoYW5naW5nIiwib25EaWRTYXZlIiwib25EaWRSZWxvYWQiLCJzZXRJbW1lZGlhdGUiLCJkaXNwb3NlIiwiY2FsbGJhY2tzIiwiZ2V0R3JhbW1hciIsInNjb3BlTmFtZSIsImRpc3Bvc2FibGUiLCJvYnNlcnZlVGV4dEVkaXRvckV2ZW50cyIsIk9ic2VydmFibGUiLCJkZWZlciIsImRpc3BhdGNoZXIiLCJjYiIsIl9fVEVTVF9fIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQVlBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7O0FBaEJBOzs7Ozs7Ozs7OztBQXNCQTtBQUNBLE1BQU1BLGtCQUFrQixHQUFHLENBQUMsWUFBRCxFQUFlLFlBQWYsRUFBNkIsVUFBN0IsQ0FBM0IsQyxDQUVBO0FBQ0E7O0FBQ0EsTUFBTUMsZ0JBQWdCLEdBQUcsQ0FBQyxVQUFELEVBQWEsWUFBYixFQUEyQixVQUEzQixDQUF6QjtBQUVBOzs7Ozs7QUFLQSxNQUFNQyxxQkFBTixDQUF5QztBQUN2QztBQUNBO0FBR0E7QUFDQTtBQUdBQyxFQUFBQSxXQUFXLEdBQUc7QUFBQSxTQU5kQyxVQU1jO0FBQUEsU0FGZEMsb0JBRWM7QUFDWixTQUFLRCxVQUFMLEdBQWtCLElBQUlFLEdBQUosRUFBbEI7QUFDQSxTQUFLRCxvQkFBTCxHQUE0QixJQUFJQyxHQUFKLEVBQTVCO0FBQ0Q7O0FBRURDLEVBQUFBLFlBQVksQ0FDVkMsT0FEVSxFQUVWQyxLQUZVLEVBR3dCO0FBQ2xDLFVBQU1DLFFBQVEsR0FBRyxLQUFLTixVQUFMLENBQWdCTyxHQUFoQixDQUFvQkgsT0FBcEIsQ0FBakI7O0FBQ0EsVUFBTUksbUJBQW1CLEdBQUcsS0FBS0MseUJBQUwsQ0FBK0JILFFB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O0FBQ3RCekUsRUFBQUE7QUFEc0IsQ0FBakIiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIEBmbG93IHN0cmljdC1sb2NhbFxyXG4gKiBAZm9ybWF0XHJcbiAqL1xyXG5cclxuaW1wb3J0IGludmFyaWFudCBmcm9tICdhc3NlcnQnO1xyXG5pbXBvcnQge09ic2VydmFibGV9IGZyb20gJ3J4anMtY29tcGF0L2J1bmRsZXMvcnhqcy1jb21wYXQudW1kLm1pbi5qcyc7XHJcbmltcG9ydCBkZWJvdW5jZSBmcm9tICdAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtY29tbW9ucy9kZWJvdW5jZSc7XHJcbmltcG9ydCB7b2JzZXJ2YWJsZUZyb21TdWJzY3JpYmVGdW5jdGlvbn0gZnJvbSAnQGF0b20taWRlLWNvbW11bml0eS9udWNsaWRlLWNvbW1vbnMvZXZlbnQnO1xyXG5pbXBvcnQgVW5pdmVyc2FsRGlzcG9zYWJsZSBmcm9tICdAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtY29tbW9ucy9Vbml2ZXJzYWxEaXNwb3NhYmxlJztcclxuXHJcbnR5cGUgRXZlbnRDYWxsYmFjayA9IChlZGl0b3I6IFRleHRFZGl0b3IpID0+IG1peGVkO1xyXG5cclxudHlwZSBFdmVudCA9ICdkaWQtcmVsb2FkJyB8ICdkaWQtY2hhbmdlJyB8ICdkaWQtc2F2ZScgfCAnZGlkLW9wZW4nO1xyXG5cclxuLy8gQSByZWxvYWQgY2hhbmdlcyB0aGUgdGV4dCBpbiB0aGUgYnVmZmVyLCBzbyBpdCBzaG91bGQgdHJpZ2dlciBhIHJlZnJlc2guXHJcbmNvbnN0IEZJTEVfQ0hBTkdFX0VWRU5UUyA9IFsnZGlkLWNoYW5nZScsICdkaWQtcmVsb2FkJywgJ2RpZC1vcGVuJ107XHJcblxyXG4vLyBBIHJlbG9hZCBiYXNpY2FsbHkgaW5kaWNhdGVzIHRoYXQgYW4gZXh0ZXJuYWwgcHJvZ3JhbSBzYXZlZCB0aGUgZmlsZSwgc29cclxuLy8gaXQgc2hvdWxkIHRyaWdnZXIgYSByZWZyZXNoLlxyXG5jb25zdCBGSUxFX1NBVkVfRVZFTlRTID0gWydkaWQtc2F2ZScsICdkaWQtcmVsb2FkJywgJ2RpZC1vcGVuJ107XHJcblxyXG4vKipcclxuICogU3RvcmVzIGNhbGxiYWNrcyBrZXllZCBvbiBncmFtbWFyIGFuZCBldmVudCwgdG8gYWxsb3cgZm9yIGVhc3kgcmV0cmlldmFsIHdoZW5cclxuICogd2UgbmVlZCB0byBkaXNwYXRjaCB0byBhbGwgY2FsbGJhY2tzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gKGdyYW1tYXIsIGV2ZW50KVxyXG4gKiBwYWlyLlxyXG4gKi9cclxuY2xhc3MgVGV4dENhbGxiYWNrQ29udGFpbmVyPENhbGxiYWNrQXJnPiB7XHJcbiAgLy8gZ3JhbW1hciAtPiBldmVudCAtPiBjYWxsYmFja1xyXG4gIC8vIGludmFyaWFudDogbm8gZW1wdHkgbWFwcyBvciBzZXRzICh0aGV5IHNob3VsZCBiZSByZW1vdmVkIGluc3RlYWQpXHJcbiAgX2NhbGxiYWNrczogTWFwPHN0cmluZywgTWFwPEV2ZW50LCBTZXQ8KGFyZzogQ2FsbGJhY2tBcmcpID0+IG1peGVkPj4+O1xyXG5cclxuICAvLyBldmVudCAtPiBjYWxsYmFja1xyXG4gIC8vIGludmFyaWFudDogbm8ga2V5cyBtYXBwaW5nIHRvIGVtcHR5IHNldHMgKHRoZXkgc2hvdWxkIGJlIHJlbW92ZWQgaW5zdGVhZClcclxuICBfYWxsR3JhbW1hckNhbGxiYWNrczogTWFwPEV2ZW50LCBTZXQ8KGFyZzogQ2FsbGJhY2tBcmcpID0+IG1peGVkPj47XHJcblxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy5fY2FsbGJhY2tzID0gbmV3IE1hcCgpO1xyXG4gICAgdGhpcy5fYWxsR3JhbW1hckNhbGxiYWNrcyA9IG5ldyBNYXAoKTtcclxuICB9XHJcblxyXG4gIGdldENhbGxiYWNrcyhcclxuICAgIGdyYW1tYXI6IHN0cmluZyxcclxuICAgIGV2ZW50OiBFdmVudCxcclxuICApOiBTZXQ8KGFyZzogQ2FsbGJhY2tBcmcpID0+IG1peGVkPiB7XHJcbiAgICBjb25zdCBldmVudE1hcCA9IHRoaXMuX2NhbGxiYWNrcy5nZXQoZ3JhbW1hcik7XHJcbiAgICBjb25zdCBjYWxsYmFja3NGb3JHcmFtbWFyID0gdGhpcy5fZ2V0Q2FsbGJhY2tzRnJvbUV2ZW50TWFwKGV2ZW50TWFwLCBldmVudCk7XHJcbiAgICBjb25zdCBjYWxsYmFja3NGb3JBbGwgPSB0aGlzLl9nZXRDYWxsYmFja3NGcm9tRXZlbnRNYXAoXHJcbiAgICAgIHRoaXMuX2FsbEdyYW1tYXJDYWxsYmFja3MsXHJcbiAgICAgIGV2ZW50LFxyXG4gICAgKTtcclxuICAgIGNvbnN0IHJlc3VsdFNldCA9IG5ldyBTZXQoKTtcclxuICAgIGNvbnN0IGFkZCA9IGNhbGxiYWNrID0+IHtcclxuICAgICAgcmVzdWx0U2V0LmFkZChjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgY2FsbGJhY2tzRm9yR3JhbW1hci5mb3JFYWNoKGFkZCk7XHJcbiAgICBjYWxsYmFja3NGb3JBbGwuZm9yRWFjaChhZGQpO1xyXG4gICAgcmV0dXJuIHJlc3VsdFNldDtcclxuICB9XHJcblxyXG4gIGlzRW1wdHkoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzLnNpemUgPT09IDAgJiYgdGhpcy5fYWxsR3JhbW1hckNhbGxiYWNrcy5zaXplID09PSAwO1xyXG4gIH1cclxuXHJcbiAgX2dldENhbGxiYWNrc0Zyb21FdmVudE1hcChcclxuICAgIGV2ZW50TWFwOiA/TWFwPEV2ZW50LCBTZXQ8KGFyZzogQ2FsbGJhY2tBcmcpID0+IG1peGVkPj4sXHJcbiAgICBldmVudDogRXZlbnQsXHJcbiAgKTogU2V0PChhcmc6IENhbGxiYWNrQXJnKSA9PiBtaXhlZD4ge1xyXG4gICAgaWYgKCFldmVudE1hcCkge1xyXG4gICAgICByZXR1cm4gbmV3IFNldCgpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgY2FsbGJhY2tTZXQgPSBldmVudE1hcC5nZXQoZXZlbnQpO1xyXG4gICAgaWYgKCFjYWxsYmFja1NldCkge1xyXG4gICAgICByZXR1cm4gbmV3IFNldCgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNhbGxiYWNrU2V0O1xyXG4gIH1cclxuXHJcbiAgYWRkQ2FsbGJhY2soXHJcbiAgICBncmFtbWFyU2NvcGVzOiBJdGVyYWJsZTxzdHJpbmc+IHwgJ2FsbCcsXHJcbiAgICBldmVudHM6IEl0ZXJhYmxlPEV2ZW50PixcclxuICAgIGNhbGxiYWNrOiAoYXJnOiBDYWxsYmFja0FyZykgPT4gbWl4ZWQsXHJcbiAgKTogdm9pZCB7XHJcbiAgICBpZiAoZ3JhbW1hclNjb3BlcyA9PT0gJ2FsbCcpIHtcclxuICAgICAgdGhpcy5fYWRkVG9FdmVudE1hcCh0aGlzLl9hbGxHcmFtbWFyQ2FsbGJhY2tzLCBldmVudHMsIGNhbGxiYWNrKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGZvciAoY29uc3QgZ3JhbW1hclNjb3BlIG9mIGdyYW1tYXJTY29wZXMpIHtcclxuICAgICAgICBsZXQgZXZlbnRNYXAgPSB0aGlzLl9jYWxsYmFja3MuZ2V0KGdyYW1tYXJTY29wZSk7XHJcbiAgICAgICAgaWYgKCFldmVudE1hcCkge1xyXG4gICAgICAgICAgZXZlbnRNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgICB0aGlzLl9jYWxsYmFja3Muc2V0KGdyYW1tYXJTY29wZSwgZXZlbnRNYXApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9hZGRUb0V2ZW50TWFwKGV2ZW50TWFwLCBldmVudHMsIGNhbGxiYWNrKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gcmVtb3ZlIHRoZSBjYWxsYmFja3MsIG1haW50YWluaW5nIHRoZSBpbnZhcmlhbnQgdGhhdCB0aGVyZSBzaG91bGQgYmUgbm9cclxuICAvLyBlbXB0eSBtYXBzIG9yIHNldHMgaW4gdGhpcy5fY2FsbGJhY2tzXHJcbiAgcmVtb3ZlQ2FsbGJhY2soXHJcbiAgICBncmFtbWFyU2NvcGVzOiBJdGVyYWJsZTxzdHJpbmc+IHwgJ2FsbCcsXHJcbiAgICBldmVudHM6IEl0ZXJhYmxlPEV2ZW50PixcclxuICAgIGNhbGxiYWNrOiAoYXJnOiBDYWxsYmFja0FyZykgPT4gbWl4ZWQsXHJcbiAgKTogdm9pZCB7XHJcbiAgICBpZiAoZ3JhbW1hclNjb3BlcyA9PT0gJ2FsbCcpIHtcclxuICAgICAgdGhpcy5fcmVtb3ZlRnJvbUV2ZW50TWFwKHRoaXMuX2FsbEdyYW1tYXJDYWxsYmFja3MsIGV2ZW50cywgY2FsbGJhY2spO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZm9yIChjb25zdCBncmFtbWFyU2NvcGUgb2YgZ3JhbW1hclNjb3Blcykge1xyXG4gICAgICAgIGNvbnN0IGV2ZW50TWFwID0gdGhpcy5fY2FsbGJhY2tzLmdldChncmFtbWFyU2NvcGUpO1xyXG4gICAgICAgIGludmFyaWFudChldmVudE1hcCk7XHJcbiAgICAgICAgdGhpcy5fcmVtb3ZlRnJvbUV2ZW50TWFwKGV2ZW50TWFwLCBldmVudHMsIGNhbGxiYWNrKTtcclxuICAgICAgICBpZiAoZXZlbnRNYXAuc2l6ZSA9PT0gMCkge1xyXG4gICAgICAgICAgdGhpcy5fY2FsbGJhY2tzLmRlbGV0ZShncmFtbWFyU2NvcGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX2FkZFRvRXZlbnRNYXAoXHJcbiAgICBldmVudE1hcDogTWFwPEV2ZW50LCBTZXQ8KGFyZzogQ2FsbGJhY2tBcmcpID0+IG1peGVkPj4sXHJcbiAgICBldmVudHM6IEl0ZXJhYmxlPEV2ZW50PixcclxuICAgIGNhbGxiYWNrOiAoYXJnOiBDYWxsYmFja0FyZykgPT4gbWl4ZWQsXHJcbiAgKTogdm9pZCB7XHJcbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cykge1xyXG4gICAgICBsZXQgY2FsbGJhY2tTZXQgPSBldmVudE1hcC5nZXQoZXZlbnQpO1xyXG4gICAgICBpZiAoIWNhbGxiYWNrU2V0KSB7XHJcbiAgICAgICAgY2FsbGJhY2tTZXQgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgZXZlbnRNYXAuc2V0KGV2ZW50LCBjYWxsYmFja1NldCk7XHJcbiAgICAgIH1cclxuICAgICAgY2FsbGJhY2tTZXQuYWRkKGNhbGxiYWNrKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9yZW1vdmVGcm9tRXZlbnRNYXAoXHJcbiAgICBldmVudE1hcDogTWFwPEV2ZW50LCBTZXQ8KGFyZzogQ2FsbGJhY2tBcmcpID0+IG1peGVkPj4sXHJcbiAgICBldmVudHM6IEl0ZXJhYmxlPEV2ZW50PixcclxuICAgIGNhbGxiYWNrOiAoYXJnOiBDYWxsYmFja0FyZykgPT4gbWl4ZWQsXHJcbiAgKTogdm9pZCB7XHJcbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cykge1xyXG4gICAgICBjb25zdCBjYWxsYmFja1NldCA9IGV2ZW50TWFwLmdldChldmVudCk7XHJcbiAgICAgIGludmFyaWFudChjYWxsYmFja1NldCk7XHJcbiAgICAgIGNhbGxiYWNrU2V0LmRlbGV0ZShjYWxsYmFjayk7XHJcbiAgICAgIGlmIChjYWxsYmFja1NldC5zaXplID09PSAwKSB7XHJcbiAgICAgICAgZXZlbnRNYXAuZGVsZXRlKGV2ZW50KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIE1lYW50IHRvIG1ha2UgaXQgc2ltcGxlIGFuZCBlYXN5IGZvciBhIERpYWdub3N0aWNQcm92aWRlciB0byBzdWJzY3JpYmUgdG9cclxuICogcmVsZXZhbnQgZXZlbnRzLiBDdXJyZW50bHkgcHJvdmlkZXMgdHdvIG1ldGhvZHMsIG9uRmlsZUNoYW5nZSBhbmQgb25GaWxlU2F2ZS5cclxuICogQSBEaWFnbm9zdGljUHJvdmlkZXIgd2lsbCB0eXBpY2FsbHkgc3Vic2NyaWJlIHRvIG9ubHkgb25lLCBkZXBlbmRpbmcgb25cclxuICogd2hldGhlciBpdCB3YW50cyB0byBiZSBub3RpZmllZCB3aGVuZXZlciBhIGZpbGUgY2hhbmdlcyBvciBvbmx5IHdoZW4gaXQgaXNcclxuICogc2F2ZWQuXHJcbiAqXHJcbiAqIEJvdGggbWV0aG9kcyB0YWtlIHR3byBhcmd1bWVudHM6XHJcbiAqIC0gQW4gSXRlcmFibGUgb2YgZ3JhbW1hcnMgZm9yIHdoaWNoIHRoZSBEaWFnbm9zdGljUHJvdmlkZXIgY2FuIHByb3ZpZGVcclxuICogZGlhZ25vc3RpY3MuXHJcbiAqIC0gVGhlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBhIHRleHQgZXZlbnQuXHJcbiAqXHJcbiAqIEEgVGV4dEV2ZW50RGlzcGF0Y2hlciB3aWxsIGJlIHN1YnNjcmliZWQgdG8gdGV4dCBldmVudHMgaWYgYW5kIG9ubHkgaWYgaXQgaGFzXHJcbiAqIHN1YnNjcmliZXJzIG9mIGl0cyBvd24uIElmIGFsbCBzdWJzY3JpYmVycyB1bnN1YnNjcmliZSwgaXQgd2lsbCB1bnN1YnNjcmliZVxyXG4gKiBmcm9tIEF0b20ncyB0ZXh0IGV2ZW50cy5cclxuICpcclxuICovXHJcbmV4cG9ydCBjbGFzcyBUZXh0RXZlbnREaXNwYXRjaGVyIHtcclxuICBfY2FsbGJhY2tDb250YWluZXI6IFRleHRDYWxsYmFja0NvbnRhaW5lcjxUZXh0RWRpdG9yPjtcclxuXHJcbiAgX2VkaXRvckxpc3RlbmVyRGlzcG9zYWJsZTogP1VuaXZlcnNhbERpc3Bvc2FibGU7XHJcblxyXG4gIF9wZW5kaW5nRXZlbnRzOiBXZWFrTWFwPGF0b20kVGV4dEJ1ZmZlciwgU2V0PEV2ZW50Pj47XHJcblxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy5fY2FsbGJhY2tDb250YWluZXIgPSBuZXcgVGV4dENhbGxiYWNrQ29udGFpbmVyKCk7XHJcbiAgICB0aGlzLl9lZGl0b3JMaXN0ZW5lckRpc3Bvc2FibGUgPSBudWxsO1xyXG4gICAgdGhpcy5fcGVuZGluZ0V2ZW50cyA9IG5ldyBXZWFrTWFwKCk7XHJcbiAgfVxyXG5cclxuICBfb25FdmVudHMoXHJcbiAgICBncmFtbWFyU2NvcGVzOiBJdGVyYWJsZTxzdHJpbmc+IHwgJ2FsbCcsXHJcbiAgICBldmVudHM6IEl0ZXJhYmxlPEV2ZW50PixcclxuICAgIGNhbGxiYWNrOiBFdmVudENhbGxiYWNrLFxyXG4gICkge1xyXG4gICAgaWYgKHRoaXMuX2NhbGxiYWNrQ29udGFpbmVyLmlzRW1wdHkoKSkge1xyXG4gICAgICB0aGlzLl9yZWdpc3RlckVkaXRvckxpc3RlbmVycygpO1xyXG4gICAgfVxyXG4gICAgLy8gU29tZXRpbWVzIHRoZXNlIGV2ZW50cyBnZXQgdHJpZ2dlcmVkIHNldmVyYWwgdGltZXMgaW4gc3VjY2Vzc2lvblxyXG4gICAgLy8gKHBhcnRpY3VsYXJseSBvbiBzdGFydHVwKS5cclxuICAgIGNvbnN0IGRlYm91bmNlZENhbGxiYWNrID0gZGVib3VuY2UoY2FsbGJhY2ssIDUwLCB0cnVlKTtcclxuICAgIHRoaXMuX2NhbGxiYWNrQ29udGFpbmVyLmFkZENhbGxiYWNrKFxyXG4gICAgICBncmFtbWFyU2NvcGVzLFxyXG4gICAgICBldmVudHMsXHJcbiAgICAgIGRlYm91bmNlZENhbGxiYWNrLFxyXG4gICAgKTtcclxuICAgIGNvbnN0IGRpc3Bvc2FibGVzID0gbmV3IFVuaXZlcnNhbERpc3Bvc2FibGUoKCkgPT4ge1xyXG4gICAgICB0aGlzLl9jYWxsYmFja0NvbnRhaW5lci5yZW1vdmVDYWxsYmFjayhcclxuICAgICAgICBncmFtbWFyU2NvcGVzLFxyXG4gICAgICAgIGV2ZW50cyxcclxuICAgICAgICBkZWJvdW5jZWRDYWxsYmFjayxcclxuICAgICAgKTtcclxuICAgICAgaWYgKHRoaXMuX2NhbGxiYWNrQ29udGFpbmVyLmlzRW1wdHkoKSkge1xyXG4gICAgICAgIHRoaXMuX2RlcmVnaXN0ZXJFZGl0b3JMaXN0ZW5lcnMoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gZGlzcG9zYWJsZXM7XHJcbiAgfVxyXG5cclxuICBvbkZpbGVDaGFuZ2UoXHJcbiAgICBncmFtbWFyU2NvcGVzOiBJdGVyYWJsZTxzdHJpbmc+LFxyXG4gICAgY2FsbGJhY2s6IEV2ZW50Q2FsbGJhY2ssXHJcbiAgKTogSURpc3Bvc2FibGUge1xyXG4gICAgcmV0dXJuIHRoaXMuX29uRXZlbnRzKGdyYW1tYXJTY29wZXMsIEZJTEVfQ0hBTkdFX0VWRU5UUywgY2FsbGJhY2spO1xyXG4gIH1cclxuXHJcbiAgb25BbnlGaWxlQ2hhbmdlKGNhbGxiYWNrOiBFdmVudENhbGxiYWNrKTogSURpc3Bvc2FibGUge1xyXG4gICAgcmV0dXJuIHRoaXMuX29uRXZlbnRzKCdhbGwnLCBGSUxFX0NIQU5HRV9FVkVOVFMsIGNhbGxiYWNrKTtcclxuICB9XHJcblxyXG4gIG9uRmlsZVNhdmUoXHJcbiAgICBncmFtbWFyU2NvcGVzOiBJdGVyYWJsZTxzdHJpbmc+LFxyXG4gICAgY2FsbGJhY2s6IEV2ZW50Q2FsbGJhY2ssXHJcbiAgKTogSURpc3Bvc2FibGUge1xyXG4gICAgcmV0dXJuIHRoaXMuX29uRXZlbnRzKGdyYW1tYXJTY29wZXMsIEZJTEVfU0FWRV9FVkVOVFMsIGNhbGxiYWNrKTtcclxuICB9XHJcblxyXG4gIG9uQW55RmlsZVNhdmUoY2FsbGJhY2s6IEV2ZW50Q2FsbGJhY2spOiBJRGlzcG9zYWJsZSB7XHJcbiAgICByZXR1cm4gdGhpcy5fb25FdmVudHMoJ2FsbCcsIEZJTEVfU0FWRV9FVkVOVFMsIGNhbGxiYWNrKTtcclxuICB9XHJcblxyXG4gIF9yZWdpc3RlckVkaXRvckxpc3RlbmVycygpOiB2b2lkIHtcclxuICAgIGlmICghdGhpcy5fZWRpdG9yTGlzdGVuZXJEaXNwb3NhYmxlKSB7XHJcbiAgICAgIHRoaXMuX2VkaXRvckxpc3RlbmVyRGlzcG9zYWJsZSA9IG5ldyBVbml2ZXJzYWxEaXNwb3NhYmxlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gV2hlbmV2ZXIgdGhlIGFjdGl2ZSBwYW5lIGl0ZW0gY2hhbmdlcywgd2UgY2hlY2sgdG8gc2VlIGlmIHRoZXJlIGFyZSBhbnlcclxuICAgIC8vIHBlbmRpbmcgZXZlbnRzIGZvciB0aGUgbmV3bHktZm9jdXNlZCBUZXh0RWRpdG9yLlxyXG4gICAgdGhpcy5fZ2V0RWRpdG9yTGlzdGVuZXJEaXNwb3NhYmxlKCkuYWRkKFxyXG4gICAgICBhdG9tLndvcmtzcGFjZS5vbkRpZENoYW5nZUFjdGl2ZVBhbmVJdGVtKCgpID0+IHtcclxuICAgICAgICBjb25zdCBjdXJyZW50RWRpdG9yID0gYXRvbS53b3Jrc3BhY2UuZ2V0QWN0aXZlVGV4dEVkaXRvcigpO1xyXG4gICAgICAgIGlmIChjdXJyZW50RWRpdG9yKSB7XHJcbiAgICAgICAgICBjb25zdCBwZW5kaW5nRXZlbnRzID0gdGhpcy5fcGVuZGluZ0V2ZW50cy5nZXQoXHJcbiAgICAgICAgICAgIGN1cnJlbnRFZGl0b3IuZ2V0QnVmZmVyKCksXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgaWYgKHBlbmRpbmdFdmVudHMpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiBwZW5kaW5nRXZlbnRzKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2hFdmVudHMoY3VycmVudEVkaXRvciwgZXZlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdFdmVudHMuZGVsZXRlKGN1cnJlbnRFZGl0b3IuZ2V0QnVmZmVyKCkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSksXHJcbiAgICApO1xyXG5cclxuICAgIHRoaXMuX2dldEVkaXRvckxpc3RlbmVyRGlzcG9zYWJsZSgpLmFkZChcclxuICAgICAgYXRvbS53b3Jrc3BhY2Uub2JzZXJ2ZVRleHRFZGl0b3JzKGVkaXRvciA9PiB7XHJcbiAgICAgICAgY29uc3QgYnVmZmVyID0gZWRpdG9yLmdldEJ1ZmZlcigpO1xyXG4gICAgICAgIGNvbnN0IG1ha2VEaXNwYXRjaCA9IChldmVudDogRXZlbnQpID0+IHtcclxuICAgICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnRzKGVkaXRvciwgZXZlbnQpO1xyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX2dldEVkaXRvckxpc3RlbmVyRGlzcG9zYWJsZSgpLmFkZFVudGlsRGVzdHJveWVkKFxyXG4gICAgICAgICAgZWRpdG9yLFxyXG4gICAgICAgICAgYnVmZmVyLm9uRGlkU3RvcENoYW5naW5nKG1ha2VEaXNwYXRjaCgnZGlkLWNoYW5nZScpKSxcclxuICAgICAgICAgIGJ1ZmZlci5vbkRpZFNhdmUobWFrZURpc3BhdGNoKCdkaWQtc2F2ZScpKSxcclxuICAgICAgICAgIGJ1ZmZlci5vbkRpZFJlbG9hZChtYWtlRGlzcGF0Y2goJ2RpZC1yZWxvYWQnKSksXHJcbiAgICAgICAgKTtcclxuICAgICAgICAvLyBEdXJpbmcgcmVsb2FkLCBtYW55IHRleHQgZWRpdG9ycyBhcmUgb3BlbmVkIHNpbXVsdGFuZW91c2x5LlxyXG4gICAgICAgIC8vIER1ZSB0byB0aGUgZGVib3VuY2Ugb24gdGhlIGV2ZW50IGNhbGxiYWNrLCB0aGlzIG1lYW5zIHRoYXQgbWFueSBlZGl0b3JzIG5ldmVyIHJlY2VpdmVcclxuICAgICAgICAvLyBhICdkaWQtb3BlbicgZXZlbnQuIFRvIHdvcmsgYXJvdW5kIHRoaXMsIGRlZmVyIGVkaXRvciBvcGVuIGV2ZW50cyBzbyB0aGF0IHNpbXVsdGFuZW91c1xyXG4gICAgICAgIC8vIG9wZW4gZXZlbnRzIGFyZSBwcm9wZXJseSByZWdpc3RlcmVkIGFzIHBlbmRpbmcuXHJcbiAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuX2Rpc3BhdGNoRXZlbnRzKGVkaXRvciwgJ2RpZC1vcGVuJykpO1xyXG4gICAgICB9KSxcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBfZGVyZWdpc3RlckVkaXRvckxpc3RlbmVycygpIHtcclxuICAgIGlmICh0aGlzLl9lZGl0b3JMaXN0ZW5lckRpc3Bvc2FibGUpIHtcclxuICAgICAgdGhpcy5fZ2V0RWRpdG9yTGlzdGVuZXJEaXNwb3NhYmxlKCkuZGlzcG9zZSgpO1xyXG4gICAgICB0aGlzLl9lZGl0b3JMaXN0ZW5lckRpc3Bvc2FibGUgPSBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX2Rpc3BhdGNoRXZlbnRzKGVkaXRvcjogVGV4dEVkaXRvciwgZXZlbnQ6IEV2ZW50KTogdm9pZCB7XHJcbiAgICBjb25zdCBjdXJyZW50RWRpdG9yID0gYXRvbS53b3Jrc3BhY2UuZ2V0QWN0aXZlVGV4dEVkaXRvcigpO1xyXG4gICAgaWYgKGN1cnJlbnRFZGl0b3IgJiYgZWRpdG9yID09PSBjdXJyZW50RWRpdG9yKSB7XHJcbiAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrQ29udGFpbmVyLmdldENhbGxiYWNrcyhcclxuICAgICAgICBlZGl0b3IuZ2V0R3JhbW1hcigpLnNjb3BlTmFtZSxcclxuICAgICAgICBldmVudCxcclxuICAgICAgKTtcclxuICAgICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiBjYWxsYmFja3MpIHtcclxuICAgICAgICBjYWxsYmFjayhlZGl0b3IpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIFdlIHdhbnQgdG8gYXZvaWQgc3RvcmluZyBwZW5kaW5nIGV2ZW50cyBpZiB0aGlzIGV2ZW50IHdhcyBnZW5lcmF0ZWQgYnlcclxuICAgICAgLy8gdGhlIHNhbWUgYnVmZmVyIGFzIHRoZSBjdXJyZW50IGVkaXRvciwgdG8gYXZvaWQgZHVwbGljYXRpbmcgZXZlbnRzIHdoZW5cclxuICAgICAgLy8gbXVsdGlwbGUgcGFuZXMgaGF2ZSB0aGUgc2FtZSBmaWxlIG9wZW4uXHJcbiAgICB9IGVsc2UgaWYgKFxyXG4gICAgICAhY3VycmVudEVkaXRvciB8fFxyXG4gICAgICBlZGl0b3IuZ2V0QnVmZmVyKCkgIT09IGN1cnJlbnRFZGl0b3IuZ2V0QnVmZmVyKClcclxuICAgICkge1xyXG4gICAgICAvLyBUcmlnZ2VyIHRoaXMgZXZlbnQgbmV4dCB0aW1lIHdlIHN3aXRjaCB0byBhbiBlZGl0b3Igd2l0aCB0aGlzIGJ1ZmZlci5cclxuICAgICAgY29uc3QgYnVmZmVyID0gZWRpdG9yLmdldEJ1ZmZlcigpO1xyXG4gICAgICBsZXQgZXZlbnRzID0gdGhpcy5fcGVuZGluZ0V2ZW50cy5nZXQoYnVmZmVyKTtcclxuICAgICAgaWYgKCFldmVudHMpIHtcclxuICAgICAgICBldmVudHMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgdGhpcy5fcGVuZGluZ0V2ZW50cy5zZXQoYnVmZmVyLCBldmVudHMpO1xyXG4gICAgICB9XHJcbiAgICAgIGV2ZW50cy5hZGQoZXZlbnQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX2dldEVkaXRvckxpc3RlbmVyRGlzcG9zYWJsZSgpOiBVbml2ZXJzYWxEaXNwb3NhYmxlIHtcclxuICAgIGNvbnN0IGRpc3Bvc2FibGUgPSB0aGlzLl9lZGl0b3JMaXN0ZW5lckRpc3Bvc2FibGU7XHJcbiAgICBpbnZhcmlhbnQoZGlzcG9zYWJsZSwgJ1RleHRFdmVudERpc3BhdGNoZXIgZGlzcG9zYWJsZSBpcyBub3QgaW5pdGlhbGl6ZWQnKTtcclxuICAgIHJldHVybiBkaXNwb3NhYmxlO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG9ic2VydmVUZXh0RWRpdG9yRXZlbnRzKFxyXG4gIGdyYW1tYXJTY29wZXM6IEl0ZXJhYmxlPHN0cmluZz4gfCAnYWxsJyxcclxuICBldmVudHM6ICdjaGFuZ2VzJyB8ICdzYXZlcycsXHJcbik6IE9ic2VydmFibGU8YXRvbSRUZXh0RWRpdG9yPiB7XHJcbiAgcmV0dXJuIE9ic2VydmFibGUuZGVmZXIoKCkgPT4ge1xyXG4gICAgY29uc3QgZGlzcGF0Y2hlciA9IG5ldyBUZXh0RXZlbnREaXNwYXRjaGVyKCk7XHJcbiAgICBpZiAoZXZlbnRzID09PSAnY2hhbmdlcycpIHtcclxuICAgICAgaWYgKGdyYW1tYXJTY29wZXMgPT09ICdhbGwnKSB7XHJcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGVGcm9tU3Vic2NyaWJlRnVuY3Rpb24oY2IgPT5cclxuICAgICAgICAgIGRpc3BhdGNoZXIub25BbnlGaWxlQ2hhbmdlKGNiKSxcclxuICAgICAgICApO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlRnJvbVN1YnNjcmliZUZ1bmN0aW9uKGNiID0+XHJcbiAgICAgICAgICBkaXNwYXRjaGVyLm9uRmlsZUNoYW5nZShncmFtbWFyU2NvcGVzLCBjYiksXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKGdyYW1tYXJTY29wZXMgPT09ICdhbGwnKSB7XHJcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGVGcm9tU3Vic2NyaWJlRnVuY3Rpb24oY2IgPT5cclxuICAgICAgICAgIGRpc3BhdGNoZXIub25BbnlGaWxlU2F2ZShjYiksXHJcbiAgICAgICAgKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZUZyb21TdWJzY3JpYmVGdW5jdGlvbihjYiA9PlxyXG4gICAgICAgICAgZGlzcGF0Y2hlci5vbkZpbGVTYXZlKGdyYW1tYXJTY29wZXMsIGNiKSxcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBfX1RFU1RfXyA9IHtcclxuICBUZXh0Q2FsbGJhY2tDb250YWluZXIsXHJcbn07XHJcbiJdfQ==