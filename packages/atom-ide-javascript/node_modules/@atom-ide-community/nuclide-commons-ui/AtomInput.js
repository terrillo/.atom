"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AtomInput = void 0;

var React = _interopRequireWildcard(require("react"));

var _classnames = _interopRequireDefault(require("classnames"));

var _assert = _interopRequireDefault(require("assert"));

var _string = require("@atom-ide-community/nuclide-commons/string");

var _observable = require("@atom-ide-community/nuclide-commons/observable");

var _debounce = _interopRequireDefault(require("@atom-ide-community/nuclide-commons/debounce"));

var _UniversalDisposable = _interopRequireDefault(require("@atom-ide-community/nuclide-commons/UniversalDisposable"));

var _atomTabIndexForwarder = _interopRequireDefault(require("./atomTabIndexForwarder"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */
const BLUR_FOCUS_DEBOUNCE_DELAY = 100;
/**
 * An input field rendered as an <atom-text-editor mini />.
 */

class AtomInput extends React.Component {
  static getDerivedStateFromProps(props) {
    const partialState = {};

    if (props.value != null) {
      partialState.value = props.value;
    }

    return partialState;
  }

  constructor(props) {
    var _props$value;

    super(props);
    this._disposables = void 0;
    this._rootNode = void 0;
    this._debouncedEditorBlur = void 0;
    this._debouncedEditorFocus = void 0;
    this._isFocused = void 0;
    this._tabIndexForwarding = void 0;

    this._onEditorFocus = () => {
      if (this.isFocused() && !this._isFocused) {
        this._isFocused = true;
        this.props.onFocus && this.props.onFocus();
      }
    };

    this._onEditorBlur = blurEvent => {
      if (!this.isFocused() && this._isFocused) {
        this._isFocused = false;
        this.props.onBlur && this.props.onBlur(blurEvent);
      }
    };

    this._textEditorRef = rootNode => {
      this._rootNode = rootNode;

      if (rootNode == null) {
        if (this._tabIndexForwarding != null) {
          this._tabIndexForwarding.dispose();

          this._tabIndexForwarding = null;
        }
      } else {
        this._tabIndexForwarding = (0, _atomTabIndexForwarder.default)(rootNode);
      }
    };

    this.state = {
      value: (_props$value = props.value) !== null && _props$value !== void 0 ? _props$value : props.initialValue
    };
    this._debouncedEditorFocus = (0, _debounce.default)(this._onEditorFocus, BLUR_FOCUS_DEBOUNCE_DELAY);
    this._debouncedEditorBlur = (0, _debounce.default)(this._onEditorBlur, BLUR_FOCUS_DEBOUNCE_DELAY);
  }

  componentDidMount() {
    const disposables = this._disposables = new _UniversalDisposable.default(); // There does not appear to be any sort of infinite loop where calling
    // setState({value}) in response to onDidChange() causes another change
    // event.

    const textEditor = this.getTextEditor();
    const textEditorElement = this.getTextEditorElement();

    if (this.props.autofocus) {
      this.focus();
    }

    (0, _assert.default)(!(this.props.startSelected && this.props.startSelectedRange != null), 'cannot have both startSelected (all) and startSelectedRange');

    if (this.props.startSelected) {
      // For some reason, selectAll() has no effect if called right now.
      disposables.add(_observable.microtask.subscribe(() => {
        if (!textEditor.isDestroyed()) {
          textEditor.selectAll();
        }
      }));
    }

    const startSelectedRange = this.props.startSelectedRange;

    if (startSelectedRange != null) {
      // For some reason, selectAll() has no effect if called right now.
      disposables.add(_observable.microtask.subscribe(() => {
        if (!textEditor.isDestroyed()) {
          textEditor.setSelectedBufferRange([[0, startSelectedRange[0]], [0, startSelectedRange[1]]]);
        }
      }));
    }

    disposables.add(atom.commands.add(textEditorElement, {
      'core:confirm': event => {
        if (this.props.onConfirm != null) {
          this.props.onConfirm(event);
        }
      },
      'core:cancel': event => {
        if (this.props.onCancel != null) {
          this.props.onCancel(event);
        }
      }
    }));
    const placeholderText = this.props.placeholderText;

    if (placeholderText != null) {
      textEditor.setPlaceholderText(placeholderText);
    }

    this.getTextEditorElement().setAttribute('tabindex', this.props.tabIndex);

    if (this.props.disabled) {
      this._updateDisabledState(true);
    } // Set the text editor's initial value and keep the cursor at the beginning of the line. Cursor
    // position was documented in a test and is retained here after changes to how text is set in
    // the text editor. (see focus-related spec in AtomInput-spec.js)


    this.setText(this.state.value);
    this.getTextEditor().moveToBeginningOfLine(); // Begin listening for changes only after initial value is set.

    disposables.add(textEditor.onDidChange(() => {
      this.setState({
        value: textEditor.getText()
      });
      this.props.onDidChange.call(null, textEditor.getText());
    }));

    if (this.props.onDidChangeSelectionRange != null) {
      disposables.add(textEditor.onDidChangeSelectionRange(this.props.onDidChangeSelectionRange));
    }

    this._updateWidth();
  }

  componentDidUpdate(prevProps, prevState) {
    this._updateWidth(prevProps.width);

    if (prevProps.disabled !== this.props.disabled) {
      this._updateDisabledState(this.props.disabled);
    }

    const newValue = this.props.value;

    if (newValue != null && prevProps.value !== newValue) {
      const editor = this.getTextEditor(); // Calling setText if the value did not change will redundantly call any
      // onDidChange listeners with the same input.

      if (editor.getText() !== newValue) {
        const cursorPosition = editor.getCursorBufferPosition();
        this.setText(newValue);
        editor.setCursorBufferPosition(cursorPosition);
      }
    }

    if (prevProps.placeholderText !== this.props.placeholderText) {
      this.getTextEditor().setPlaceholderText(this.props.placeholderText || '');
    }
  }

  componentWillUnmount() {
    // Note that destroy() is not part of TextEditor's public API.
    const editor = this.getTextEditor();
    process.nextTick(() => editor.destroy());

    if (this._disposables) {
      this._disposables.dispose();

      this._disposables = null;
    }
  }

  _updateDisabledState(isDisabled) {
    // Hack to set TextEditor to read-only mode, per https://github.com/atom/atom/issues/6880
    if (isDisabled) {
      this.getTextEditorElement().removeAttribute('tabindex');
    } else {
      this.getTextEditorElement().setAttribute('tabindex', this.props.tabIndex);
    }
  }

  isFocused() {
    return this._rootNode != null && this._rootNode.contains(document.activeElement);
  }

  render() {
    const className = (0, _classnames.default)(this.props.className, {
      'atom-text-editor-unstyled': this.props.unstyled,
      [`atom-text-editor-${(0, _string.maybeToString)(this.props.size)}`]: this.props.size != null,
      'atom-text-editor-invalid': this.props.invalid
    });
    return (
      /*#__PURE__*/
      // Because the contents of `<atom-text-editor>` elements are managed by its custom web
      // component class when "Use Shadow DOM" is disabled, this element should never have children.
      // If an element has no children, React guarantees it will never re-render the element (which
      // would wipe out the web component's work in this case).
      React.createElement("atom-text-editor", {
        class: className,
        mini: true,
        ref: this._textEditorRef,
        onClick: this.props.onClick,
        onFocus: this._debouncedEditorFocus,
        onBlur: this._debouncedEditorBlur,
        style: this.props.style
      })
    );
  }

  getText() {
    return this.state.value;
  }

  setText(text) {
    this.getTextEditor().setText(text);
  }

  getTextEditor() {
    return this.getTextEditorElement().getModel();
  }

  onDidChange(callback) {
    return this.getTextEditor().getBuffer().onDidChangeText(callback);
  }

  getTextEditorElement() {
    (0, _assert.default)(this._rootNode != null); // $FlowFixMe

    return this._rootNode;
  }

  _updateWidth(prevWidth) {
    if (this.props.width !== prevWidth) {
      const width = this.props.width == null ? undefined : this.props.width;
      this.getTextEditorElement().setWidth(width);
    }
  }

  focus() {
    this.getTextEditor().moveToEndOfLine();
    this.getTextEditorElement().focus();
  }

}

exports.AtomInput = AtomInput;
AtomInput.defaultProps = {
  disabled: false,
  autofocus: false,
  startSelected: false,
  initialValue: '',
  tabIndex: '0',
  // Default to all <AtomInput /> components being in tab order
  onClick: () => {},
  onDidChange: () => {},
  onFocus: () => {},
  onBlur: () => {},
  unstyled: false,
  style: null
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zLXVpL0F0b21JbnB1dC5qcyJdLCJuYW1lcyI6WyJCTFVSX0ZPQ1VTX0RFQk9VTkNFX0RFTEFZIiwiQXRvbUlucHV0IiwiUmVhY3QiLCJDb21wb25lbnQiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJwcm9wcyIsInBhcnRpYWxTdGF0ZSIsInZhbHVlIiwiY29uc3RydWN0b3IiLCJfZGlzcG9zYWJsZXMiLCJfcm9vdE5vZGUiLCJfZGVib3VuY2VkRWRpdG9yQmx1ciIsIl9kZWJvdW5jZWRFZGl0b3JGb2N1cyIsIl9pc0ZvY3VzZWQiLCJfdGFiSW5kZXhGb3J3YXJkaW5nIiwiX29uRWRpdG9yRm9jdXMiLCJpc0ZvY3VzZWQiLCJvbkZvY3VzIiwiX29uRWRpdG9yQmx1ciIsImJsdXJFdmVudCIsIm9uQmx1ciIsIl90ZXh0RWRpdG9yUmVmIiwicm9vdE5vZGUiLCJkaXNwb3NlIiwic3RhdGUiLCJpbml0aWFsVmFsdWUiLCJjb21wb25lbnREaWRNb3VudCIsImRpc3Bvc2FibGVzIiwiVW5pdmVyc2FsRGlzcG9zYWJsZSIsInRleHRFZGl0b3IiLCJnZXRUZXh0RWRpdG9yIiwidGV4dEVkaXRvckVsZW1lbnQiLCJnZXRUZXh0RWRpdG9yRWxlbWVudCIsImF1dG9mb2N1cyIsImZvY3VzIiwic3RhcnRTZWxlY3RlZCIsInN0YXJ0U2VsZWN0ZWRSYW5nZSIsImFkZCIsIm1pY3JvdGFzayIsInN1YnNjcmliZSIsImlzRGVzdHJveWVkIiwic2VsZWN0QWxsIiwic2V0U2VsZWN0ZWRCdWZmZXJSYW5nZSIsImF0b20iLCJjb21tYW5kcyIsImV2ZW50Iiwib25Db25maXJtIiwib25DYW5jZWwiLCJwbGFjZWhvbGRlclRleHQiLCJzZXRQbGFjZWhvbGRlclRleHQiLCJzZXRBdHRyaWJ1dGUiLCJ0YWJJbmRleCIsImRpc2FibGVkIiwiX3VwZGF0ZURpc2FibGVkU3RhdGUiLCJzZXRUZXh0IiwibW92ZVRvQmVnaW5uaW5nT2ZMaW5lIiwib25EaWRDaGFuZ2UiLCJzZXRTdGF0ZSIsImdldFRleHQiLCJjYWxsIiwib25EaWRDaGFuZ2VTZWxlY3Rpb25SYW5nZSIsIl91cGRhdGVXaWR0aCIsImNvbXBvbmVudERpZFVwZGF0ZSIsInByZXZQcm9wcyIsInByZXZTdGF0ZSIsIndpZHRoIiwibmV3VmFsdWUiLCJlZGl0b3IiLCJjdXJzb3JQb3NpdGlvbiIsImdldEN1cnNvckJ1ZmZlclBvc2l0aW9uIiwic2V0Q3Vyc29yQnVmZmVyUG9zaXRpb24iLCJjb21wb25lbnRXaWxsVW5tb3VudCIsInByb2Nlc3MiLCJuZXh0VGljayIsImRlc3Ryb3kiLCJpc0Rpc2FibGVkIiwicmVtb3ZlQXR0cmlidXRlIiwiY29udGFpbnMiLCJkb2N1bWVudCIsImFjdGl2ZUVsZW1lbnQiLCJyZW5kZXIiLCJjbGFzc05hbWUiLCJ1bnN0eWxlZCIsInNpemUiLCJpbnZhbGlkIiwib25DbGljayIsInN0eWxlIiwidGV4dCIsImdldE1vZGVsIiwiY2FsbGJhY2siLCJnZXRCdWZmZXIiLCJvbkRpZENoYW5nZVRleHQiLCJwcmV2V2lkdGgiLCJ1bmRlZmluZWQiLCJzZXRXaWR0aCIsIm1vdmVUb0VuZE9mTGluZSIsImRlZmF1bHRQcm9wcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQVlBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7OztBQXBCQTs7Ozs7Ozs7Ozs7QUFvREEsTUFBTUEseUJBQXlCLEdBQUcsR0FBbEM7QUFFQTs7OztBQUdPLE1BQU1DLFNBQU4sU0FBd0JDLEtBQUssQ0FBQ0MsU0FBOUIsQ0FBc0Q7QUFzQjNELFNBQU9DLHdCQUFQLENBQWdDQyxLQUFoQyxFQUE4QztBQUM1QyxVQUFNQyxZQUFZLEdBQUcsRUFBckI7O0FBQ0EsUUFBSUQsS0FBSyxDQUFDRSxLQUFOLElBQWUsSUFBbkIsRUFBeUI7QUFDdkJELE1BQUFBLFlBQVksQ0FBQ0MsS0FBYixHQUFxQkYsS0FBSyxDQUFDRSxLQUEzQjtBQUNEOztBQUVE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a0IsSUFBNUIsRUFENkMsQ0FFN0M7O0FBQ0EsV0FBTyxLQUFLQSxTQUFaO0FBQ0Q7O0FBRURtRCxFQUFBQSxZQUFZLENBQUMrQixTQUFELEVBQTJCO0FBQ3JDLFFBQUksS0FBS3ZGLEtBQUwsQ0FBVzRELEtBQVgsS0FBcUIyQixTQUF6QixFQUFvQztBQUNsQyxZQUFNM0IsS0FBSyxHQUFHLEtBQUs1RCxLQUFMLENBQVc0RCxLQUFYLElBQW9CLElBQXBCLEdBQTJCNEIsU0FBM0IsR0FBdUMsS0FBS3hGLEtBQUwsQ0FBVzRELEtBQWhFO0FBQ0EsV0FBS2pDLG9CQUFMLEdBQTRCOEQsUUFBNUIsQ0FBcUM3QixLQUFyQztBQUNEO0FBQ0Y7O0FBRUQvQixFQUFBQSxLQUFLLEdBQVM7QUFDWixTQUFLSixhQUFMLEdBQXFCaUUsZUFBckI7QUFDQSxTQUFLL0Qsb0JBQUwsR0FBNEJFLEtBQTVCO0FBQ0Q7O0FBaFIwRDs7O0FBQWhEakMsUyxDQVFKK0YsWSxHQUFlO0FBQ3BCNUMsRUFBQUEsUUFBUSxFQUFFLEtBRFU7QUFFcEJuQixFQUFBQSxTQUFTLEVBQUUsS0FGUztBQUdwQkUsRUFBQUEsYUFBYSxFQUFFLEtBSEs7QUFJcEJWLEVBQUFBLFlBQVksRUFBRSxFQUpNO0FBS3BCMEIsRUFBQUEsUUFBUSxFQUFFLEdBTFU7QUFLTDtBQUNma0MsRUFBQUEsT0FBTyxFQUFFLE1BQU0sQ0FBRSxDQU5HO0FBT3BCN0IsRUFBQUEsV0FBVyxFQUFFLE1BQU0sQ0FBRSxDQVBEO0FBUXBCdkMsRUFBQUEsT0FBTyxFQUFFLE1BQU0sQ0FBRSxDQVJHO0FBU3BCRyxFQUFBQSxNQUFNLEVBQUUsTUFBTSxDQUFFLENBVEk7QUFVcEI4RCxFQUFBQSxRQUFRLEVBQUUsS0FWVTtBQVdwQkksRUFBQUEsS0FBSyxFQUFFO0FBWGEsQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTctcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogQGZsb3dcclxuICogQGZvcm1hdFxyXG4gKi9cclxuXHJcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnYXNzZXJ0JztcclxuXHJcbmltcG9ydCB7bWF5YmVUb1N0cmluZ30gZnJvbSAnQGF0b20taWRlLWNvbW11bml0eS9udWNsaWRlLWNvbW1vbnMvc3RyaW5nJztcclxuaW1wb3J0IHttaWNyb3Rhc2t9IGZyb20gJ0BhdG9tLWlkZS1jb21tdW5pdHkvbnVjbGlkZS1jb21tb25zL29ic2VydmFibGUnO1xyXG5pbXBvcnQgZGVib3VuY2UgZnJvbSAnQGF0b20taWRlLWNvbW11bml0eS9udWNsaWRlLWNvbW1vbnMvZGVib3VuY2UnO1xyXG5pbXBvcnQgVW5pdmVyc2FsRGlzcG9zYWJsZSBmcm9tICdAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtY29tbW9ucy9Vbml2ZXJzYWxEaXNwb3NhYmxlJztcclxuaW1wb3J0IGF0b21UYWJJbmRleEZvcndhcmRlciBmcm9tICcuL2F0b21UYWJJbmRleEZvcndhcmRlcic7XHJcblxyXG50eXBlIFByb3BzID0ge1xyXG4gIGNsYXNzTmFtZT86IHN0cmluZyxcclxuICBkaXNhYmxlZDogYm9vbGVhbixcclxuICBhdXRvZm9jdXM6IGJvb2xlYW4sXHJcbiAgc3RhcnRTZWxlY3RlZDogYm9vbGVhbixcclxuICBzdGFydFNlbGVjdGVkUmFuZ2U/OiA/W251bWJlciwgbnVtYmVyXSxcclxuICBpbml0aWFsVmFsdWU6IHN0cmluZyxcclxuICBpbnZhbGlkPzogYm9vbGVhbixcclxuICBwbGFjZWhvbGRlclRleHQ/OiBzdHJpbmcsXHJcbiAgdGFiSW5kZXg6IHN0cmluZyxcclxuICBvbkZvY3VzOiAoKSA9PiBtaXhlZCxcclxuICBvbkNsaWNrOiAoZXZlbnQ6IFN5bnRoZXRpY01vdXNlRXZlbnQ8PikgPT4gbWl4ZWQsXHJcbiAgb25EaWRDaGFuZ2U6ICh0ZXh0OiBzdHJpbmcpID0+IG1peGVkLFxyXG4gIG9uRGlkQ2hhbmdlU2VsZWN0aW9uUmFuZ2U/OiAoZXZlbnQ6IGF0b20kQ2hhbmdlU2VsZWN0aW9uUmFuZ2VFdmVudCkgPT4gbWl4ZWQsXHJcbiAgb25Db25maXJtPzogKGV2ZW50PzogYXRvbSRDdXN0b21FdmVudCkgPT4gbWl4ZWQsXHJcbiAgb25DYW5jZWw/OiAoZXZlbnQ/OiBhdG9tJEN1c3RvbUV2ZW50KSA9PiBtaXhlZCxcclxuICBvbkJsdXI6IChibHVyRXZlbnQ6IEV2ZW50KSA9PiBtaXhlZCxcclxuICBzaXplPzogJ3hzJyB8ICdzbScgfCAnbGcnLFxyXG4gIHVuc3R5bGVkOiBib29sZWFuLFxyXG4gIHdpZHRoPzogP251bWJlcixcclxuICAvLyBJZiB0aGUgYHZhbHVlYCBwcm9wIGlzIHNwZWNpZmllZCwgdGhlbiB0aGUgY29tcG9uZW50J3MgZGlzcGxheWVkIHRleHQgaXMgY29udHJvbGxlZCBieSB0aGlzXHJcbiAgLy8gcHJvcC4gIE90aGVyd2lzZSBpdHMgZGlzcGxheWVkIHRleHQgbXVzdCBiZSBpbXBlcmF0aXZlbHkgc2V0IG9uIHRoZSBpbnN0YW5jZS5cclxuICB2YWx1ZT86IHN0cmluZyxcclxuICBzdHlsZTogP09iamVjdCxcclxufTtcclxuXHJcbnR5cGUgU3RhdGUgPSB7fFxyXG4gIHZhbHVlOiBzdHJpbmcsXHJcbnx9O1xyXG5cclxuY29uc3QgQkxVUl9GT0NVU19ERUJPVU5DRV9ERUxBWSA9IDEwMDtcclxuXHJcbi8qKlxyXG4gKiBBbiBpbnB1dCBmaWVsZCByZW5kZXJlZCBhcyBhbiA8YXRvbS10ZXh0LWVkaXRvciBtaW5pIC8+LlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEF0b21JbnB1dCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxQcm9wcywgU3RhdGU+IHtcclxuICBfZGlzcG9zYWJsZXM6ID9Vbml2ZXJzYWxEaXNwb3NhYmxlO1xyXG4gIF9yb290Tm9kZTogP0hUTUxFbGVtZW50O1xyXG4gIF9kZWJvdW5jZWRFZGl0b3JCbHVyOiAoYmx1ckV2ZW50OiBFdmVudCkgPT4gdm9pZDtcclxuICBfZGVib3VuY2VkRWRpdG9yRm9jdXM6ICgpID0+IHZvaWQ7XHJcbiAgX2lzRm9jdXNlZDogYm9vbGVhbjtcclxuICBfdGFiSW5kZXhGb3J3YXJkaW5nOiA/SURpc3Bvc2FibGU7XHJcblxyXG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XHJcbiAgICBkaXNhYmxlZDogZmFsc2UsXHJcbiAgICBhdXRvZm9jdXM6IGZhbHNlLFxyXG4gICAgc3RhcnRTZWxlY3RlZDogZmFsc2UsXHJcbiAgICBpbml0aWFsVmFsdWU6ICcnLFxyXG4gICAgdGFiSW5kZXg6ICcwJywgLy8gRGVmYXVsdCB0byBhbGwgPEF0b21JbnB1dCAvPiBjb21wb25lbnRzIGJlaW5nIGluIHRhYiBvcmRlclxyXG4gICAgb25DbGljazogKCkgPT4ge30sXHJcbiAgICBvbkRpZENoYW5nZTogKCkgPT4ge30sXHJcbiAgICBvbkZvY3VzOiAoKSA9PiB7fSxcclxuICAgIG9uQmx1cjogKCkgPT4ge30sXHJcbiAgICB1bnN0eWxlZDogZmFsc2UsXHJcbiAgICBzdHlsZTogbnVsbCxcclxuICB9O1xyXG5cclxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKHByb3BzOiBQcm9wcykge1xyXG4gICAgY29uc3QgcGFydGlhbFN0YXRlID0ge307XHJcbiAgICBpZiAocHJvcHMudmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICBwYXJ0aWFsU3RhdGUudmFsdWUgPSBwcm9wcy52YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcGFydGlhbFN0YXRlO1xyXG4gIH1cclxuXHJcbiAgY29uc3RydWN0b3IocHJvcHM6IFByb3BzKSB7XHJcbiAgICBzdXBlcihwcm9wcyk7XHJcblxyXG4gICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgdmFsdWU6IHByb3BzLnZhbHVlID8/IHByb3BzLmluaXRpYWxWYWx1ZSxcclxuICAgIH07XHJcbiAgICB0aGlzLl9kZWJvdW5jZWRFZGl0b3JGb2N1cyA9IGRlYm91bmNlKFxyXG4gICAgICB0aGlzLl9vbkVkaXRvckZvY3VzLFxyXG4gICAgICBCTFVSX0ZPQ1VTX0RFQk9VTkNFX0RFTEFZLFxyXG4gICAgKTtcclxuICAgIHRoaXMuX2RlYm91bmNlZEVkaXRvckJsdXIgPSBkZWJvdW5jZShcclxuICAgICAgdGhpcy5fb25FZGl0b3JCbHVyLFxyXG4gICAgICBCTFVSX0ZPQ1VTX0RFQk9VTkNFX0RFTEFZLFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGNvbXBvbmVudERpZE1vdW50KCk6IHZvaWQge1xyXG4gICAgY29uc3QgZGlzcG9zYWJsZXMgPSAodGhpcy5fZGlzcG9zYWJsZXMgPSBuZXcgVW5pdmVyc2FsRGlzcG9zYWJsZSgpKTtcclxuXHJcbiAgICAvLyBUaGVyZSBkb2VzIG5vdCBhcHBlYXIgdG8gYmUgYW55IHNvcnQgb2YgaW5maW5pdGUgbG9vcCB3aGVyZSBjYWxsaW5nXHJcbiAgICAvLyBzZXRTdGF0ZSh7dmFsdWV9KSBpbiByZXNwb25zZSB0byBvbkRpZENoYW5nZSgpIGNhdXNlcyBhbm90aGVyIGNoYW5nZVxyXG4gICAgLy8gZXZlbnQuXHJcbiAgICBjb25zdCB0ZXh0RWRpdG9yID0gdGhpcy5nZXRUZXh0RWRpdG9yKCk7XHJcbiAgICBjb25zdCB0ZXh0RWRpdG9yRWxlbWVudCA9IHRoaXMuZ2V0VGV4dEVkaXRvckVsZW1lbnQoKTtcclxuICAgIGlmICh0aGlzLnByb3BzLmF1dG9mb2N1cykge1xyXG4gICAgICB0aGlzLmZvY3VzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaW52YXJpYW50KFxyXG4gICAgICAhKHRoaXMucHJvcHMuc3RhcnRTZWxlY3RlZCAmJiB0aGlzLnByb3BzLnN0YXJ0U2VsZWN0ZWRSYW5nZSAhPSBudWxsKSxcclxuICAgICAgJ2Nhbm5vdCBoYXZlIGJvdGggc3RhcnRTZWxlY3RlZCAoYWxsKSBhbmQgc3RhcnRTZWxlY3RlZFJhbmdlJyxcclxuICAgICk7XHJcblxyXG4gICAgaWYgKHRoaXMucHJvcHMuc3RhcnRTZWxlY3RlZCkge1xyXG4gICAgICAvLyBGb3Igc29tZSByZWFzb24sIHNlbGVjdEFsbCgpIGhhcyBubyBlZmZlY3QgaWYgY2FsbGVkIHJpZ2h0IG5vdy5cclxuICAgICAgZGlzcG9zYWJsZXMuYWRkKFxyXG4gICAgICAgIG1pY3JvdGFzay5zdWJzY3JpYmUoKCkgPT4ge1xyXG4gICAgICAgICAgaWYgKCF0ZXh0RWRpdG9yLmlzRGVzdHJveWVkKCkpIHtcclxuICAgICAgICAgICAgdGV4dEVkaXRvci5zZWxlY3RBbGwoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KSxcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzdGFydFNlbGVjdGVkUmFuZ2UgPSB0aGlzLnByb3BzLnN0YXJ0U2VsZWN0ZWRSYW5nZTtcclxuICAgIGlmIChzdGFydFNlbGVjdGVkUmFuZ2UgIT0gbnVsbCkge1xyXG4gICAgICAvLyBGb3Igc29tZSByZWFzb24sIHNlbGVjdEFsbCgpIGhhcyBubyBlZmZlY3QgaWYgY2FsbGVkIHJpZ2h0IG5vdy5cclxuICAgICAgZGlzcG9zYWJsZXMuYWRkKFxyXG4gICAgICAgIG1pY3JvdGFzay5zdWJzY3JpYmUoKCkgPT4ge1xyXG4gICAgICAgICAgaWYgKCF0ZXh0RWRpdG9yLmlzRGVzdHJveWVkKCkpIHtcclxuICAgICAgICAgICAgdGV4dEVkaXRvci5zZXRTZWxlY3RlZEJ1ZmZlclJhbmdlKFtcclxuICAgICAgICAgICAgICBbMCwgc3RhcnRTZWxlY3RlZFJhbmdlWzBdXSxcclxuICAgICAgICAgICAgICBbMCwgc3RhcnRTZWxlY3RlZFJhbmdlWzFdXSxcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSksXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgZGlzcG9zYWJsZXMuYWRkKFxyXG4gICAgICBhdG9tLmNvbW1hbmRzLmFkZCh0ZXh0RWRpdG9yRWxlbWVudCwge1xyXG4gICAgICAgICdjb3JlOmNvbmZpcm0nOiBldmVudCA9PiB7XHJcbiAgICAgICAgICBpZiAodGhpcy5wcm9wcy5vbkNvbmZpcm0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uQ29uZmlybShldmVudCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAnY29yZTpjYW5jZWwnOiBldmVudCA9PiB7XHJcbiAgICAgICAgICBpZiAodGhpcy5wcm9wcy5vbkNhbmNlbCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25DYW5jZWwoZXZlbnQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0pLFxyXG4gICAgKTtcclxuICAgIGNvbnN0IHBsYWNlaG9sZGVyVGV4dCA9IHRoaXMucHJvcHMucGxhY2Vob2xkZXJUZXh0O1xyXG4gICAgaWYgKHBsYWNlaG9sZGVyVGV4dCAhPSBudWxsKSB7XHJcbiAgICAgIHRleHRFZGl0b3Iuc2V0UGxhY2Vob2xkZXJUZXh0KHBsYWNlaG9sZGVyVGV4dCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmdldFRleHRFZGl0b3JFbGVtZW50KCkuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIHRoaXMucHJvcHMudGFiSW5kZXgpO1xyXG4gICAgaWYgKHRoaXMucHJvcHMuZGlzYWJsZWQpIHtcclxuICAgICAgdGhpcy5fdXBkYXRlRGlzYWJsZWRTdGF0ZSh0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTZXQgdGhlIHRleHQgZWRpdG9yJ3MgaW5pdGlhbCB2YWx1ZSBhbmQga2VlcCB0aGUgY3Vyc29yIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpbmUuIEN1cnNvclxyXG4gICAgLy8gcG9zaXRpb24gd2FzIGRvY3VtZW50ZWQgaW4gYSB0ZXN0IGFuZCBpcyByZXRhaW5lZCBoZXJlIGFmdGVyIGNoYW5nZXMgdG8gaG93IHRleHQgaXMgc2V0IGluXHJcbiAgICAvLyB0aGUgdGV4dCBlZGl0b3IuIChzZWUgZm9jdXMtcmVsYXRlZCBzcGVjIGluIEF0b21JbnB1dC1zcGVjLmpzKVxyXG4gICAgdGhpcy5zZXRUZXh0KHRoaXMuc3RhdGUudmFsdWUpO1xyXG4gICAgdGhpcy5nZXRUZXh0RWRpdG9yKCkubW92ZVRvQmVnaW5uaW5nT2ZMaW5lKCk7XHJcblxyXG4gICAgLy8gQmVnaW4gbGlzdGVuaW5nIGZvciBjaGFuZ2VzIG9ubHkgYWZ0ZXIgaW5pdGlhbCB2YWx1ZSBpcyBzZXQuXHJcbiAgICBkaXNwb3NhYmxlcy5hZGQoXHJcbiAgICAgIHRleHRFZGl0b3Iub25EaWRDaGFuZ2UoKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe3ZhbHVlOiB0ZXh0RWRpdG9yLmdldFRleHQoKX0pO1xyXG4gICAgICAgIHRoaXMucHJvcHMub25EaWRDaGFuZ2UuY2FsbChudWxsLCB0ZXh0RWRpdG9yLmdldFRleHQoKSk7XHJcbiAgICAgIH0pLFxyXG4gICAgKTtcclxuICAgIGlmICh0aGlzLnByb3BzLm9uRGlkQ2hhbmdlU2VsZWN0aW9uUmFuZ2UgIT0gbnVsbCkge1xyXG4gICAgICBkaXNwb3NhYmxlcy5hZGQoXHJcbiAgICAgICAgdGV4dEVkaXRvci5vbkRpZENoYW5nZVNlbGVjdGlvblJhbmdlKFxyXG4gICAgICAgICAgdGhpcy5wcm9wcy5vbkRpZENoYW5nZVNlbGVjdGlvblJhbmdlLFxyXG4gICAgICAgICksXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fdXBkYXRlV2lkdGgoKTtcclxuICB9XHJcblxyXG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHM6IE9iamVjdCwgcHJldlN0YXRlOiBPYmplY3QpOiB2b2lkIHtcclxuICAgIHRoaXMuX3VwZGF0ZVdpZHRoKHByZXZQcm9wcy53aWR0aCk7XHJcblxyXG4gICAgaWYgKHByZXZQcm9wcy5kaXNhYmxlZCAhPT0gdGhpcy5wcm9wcy5kaXNhYmxlZCkge1xyXG4gICAgICB0aGlzLl91cGRhdGVEaXNhYmxlZFN0YXRlKHRoaXMucHJvcHMuZGlzYWJsZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG5ld1ZhbHVlID0gdGhpcy5wcm9wcy52YWx1ZTtcclxuICAgIGlmIChuZXdWYWx1ZSAhPSBudWxsICYmIHByZXZQcm9wcy52YWx1ZSAhPT0gbmV3VmFsdWUpIHtcclxuICAgICAgY29uc3QgZWRpdG9yID0gdGhpcy5nZXRUZXh0RWRpdG9yKCk7XHJcbiAgICAgIC8vIENhbGxpbmcgc2V0VGV4dCBpZiB0aGUgdmFsdWUgZGlkIG5vdCBjaGFuZ2Ugd2lsbCByZWR1bmRhbnRseSBjYWxsIGFueVxyXG4gICAgICAvLyBvbkRpZENoYW5nZSBsaXN0ZW5lcnMgd2l0aCB0aGUgc2FtZSBpbnB1dC5cclxuICAgICAgaWYgKGVkaXRvci5nZXRUZXh0KCkgIT09IG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgY3Vyc29yUG9zaXRpb24gPSBlZGl0b3IuZ2V0Q3Vyc29yQnVmZmVyUG9zaXRpb24oKTtcclxuICAgICAgICB0aGlzLnNldFRleHQobmV3VmFsdWUpO1xyXG4gICAgICAgIGVkaXRvci5zZXRDdXJzb3JCdWZmZXJQb3NpdGlvbihjdXJzb3JQb3NpdGlvbik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAocHJldlByb3BzLnBsYWNlaG9sZGVyVGV4dCAhPT0gdGhpcy5wcm9wcy5wbGFjZWhvbGRlclRleHQpIHtcclxuICAgICAgdGhpcy5nZXRUZXh0RWRpdG9yKCkuc2V0UGxhY2Vob2xkZXJUZXh0KHRoaXMucHJvcHMucGxhY2Vob2xkZXJUZXh0IHx8ICcnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCk6IHZvaWQge1xyXG4gICAgLy8gTm90ZSB0aGF0IGRlc3Ryb3koKSBpcyBub3QgcGFydCBvZiBUZXh0RWRpdG9yJ3MgcHVibGljIEFQSS5cclxuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuZ2V0VGV4dEVkaXRvcigpO1xyXG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiBlZGl0b3IuZGVzdHJveSgpKTtcclxuXHJcbiAgICBpZiAodGhpcy5fZGlzcG9zYWJsZXMpIHtcclxuICAgICAgdGhpcy5fZGlzcG9zYWJsZXMuZGlzcG9zZSgpO1xyXG4gICAgICB0aGlzLl9kaXNwb3NhYmxlcyA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfdXBkYXRlRGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAvLyBIYWNrIHRvIHNldCBUZXh0RWRpdG9yIHRvIHJlYWQtb25seSBtb2RlLCBwZXIgaHR0cHM6Ly9naXRodWIuY29tL2F0b20vYXRvbS9pc3N1ZXMvNjg4MFxyXG4gICAgaWYgKGlzRGlzYWJsZWQpIHtcclxuICAgICAgdGhpcy5nZXRUZXh0RWRpdG9yRWxlbWVudCgpLnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuZ2V0VGV4dEVkaXRvckVsZW1lbnQoKS5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgdGhpcy5wcm9wcy50YWJJbmRleCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfb25FZGl0b3JGb2N1cyA9ICgpOiB2b2lkID0+IHtcclxuICAgIGlmICh0aGlzLmlzRm9jdXNlZCgpICYmICF0aGlzLl9pc0ZvY3VzZWQpIHtcclxuICAgICAgdGhpcy5faXNGb2N1c2VkID0gdHJ1ZTtcclxuICAgICAgdGhpcy5wcm9wcy5vbkZvY3VzICYmIHRoaXMucHJvcHMub25Gb2N1cygpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIF9vbkVkaXRvckJsdXIgPSAoYmx1ckV2ZW50OiBFdmVudCk6IHZvaWQgPT4ge1xyXG4gICAgaWYgKCF0aGlzLmlzRm9jdXNlZCgpICYmIHRoaXMuX2lzRm9jdXNlZCkge1xyXG4gICAgICB0aGlzLl9pc0ZvY3VzZWQgPSBmYWxzZTtcclxuICAgICAgdGhpcy5wcm9wcy5vbkJsdXIgJiYgdGhpcy5wcm9wcy5vbkJsdXIoYmx1ckV2ZW50KTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBpc0ZvY3VzZWQoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICB0aGlzLl9yb290Tm9kZSAhPSBudWxsICYmIHRoaXMuX3Jvb3ROb2RlLmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgcmVuZGVyKCk6IFJlYWN0Lk5vZGUge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lID0gY2xhc3NOYW1lcyh0aGlzLnByb3BzLmNsYXNzTmFtZSwge1xyXG4gICAgICAnYXRvbS10ZXh0LWVkaXRvci11bnN0eWxlZCc6IHRoaXMucHJvcHMudW5zdHlsZWQsXHJcbiAgICAgIFtgYXRvbS10ZXh0LWVkaXRvci0ke21heWJlVG9TdHJpbmcodGhpcy5wcm9wcy5zaXplKX1gXTpcclxuICAgICAgICB0aGlzLnByb3BzLnNpemUgIT0gbnVsbCxcclxuICAgICAgJ2F0b20tdGV4dC1lZGl0b3ItaW52YWxpZCc6IHRoaXMucHJvcHMuaW52YWxpZCxcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgIC8vIEJlY2F1c2UgdGhlIGNvbnRlbnRzIG9mIGA8YXRvbS10ZXh0LWVkaXRvcj5gIGVsZW1lbnRzIGFyZSBtYW5hZ2VkIGJ5IGl0cyBjdXN0b20gd2ViXHJcbiAgICAgIC8vIGNvbXBvbmVudCBjbGFzcyB3aGVuIFwiVXNlIFNoYWRvdyBET01cIiBpcyBkaXNhYmxlZCwgdGhpcyBlbGVtZW50IHNob3VsZCBuZXZlciBoYXZlIGNoaWxkcmVuLlxyXG4gICAgICAvLyBJZiBhbiBlbGVtZW50IGhhcyBubyBjaGlsZHJlbiwgUmVhY3QgZ3VhcmFudGVlcyBpdCB3aWxsIG5ldmVyIHJlLXJlbmRlciB0aGUgZWxlbWVudCAod2hpY2hcclxuICAgICAgLy8gd291bGQgd2lwZSBvdXQgdGhlIHdlYiBjb21wb25lbnQncyB3b3JrIGluIHRoaXMgY2FzZSkuXHJcbiAgICAgIDxhdG9tLXRleHQtZWRpdG9yXHJcbiAgICAgICAgY2xhc3M9e2NsYXNzTmFtZX1cclxuICAgICAgICBtaW5pXHJcbiAgICAgICAgcmVmPXt0aGlzLl90ZXh0RWRpdG9yUmVmfVxyXG4gICAgICAgIG9uQ2xpY2s9e3RoaXMucHJvcHMub25DbGlja31cclxuICAgICAgICBvbkZvY3VzPXt0aGlzLl9kZWJvdW5jZWRFZGl0b3JGb2N1c31cclxuICAgICAgICBvbkJsdXI9e3RoaXMuX2RlYm91bmNlZEVkaXRvckJsdXJ9XHJcbiAgICAgICAgc3R5bGU9e3RoaXMucHJvcHMuc3R5bGV9XHJcbiAgICAgIC8+XHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgX3RleHRFZGl0b3JSZWYgPSAocm9vdE5vZGU6ID9IVE1MRWxlbWVudCk6IHZvaWQgPT4ge1xyXG4gICAgdGhpcy5fcm9vdE5vZGUgPSByb290Tm9kZTtcclxuICAgIGlmIChyb290Tm9kZSA9PSBudWxsKSB7XHJcbiAgICAgIGlmICh0aGlzLl90YWJJbmRleEZvcndhcmRpbmcgIT0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMuX3RhYkluZGV4Rm9yd2FyZGluZy5kaXNwb3NlKCk7XHJcbiAgICAgICAgdGhpcy5fdGFiSW5kZXhGb3J3YXJkaW5nID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5fdGFiSW5kZXhGb3J3YXJkaW5nID0gYXRvbVRhYkluZGV4Rm9yd2FyZGVyKHJvb3ROb2RlKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBnZXRUZXh0KCk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS52YWx1ZTtcclxuICB9XHJcblxyXG4gIHNldFRleHQodGV4dDogc3RyaW5nKSB7XHJcbiAgICB0aGlzLmdldFRleHRFZGl0b3IoKS5zZXRUZXh0KHRleHQpO1xyXG4gIH1cclxuXHJcbiAgZ2V0VGV4dEVkaXRvcigpOiBUZXh0RWRpdG9yIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRleHRFZGl0b3JFbGVtZW50KCkuZ2V0TW9kZWwoKTtcclxuICB9XHJcblxyXG4gIG9uRGlkQ2hhbmdlKGNhbGxiYWNrOiAoKSA9PiBhbnkpOiBJRGlzcG9zYWJsZSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUZXh0RWRpdG9yKClcclxuICAgICAgLmdldEJ1ZmZlcigpXHJcbiAgICAgIC5vbkRpZENoYW5nZVRleHQoY2FsbGJhY2spO1xyXG4gIH1cclxuXHJcbiAgZ2V0VGV4dEVkaXRvckVsZW1lbnQoKTogYXRvbSRUZXh0RWRpdG9yRWxlbWVudCB7XHJcbiAgICBpbnZhcmlhbnQodGhpcy5fcm9vdE5vZGUgIT0gbnVsbCk7XHJcbiAgICAvLyAkRmxvd0ZpeE1lXHJcbiAgICByZXR1cm4gdGhpcy5fcm9vdE5vZGU7XHJcbiAgfVxyXG5cclxuICBfdXBkYXRlV2lkdGgocHJldldpZHRoPzogbnVtYmVyKTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5wcm9wcy53aWR0aCAhPT0gcHJldldpZHRoKSB7XHJcbiAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5wcm9wcy53aWR0aCA9PSBudWxsID8gdW5kZWZpbmVkIDogdGhpcy5wcm9wcy53aWR0aDtcclxuICAgICAgdGhpcy5nZXRUZXh0RWRpdG9yRWxlbWVudCgpLnNldFdpZHRoKHdpZHRoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZvY3VzKCk6IHZvaWQge1xyXG4gICAgdGhpcy5nZXRUZXh0RWRpdG9yKCkubW92ZVRvRW5kT2ZMaW5lKCk7XHJcbiAgICB0aGlzLmdldFRleHRFZGl0b3JFbGVtZW50KCkuZm9jdXMoKTtcclxuICB9XHJcbn1cclxuIl19