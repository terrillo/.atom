"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFilterPattern = getFilterPattern;
exports.default = void 0;

var _AtomInput = require("./AtomInput");

var _classnames = _interopRequireDefault(require("classnames"));

var _Button = require("./Button");

var _ButtonGroup = require("./ButtonGroup");

var _escapeStringRegexp = _interopRequireDefault(require("escape-string-regexp"));

var React = _interopRequireWildcard(require("react"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */
class RegExpFilter extends React.Component {
  constructor(props) {
    super(props);
    this._currentValue = void 0;
    this._input = void 0;

    this._handleReToggleButtonClick = () => {
      this.props.onChange({
        text: this._currentValue.text,
        isRegExp: !this._currentValue.isRegExp
      });
    };

    this._handleTextChange = text => {
      if (text === this._currentValue.text) {
        return;
      }

      this.props.onChange({
        text,
        isRegExp: this._currentValue.isRegExp
      });
    };

    this._currentValue = props.value;
  }

  UNSAFE_componentWillReceiveProps(props) {
    // We need to store this so that we can use it in the event handlers.
    this._currentValue = props.value;
  }

  render() {
    const {
      value: {
        text,
        isRegExp,
        invalid
      }
    } = this.props;
    const size = this.props.size || 'sm';
    const buttonSize = getButtonSize(size);
    const inputWidth = this.props.inputWidth == null ? 200 : this.props.inputWidth;
    const inputClassName = (0, _classnames.default)('nuclide-ui-regexp-filter-input', this.props.inputClassName);
    return /*#__PURE__*/React.createElement(_ButtonGroup.ButtonGroup, {
      className: "inline-block"
    }, /*#__PURE__*/React.createElement(_AtomInput.AtomInput, {
      ref: el => {
        this._input = el;
      },
      invalid: invalid,
      className: inputClassName,
      size: size,
      width: inputWidth,
      placeholderText: "Filter",
      onDidChange: this._handleTextChange,
      value: text
    }), /*#__PURE__*/React.createElement(_Button.Button, {
      className: "nuclide-ui-regexp-filter-button",
      size: buttonSize,
      selected: isRegExp,
      onClick: this._handleReToggleButtonClick,
      tooltip: {
        title: 'Use Regex'
      }
    }, ".*"));
  }

  focus() {
    if (this._input == null) {
      return;
    }

    this._input.focus();
  }

}

exports.default = RegExpFilter;

function getButtonSize(size) {
  switch (size) {
    case 'xs':
      return _Button.ButtonSizes.EXTRA_SMALL;

    case 'sm':
      return _Button.ButtonSizes.SMALL;

    case 'lg':
      return _Button.ButtonSizes.LARGE;

    default:
      size;
      throw new Error(`Invalid size: ${size}`);
  }
}

function getFilterPattern(text, isRegExp) {
  if (text === '') {
    return {
      pattern: null,
      invalid: false
    };
  }

  const source = isRegExp ? text : (0, _escapeStringRegexp.default)(text);

  try {
    return {
      pattern: new RegExp(source, 'i'),
      invalid: false
    };
  } catch (err) {
    return {
      pattern: null,
      invalid: true
    };
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zLXVpL1JlZ0V4cEZpbHRlci5qcyJdLCJuYW1lcyI6WyJSZWdFeHBGaWx0ZXIiLCJSZWFjdCIsIkNvbXBvbmVudCIsImNvbnN0cnVjdG9yIiwicHJvcHMiLCJfY3VycmVudFZhbHVlIiwiX2lucHV0IiwiX2hhbmRsZVJlVG9nZ2xlQnV0dG9uQ2xpY2siLCJvbkNoYW5nZSIsInRleHQiLCJpc1JlZ0V4cCIsIl9oYW5kbGVUZXh0Q2hhbmdlIiwidmFsdWUiLCJVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsInJlbmRlciIsImludmFsaWQiLCJzaXplIiwiYnV0dG9uU2l6ZSIsImdldEJ1dHRvblNpemUiLCJpbnB1dFdpZHRoIiwiaW5wdXRDbGFzc05hbWUiLCJlbCIsInRpdGxlIiwiZm9jdXMiLCJCdXR0b25TaXplcyIsIkVYVFJBX1NNQUxMIiwiU01BTEwiLCJMQVJHRSIsIkVycm9yIiwiZ2V0RmlsdGVyUGF0dGVybiIsInBhdHRlcm4iLCJzb3VyY2UiLCJSZWdFeHAiLCJlcnIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBY0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7O0FBbkJBOzs7Ozs7Ozs7OztBQXFEZSxNQUFNQSxZQUFOLFNBQTJCQyxLQUFLLENBQUNDLFNBQWpDLENBQXlEO0FBSXRFQyxFQUFBQSxXQUFXLENBQUNDLEtBQUQsRUFBZTtBQUN4QixVQUFNQSxLQUFOO0FBRHdCLFNBSDFCQyxhQUcwQjtBQUFBLFNBRjFCQyxNQUUwQjs7QUFBQSxTQXdEMUJDLDBCQXhEMEIsR0F3REcsTUFBWTtBQUN2QyxXQUFLSCxLQUFMLENBQVdJLFFBQVgsQ0FBb0I7QUFDbEJDLFFBQUFBLElBQUksRUFBRSxLQUFLSixhQUFMLENBQW1CSSxJQURQO0FBRWxCQyxRQUFBQSxRQUFRLEVBQUUsQ0FBQyxLQUFLTCxhQUFMLENBQW1CSztBQUZaLE9BQXBCO0FBSUQsS0E3RHlCOztBQUFB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QUFDRCxRQUFNZ0IsTUFBTSxHQUFHckIsUUFBUSxHQUFHRCxJQUFILEdBQVUsaUNBQW1CQSxJQUFuQixDQUFqQzs7QUFDQSxNQUFJO0FBQ0YsV0FBTztBQUNMcUIsTUFBQUEsT0FBTyxFQUFFLElBQUlFLE1BQUosQ0FBV0QsTUFBWCxFQUFtQixHQUFuQixDQURKO0FBRUxoQixNQUFBQSxPQUFPLEVBQUU7QUFGSixLQUFQO0FBSUQsR0FMRCxDQUtFLE9BQU9rQixHQUFQLEVBQVk7QUFDWixXQUFPO0FBQ0xILE1BQUFBLE9BQU8sRUFBRSxJQURKO0FBRUxmLE1BQUFBLE9BQU8sRUFBRTtBQUZKLEtBQVA7QUFJRDtBQUNGIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBAZmxvdyBzdHJpY3QtbG9jYWxcclxuICogQGZvcm1hdFxyXG4gKi9cclxuXHJcbmltcG9ydCB0eXBlIHtCdXR0b25TaXplfSBmcm9tICcuL0J1dHRvbic7XHJcblxyXG5pbXBvcnQge0F0b21JbnB1dH0gZnJvbSAnLi9BdG9tSW5wdXQnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuaW1wb3J0IHtCdXR0b24sIEJ1dHRvblNpemVzfSBmcm9tICcuL0J1dHRvbic7XHJcbmltcG9ydCB7QnV0dG9uR3JvdXB9IGZyb20gJy4vQnV0dG9uR3JvdXAnO1xyXG5pbXBvcnQgZXNjYXBlU3RyaW5nUmVnZXhwIGZyb20gJ2VzY2FwZS1zdHJpbmctcmVnZXhwJztcclxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5cclxudHlwZSBTaXplID0gJ3hzJyB8ICdzbScgfCAnbGcnO1xyXG5cclxudHlwZSBQcm9wcyA9IHtcclxuICB2YWx1ZTogUmVnRXhwRmlsdGVyVmFsdWUsXHJcbiAgaW5wdXRXaWR0aD86IG51bWJlcixcclxuICBpbnB1dENsYXNzTmFtZT86IHN0cmluZyxcclxuICBvbkNoYW5nZTogKHZhbHVlOiBSZWdFeHBGaWx0ZXJDaGFuZ2UpID0+IG1peGVkLFxyXG4gIHNpemU/OiBTaXplLFxyXG59O1xyXG5cclxudHlwZSBTdGF0ZSA9IHtcclxuICB0ZXh0OiBzdHJpbmcsXHJcbiAgaXNSZWdFeHA6IGJvb2xlYW4sXHJcbiAgaW52YWxpZDogYm9vbGVhbixcclxufTtcclxuXHJcbmV4cG9ydCB0eXBlIFJlZ0V4cEZpbHRlclZhbHVlID0ge1xyXG4gIHRleHQ6IHN0cmluZyxcclxuICBpc1JlZ0V4cDogYm9vbGVhbixcclxuICBpbnZhbGlkOiBib29sZWFuLFxyXG59O1xyXG5cclxuZXhwb3J0IHR5cGUgRmlsdGVyUGF0dGVybiA9IHtcclxuICBwYXR0ZXJuOiA/UmVnRXhwLFxyXG4gIGludmFsaWQ6IGJvb2xlYW4sXHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBSZWdFeHBGaWx0ZXJDaGFuZ2UgPSB7XHJcbiAgdGV4dDogc3RyaW5nLFxyXG4gIGlzUmVnRXhwOiBib29sZWFuLFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVnRXhwRmlsdGVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFByb3BzLCBTdGF0ZT4ge1xyXG4gIF9jdXJyZW50VmFsdWU6IFJlZ0V4cEZpbHRlclZhbHVlO1xyXG4gIF9pbnB1dDogP0F0b21JbnB1dDtcclxuXHJcbiAgY29uc3RydWN0b3IocHJvcHM6IFByb3BzKSB7XHJcbiAgICBzdXBlcihwcm9wcyk7XHJcbiAgICB0aGlzLl9jdXJyZW50VmFsdWUgPSBwcm9wcy52YWx1ZTtcclxuICB9XHJcblxyXG4gIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHByb3BzOiBQcm9wcyk6IHZvaWQge1xyXG4gICAgLy8gV2UgbmVlZCB0byBzdG9yZSB0aGlzIHNvIHRoYXQgd2UgY2FuIHVzZSBpdCBpbiB0aGUgZXZlbnQgaGFuZGxlcnMuXHJcbiAgICB0aGlzLl9jdXJyZW50VmFsdWUgPSBwcm9wcy52YWx1ZTtcclxuICB9XHJcblxyXG4gIHJlbmRlcigpOiBSZWFjdC5Ob2RlIHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgdmFsdWU6IHt0ZXh0LCBpc1JlZ0V4cCwgaW52YWxpZH0sXHJcbiAgICB9ID0gdGhpcy5wcm9wcztcclxuICAgIGNvbnN0IHNpemUgPSB0aGlzLnByb3BzLnNpemUgfHwgJ3NtJztcclxuICAgIGNvbnN0IGJ1dHRvblNpemUgPSBnZXRCdXR0b25TaXplKHNpemUpO1xyXG4gICAgY29uc3QgaW5wdXRXaWR0aCA9XHJcbiAgICAgIHRoaXMucHJvcHMuaW5wdXRXaWR0aCA9PSBudWxsID8gMjAwIDogdGhpcy5wcm9wcy5pbnB1dFdpZHRoO1xyXG4gICAgY29uc3QgaW5wdXRDbGFzc05hbWUgPSBjbGFzc25hbWVzKFxyXG4gICAgICAnbnVjbGlkZS11aS1yZWdleHAtZmlsdGVyLWlucHV0JyxcclxuICAgICAgdGhpcy5wcm9wcy5pbnB1dENsYXNzTmFtZSxcclxuICAgICk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgPEJ1dHRvbkdyb3VwIGNsYXNzTmFtZT1cImlubGluZS1ibG9ja1wiPlxyXG4gICAgICAgIDxBdG9tSW5wdXRcclxuICAgICAgICAgIHJlZj17ZWwgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9pbnB1dCA9IGVsO1xyXG4gICAgICAgICAgfX1cclxuICAgICAgICAgIGludmFsaWQ9e2ludmFsaWR9XHJcbiAgICAgICAgICBjbGFzc05hbWU9e2lucHV0Q2xhc3NOYW1lfVxyXG4gICAgICAgICAgc2l6ZT17c2l6ZX1cclxuICAgICAgICAgIHdpZHRoPXtpbnB1dFdpZHRofVxyXG4gICAgICAgICAgcGxhY2Vob2xkZXJUZXh0PVwiRmlsdGVyXCJcclxuICAgICAgICAgIG9uRGlkQ2hhbmdlPXt0aGlzLl9oYW5kbGVUZXh0Q2hhbmdlfVxyXG4gICAgICAgICAgdmFsdWU9e3RleHR9XHJcbiAgICAgICAgLz5cclxuICAgICAgICA8QnV0dG9uXHJcbiAgICAgICAgICBjbGFzc05hbWU9XCJudWNsaWRlLXVpLXJlZ2V4cC1maWx0ZXItYnV0dG9uXCJcclxuICAgICAgICAgIHNpemU9e2J1dHRvblNpemV9XHJcbiAgICAgICAgICBzZWxlY3RlZD17aXNSZWdFeHB9XHJcbiAgICAgICAgICBvbkNsaWNrPXt0aGlzLl9oYW5kbGVSZVRvZ2dsZUJ1dHRvbkNsaWNrfVxyXG4gICAgICAgICAgdG9vbHRpcD17e3RpdGxlOiAnVXNlIFJlZ2V4J319PlxyXG4gICAgICAgICAgLipcclxuICAgICAgICA8L0J1dHRvbj5cclxuICAgICAgPC9CdXR0b25Hcm91cD5cclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBmb2N1cygpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLl9pbnB1dCA9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMuX2lucHV0LmZvY3VzKCk7XHJcbiAgfVxyXG5cclxuICBfaGFuZGxlUmVUb2dnbGVCdXR0b25DbGljayA9ICgpOiB2b2lkID0+IHtcclxuICAgIHRoaXMucHJvcHMub25DaGFuZ2Uoe1xyXG4gICAgICB0ZXh0OiB0aGlzLl9jdXJyZW50VmFsdWUudGV4dCxcclxuICAgICAgaXNSZWdFeHA6ICF0aGlzLl9jdXJyZW50VmFsdWUuaXNSZWdFeHAsXHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICBfaGFuZGxlVGV4dENoYW5nZSA9ICh0ZXh0OiBzdHJpbmcpOiB2b2lkID0+IHtcclxuICAgIGlmICh0ZXh0ID09PSB0aGlzLl9jdXJyZW50VmFsdWUudGV4dCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHtcclxuICAgICAgdGV4dCxcclxuICAgICAgaXNSZWdFeHA6IHRoaXMuX2N1cnJlbnRWYWx1ZS5pc1JlZ0V4cCxcclxuICAgIH0pO1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEJ1dHRvblNpemUoc2l6ZTogU2l6ZSk6IEJ1dHRvblNpemUge1xyXG4gIHN3aXRjaCAoc2l6ZSkge1xyXG4gICAgY2FzZSAneHMnOlxyXG4gICAgICByZXR1cm4gQnV0dG9uU2l6ZXMuRVhUUkFfU01BTEw7XHJcbiAgICBjYXNlICdzbSc6XHJcbiAgICAgIHJldHVybiBCdXR0b25TaXplcy5TTUFMTDtcclxuICAgIGNhc2UgJ2xnJzpcclxuICAgICAgcmV0dXJuIEJ1dHRvblNpemVzLkxBUkdFO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgKHNpemU6IGVtcHR5KTtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNpemU6ICR7c2l6ZX1gKTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWx0ZXJQYXR0ZXJuKFxyXG4gIHRleHQ6IHN0cmluZyxcclxuICBpc1JlZ0V4cDogYm9vbGVhbixcclxuKTogRmlsdGVyUGF0dGVybiB7XHJcbiAgaWYgKHRleHQgPT09ICcnKSB7XHJcbiAgICByZXR1cm4ge3BhdHRlcm46IG51bGwsIGludmFsaWQ6IGZhbHNlfTtcclxuICB9XHJcbiAgY29uc3Qgc291cmNlID0gaXNSZWdFeHAgPyB0ZXh0IDogZXNjYXBlU3RyaW5nUmVnZXhwKHRleHQpO1xyXG4gIHRyeSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBwYXR0ZXJuOiBuZXcgUmVnRXhwKHNvdXJjZSwgJ2knKSxcclxuICAgICAgaW52YWxpZDogZmFsc2UsXHJcbiAgICB9O1xyXG4gIH0gY2F0Y2ggKGVycikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcGF0dGVybjogbnVsbCxcclxuICAgICAgaW52YWxpZDogdHJ1ZSxcclxuICAgIH07XHJcbiAgfVxyXG59XHJcbiJdfQ==