"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ResizeSensitiveContainer = void 0;

var React = _interopRequireWildcard(require("react"));

var _classnames = _interopRequireDefault(require("classnames"));

var _nullthrows = _interopRequireDefault(require("nullthrows"));

var _observable = require("@atom-ide-community/nuclide-commons/observable");

var _rxjsCompatUmdMin = require("rxjs-compat/bundles/rxjs-compat.umd.min.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */
const EXPANSION_BUFFER = 50;
/**
 * Hidden set of DOM nodes that are used to detect resizes through onScroll events.
 *
 * This component works by injecting two sets of divs, one for detecting expansions
 * and one for detecting shrinking. They are sized and have their scroll positions
 * set in a specific way so that a resize of the container will trigger an onScroll
 * event. This is used as the basis for the "onResize" event.
 *
 * The scroll position of the inner divs can be reset when DOM nodes are shuffled
 * around, which will break the resize detection. To handle this case, the sensor
 * uses a CSS animation and listens for onAnimationStart to know when to reset the
 * scroll positions.
 *
 * This strategy is derived from https://github.com/wnr/element-resize-detector
 */

class ResizeSensor extends React.Component {
  constructor(...args) {
    super(...args);
    this._expand = void 0;
    this._shrink = void 0;

    this._handleScroll = () => {
      this._resetScrollbars();

      this.props.onDetectedResize();
    };

    this._handleExpandRef = el => {
      this._expand = el;
    };

    this._handleShrinkRef = el => {
      this._shrink = el;
    };
  }

  componentDidMount() {
    this._resetScrollbars();
  }

  componentDidUpdate(prevProps) {
    const {
      targetWidth,
      targetHeight
    } = this.props;

    if (prevProps.targetWidth !== targetWidth || prevProps.targetHeight !== targetHeight) {
      this._resetScrollbars();
    }
  }

  _resetScrollbars() {
    if (this._expand == null || this._shrink == null) {
      return;
    }

    this._expand.scrollLeft = this._expand.scrollWidth;
    this._expand.scrollTop = this._expand.scrollHeight;
    this._shrink.scrollLeft = this._shrink.scrollWidth;
    this._shrink.scrollTop = this._shrink.scrollHeight;
  }

  render() {
    const {
      targetWidth,
      targetHeight
    } = this.props;
    const expandInnerStyle = {
      width: targetWidth + EXPANSION_BUFFER,
      height: targetHeight + EXPANSION_BUFFER
    };
    return /*#__PURE__*/React.createElement("div", {
      className: "nuclide-resize-sensitive-container-sensor",
      onAnimationStart: this._handleScroll
    }, /*#__PURE__*/React.createElement("div", {
      // $FlowFixMe(>=0.53.0) Flow suppress
      ref: this._handleExpandRef,
      className: "nuclide-resize-sensitive-container-expand",
      onScroll: this._handleScroll
    }, /*#__PURE__*/React.createElement("div", {
      className: "nuclide-resize-sensitive-container-expand-inner",
      style: expandInnerStyle
    })), /*#__PURE__*/React.createElement("div", {
      // $FlowFixMe(>=0.53.0) Flow suppress
      ref: this._handleShrinkRef,
      className: "nuclide-resize-sensitive-container-shrink",
      onScroll: this._handleScroll
    }, /*#__PURE__*/React.createElement("div", {
      className: "nuclide-resize-sensitive-container-shrink-inner"
    })));
  }

}

/**
 * Size-sensitive container that provides an onResize callback that
 * is invoked with the container's width and height whenever it changes.
 *
 * NOTE: This component is meant to be used to detect size changes that
 *       are not a result of a DOM mutation. If you only care about size
 *       changes as a result of a DOM mutation, use MeasuredComponent
 *       instead.
 */
class ResizeSensitiveContainer extends React.Component {
  constructor(props) {
    super(props);
    this._container = void 0;
    this._resizeEvents = new _rxjsCompatUmdMin.Subject();
    this._resizeSubscription = void 0;

    this._handleContainer = el => {
      this._container = el;

      this._updateContainerSize();
    };

    this._updateContainerSize = () => {
      if (this._container == null) {
        return;
      }

      const {
        offsetHeight,
        offsetWidth
      } = this._container;
      const {
        height,
        width
      } = this.state;

      if (offsetHeight === height && offsetWidth === width) {
        return;
      }

      this.setState({
        height: offsetHeight,
        width: offsetWidth
      });
      this.props.onResize(offsetHeight, offsetWidth);
    };

    this._handleResize = () => {
      this._resizeEvents.next();
    };

    this.state = {
      height: -1,
      width: -1
    };
  }

  componentDidMount() {
    this._resizeSubscription = this._resizeEvents.switchMap(() => _observable.nextAnimationFrame).subscribe(() => {
      this._updateContainerSize();
    });
  }

  componentWillUnmount() {
    (0, _nullthrows.default)(this._resizeSubscription).unsubscribe();
  }

  _containerRendered() {
    return this.state.height !== -1 && this.state.width !== -1;
  }

  render() {
    const {
      children,
      className,
      tabIndex
    } = this.props;
    const {
      height,
      width
    } = this.state;
    const containerClasses = (0, _classnames.default)('nuclide-resize-sensitive-container', className);
    return /*#__PURE__*/React.createElement("div", {
      className: "nuclide-resize-sensitive-container-wrapper"
    }, /*#__PURE__*/React.createElement("div", {
      ref: this._handleContainer,
      className: containerClasses,
      tabIndex: tabIndex
    }, children), this._containerRendered() ? /*#__PURE__*/React.createElement(ResizeSensor, {
      targetHeight: height,
      targetWidth: width,
      onDetectedResize: this._handleResize
    }) : null);
  }

}

exports.ResizeSensitiveContainer = ResizeSensitiveContainer;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zLXVpL1Jlc2l6ZVNlbnNpdGl2ZUNvbnRhaW5lci5qcyJdLCJuYW1lcyI6WyJFWFBBTlNJT05fQlVGRkVSIiwiUmVzaXplU2Vuc29yIiwiUmVhY3QiLCJDb21wb25lbnQiLCJfZXhwYW5kIiwiX3NocmluayIsIl9oYW5kbGVTY3JvbGwiLCJfcmVzZXRTY3JvbGxiYXJzIiwicHJvcHMiLCJvbkRldGVjdGVkUmVzaXplIiwiX2hhbmRsZUV4cGFuZFJlZiIsImVsIiwiX2hhbmRsZVNocmlua1JlZiIsImNvbXBvbmVudERpZE1vdW50IiwiY29tcG9uZW50RGlkVXBkYXRlIiwicHJldlByb3BzIiwidGFyZ2V0V2lkdGgiLCJ0YXJnZXRIZWlnaHQiLCJzY3JvbGxMZWZ0Iiwic2Nyb2xsV2lkdGgiLCJzY3JvbGxUb3AiLCJzY3JvbGxIZWlnaHQiLCJyZW5kZXIiLCJleHBhbmRJbm5lclN0eWxlIiwid2lkdGgiLCJoZWlnaHQiLCJSZXNpemVTZW5zaXRpdmVDb250YWluZXIiLCJjb25zdHJ1Y3RvciIsIl9jb250YWluZXIiLCJfcmVzaXplRXZlbnRzIiwiU3ViamVjdCIsIl9yZXNpemVTdWJzY3JpcHRpb24iLCJfaGFuZGxlQ29udGFpbmVyIiwiX3VwZGF0ZUNvbnRhaW5lclNpemUiLCJvZmZzZXRIZWlnaHQiLCJvZmZzZXRXaWR0aCIsInN0YXRlIiwic2V0U3RhdGUiLCJvblJlc2l6ZSIsIl9oYW5kbGVSZXNpemUiLCJuZXh0Iiwic3dpdGNoTWFwIiwibmV4dEFuaW1hdGlvbkZyYW1lIiwic3Vic2NyaWJlIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJ1bnN1YnNjcmliZSIsIl9jb250YWluZXJSZW5kZXJlZCIsImNoaWxkcmVuIiwiY2xhc3NOYW1lIiwidGFiSW5kZXgiLCJjb250YWluZXJDbGFzc2VzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBWUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7O0FBaEJB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S0FBS2IsbUJBQWhCLEVBQXFDYyxXQUFyQztBQUNEOztBQUVEQyxFQUFBQSxrQkFBa0IsR0FBWTtBQUM1QixXQUFPLEtBQUtWLEtBQUwsQ0FBV1gsTUFBWCxLQUFzQixDQUFDLENBQXZCLElBQTRCLEtBQUtXLEtBQUwsQ0FBV1osS0FBWCxLQUFxQixDQUFDLENBQXpEO0FBQ0Q7O0FBNkJERixFQUFBQSxNQUFNLEdBQWU7QUFDbkIsVUFBTTtBQUFDeUIsTUFBQUEsUUFBRDtBQUFXQyxNQUFBQSxTQUFYO0FBQXNCQyxNQUFBQTtBQUF0QixRQUFrQyxLQUFLekMsS0FBN0M7QUFDQSxVQUFNO0FBQUNpQixNQUFBQSxNQUFEO0FBQVNELE1BQUFBO0FBQVQsUUFBa0IsS0FBS1ksS0FBN0I7QUFDQSxVQUFNYyxnQkFBZ0IsR0FBRyx5QkFDdkIsb0NBRHVCLEVBRXZCRixTQUZ1QixDQUF6QjtBQUlBLHdCQUNFO0FBQUssTUFBQSxTQUFTLEVBQUM7QUFBZixvQkFDRTtBQUNFLE1BQUEsR0FBRyxFQUFFLEtBQUtoQixnQkFEWjtBQUVFLE1BQUEsU0FBUyxFQUFFa0IsZ0JBRmI7QUFHRSxNQUFBLFFBQVEsRUFBRUQ7QUFIWixPQUlHRixRQUpILENBREYsRUFPRyxLQUFLRCxrQkFBTCxrQkFDQyxvQkFBQyxZQUFEO0FBQ0UsTUFBQSxZQUFZLEVBQUVyQixNQURoQjtBQUVFLE1BQUEsV0FBVyxFQUFFRCxLQUZmO0FBR0UsTUFBQSxnQkFBZ0IsRUFBRSxLQUFLZTtBQUh6QixNQURELEdBTUcsSUFiTixDQURGO0FBaUJEOztBQWhGeUUiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIEBmbG93XHJcbiAqIEBmb3JtYXRcclxuICovXHJcblxyXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5pbXBvcnQgbnVsbHRocm93cyBmcm9tICdudWxsdGhyb3dzJztcclxuaW1wb3J0IHtuZXh0QW5pbWF0aW9uRnJhbWV9IGZyb20gJ0BhdG9tLWlkZS1jb21tdW5pdHkvbnVjbGlkZS1jb21tb25zL29ic2VydmFibGUnO1xyXG5pbXBvcnQge1N1YmplY3R9IGZyb20gJ3J4anMtY29tcGF0L2J1bmRsZXMvcnhqcy1jb21wYXQudW1kLm1pbi5qcyc7XHJcblxyXG50eXBlIFNlbnNvclByb3BzID0ge1xyXG4gIHRhcmdldEhlaWdodDogbnVtYmVyLFxyXG4gIHRhcmdldFdpZHRoOiBudW1iZXIsXHJcbiAgb25EZXRlY3RlZFJlc2l6ZTogKCkgPT4gdm9pZCxcclxufTtcclxuXHJcbmNvbnN0IEVYUEFOU0lPTl9CVUZGRVIgPSA1MDtcclxuXHJcbi8qKlxyXG4gKiBIaWRkZW4gc2V0IG9mIERPTSBub2RlcyB0aGF0IGFyZSB1c2VkIHRvIGRldGVjdCByZXNpemVzIHRocm91Z2ggb25TY3JvbGwgZXZlbnRzLlxyXG4gKlxyXG4gKiBUaGlzIGNvbXBvbmVudCB3b3JrcyBieSBpbmplY3RpbmcgdHdvIHNldHMgb2YgZGl2cywgb25lIGZvciBkZXRlY3RpbmcgZXhwYW5zaW9uc1xyXG4gKiBhbmQgb25lIGZvciBkZXRlY3Rpbmcgc2hyaW5raW5nLiBUaGV5IGFyZSBzaXplZCBhbmQgaGF2ZSB0aGVpciBzY3JvbGwgcG9zaXRpb25zXHJcbiAqIHNldCBpbiBhIHNwZWNpZmljIHdheSBzbyB0aGF0IGEgcmVzaXplIG9mIHRoZSBjb250YWluZXIgd2lsbCB0cmlnZ2VyIGFuIG9uU2Nyb2xsXHJcbiAqIGV2ZW50LiBUaGlzIGlzIHVzZWQgYXMgdGhlIGJhc2lzIGZvciB0aGUgXCJvblJlc2l6ZVwiIGV2ZW50LlxyXG4gKlxyXG4gKiBUaGUgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBpbm5lciBkaXZzIGNhbiBiZSByZXNldCB3aGVuIERPTSBub2RlcyBhcmUgc2h1ZmZsZWRcclxuICogYXJvdW5kLCB3aGljaCB3aWxsIGJyZWFrIHRoZSByZXNpemUgZGV0ZWN0aW9uLiBUbyBoYW5kbGUgdGhpcyBjYXNlLCB0aGUgc2Vuc29yXHJcbiAqIHVzZXMgYSBDU1MgYW5pbWF0aW9uIGFuZCBsaXN0ZW5zIGZvciBvbkFuaW1hdGlvblN0YXJ0IHRvIGtub3cgd2hlbiB0byByZXNldCB0aGVcclxuICogc2Nyb2xsIHBvc2l0aW9ucy5cclxuICpcclxuICogVGhpcyBzdHJhdGVneSBpcyBkZXJpdmVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3duci9lbGVtZW50LXJlc2l6ZS1kZXRlY3RvclxyXG4gKi9cclxuY2xhc3MgUmVzaXplU2Vuc29yIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFNlbnNvclByb3BzPiB7XHJcbiAgX2V4cGFuZDogP0hUTUxFbGVtZW50O1xyXG4gIF9zaHJpbms6ID9IVE1MRWxlbWVudDtcclxuXHJcbiAgY29tcG9uZW50RGlkTW91bnQoKTogdm9pZCB7XHJcbiAgICB0aGlzLl9yZXNldFNjcm9sbGJhcnMoKTtcclxuICB9XHJcblxyXG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHM6IFNlbnNvclByb3BzKTogdm9pZCB7XHJcbiAgICBjb25zdCB7dGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodH0gPSB0aGlzLnByb3BzO1xyXG4gICAgaWYgKFxyXG4gICAgICBwcmV2UHJvcHMudGFyZ2V0V2lkdGggIT09IHRhcmdldFdpZHRoIHx8XHJcbiAgICAgIHByZXZQcm9wcy50YXJnZXRIZWlnaHQgIT09IHRhcmdldEhlaWdodFxyXG4gICAgKSB7XHJcbiAgICAgIHRoaXMuX3Jlc2V0U2Nyb2xsYmFycygpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX3Jlc2V0U2Nyb2xsYmFycygpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLl9leHBhbmQgPT0gbnVsbCB8fCB0aGlzLl9zaHJpbmsgPT0gbnVsbCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fZXhwYW5kLnNjcm9sbExlZnQgPSB0aGlzLl9leHBhbmQuc2Nyb2xsV2lkdGg7XHJcbiAgICB0aGlzLl9leHBhbmQuc2Nyb2xsVG9wID0gdGhpcy5fZXhwYW5kLnNjcm9sbEhlaWdodDtcclxuXHJcbiAgICB0aGlzLl9zaHJpbmsuc2Nyb2xsTGVmdCA9IHRoaXMuX3Nocmluay5zY3JvbGxXaWR0aDtcclxuICAgIHRoaXMuX3Nocmluay5zY3JvbGxUb3AgPSB0aGlzLl9zaHJpbmsuc2Nyb2xsSGVpZ2h0O1xyXG4gIH1cclxuXHJcbiAgX2hhbmRsZVNjcm9sbCA9ICgpOiB2b2lkID0+IHtcclxuICAgIHRoaXMuX3Jlc2V0U2Nyb2xsYmFycygpO1xyXG4gICAgdGhpcy5wcm9wcy5vbkRldGVjdGVkUmVzaXplKCk7XHJcbiAgfTtcclxuXHJcbiAgX2hhbmRsZUV4cGFuZFJlZiA9IChlbDogSFRNTEVsZW1lbnQpOiB2b2lkID0+IHtcclxuICAgIHRoaXMuX2V4cGFuZCA9IGVsO1xyXG4gIH07XHJcblxyXG4gIF9oYW5kbGVTaHJpbmtSZWYgPSAoZWw6IEhUTUxFbGVtZW50KTogdm9pZCA9PiB7XHJcbiAgICB0aGlzLl9zaHJpbmsgPSBlbDtcclxuICB9O1xyXG5cclxuICByZW5kZXIoKTogUmVhY3QuTm9kZSB7XHJcbiAgICBjb25zdCB7dGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodH0gPSB0aGlzLnByb3BzO1xyXG4gICAgY29uc3QgZXhwYW5kSW5uZXJTdHlsZSA9IHtcclxuICAgICAgd2lkdGg6IHRhcmdldFdpZHRoICsgRVhQQU5TSU9OX0JVRkZFUixcclxuICAgICAgaGVpZ2h0OiB0YXJnZXRIZWlnaHQgKyBFWFBBTlNJT05fQlVGRkVSLFxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICA8ZGl2XHJcbiAgICAgICAgY2xhc3NOYW1lPVwibnVjbGlkZS1yZXNpemUtc2Vuc2l0aXZlLWNvbnRhaW5lci1zZW5zb3JcIlxyXG4gICAgICAgIG9uQW5pbWF0aW9uU3RhcnQ9e3RoaXMuX2hhbmRsZVNjcm9sbH0+XHJcbiAgICAgICAgPGRpdlxyXG4gICAgICAgICAgLy8gJEZsb3dGaXhNZSg+PTAuNTMuMCkgRmxvdyBzdXBwcmVzc1xyXG4gICAgICAgICAgcmVmPXt0aGlzLl9oYW5kbGVFeHBhbmRSZWZ9XHJcbiAgICAgICAgICBjbGFzc05hbWU9XCJudWNsaWRlLXJlc2l6ZS1zZW5zaXRpdmUtY29udGFpbmVyLWV4cGFuZFwiXHJcbiAgICAgICAgICBvblNjcm9sbD17dGhpcy5faGFuZGxlU2Nyb2xsfT5cclxuICAgICAgICAgIDxkaXZcclxuICAgICAgICAgICAgY2xhc3NOYW1lPVwibnVjbGlkZS1yZXNpemUtc2Vuc2l0aXZlLWNvbnRhaW5lci1leHBhbmQtaW5uZXJcIlxyXG4gICAgICAgICAgICBzdHlsZT17ZXhwYW5kSW5uZXJTdHlsZX1cclxuICAgICAgICAgIC8+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPGRpdlxyXG4gICAgICAgICAgLy8gJEZsb3dGaXhNZSg+PTAuNTMuMCkgRmxvdyBzdXBwcmVzc1xyXG4gICAgICAgICAgcmVmPXt0aGlzLl9oYW5kbGVTaHJpbmtSZWZ9XHJcbiAgICAgICAgICBjbGFzc05hbWU9XCJudWNsaWRlLXJlc2l6ZS1zZW5zaXRpdmUtY29udGFpbmVyLXNocmlua1wiXHJcbiAgICAgICAgICBvblNjcm9sbD17dGhpcy5faGFuZGxlU2Nyb2xsfT5cclxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibnVjbGlkZS1yZXNpemUtc2Vuc2l0aXZlLWNvbnRhaW5lci1zaHJpbmstaW5uZXJcIiAvPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICA8L2Rpdj5cclxuICAgICk7XHJcbiAgfVxyXG59XHJcblxyXG50eXBlIFByb3BzID0ge1xyXG4gIGNsYXNzTmFtZT86IHN0cmluZyxcclxuICB0YWJJbmRleD86IHN0cmluZyxcclxuICBjaGlsZHJlbj86IFJlYWN0LkVsZW1lbnQ8YW55PixcclxuICBvblJlc2l6ZTogKGhlaWdodDogbnVtYmVyLCB3aWR0aDogbnVtYmVyKSA9PiB2b2lkLFxyXG59O1xyXG5cclxudHlwZSBTdGF0ZSA9IHtcclxuICBoZWlnaHQ6IG51bWJlcixcclxuICB3aWR0aDogbnVtYmVyLFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNpemUtc2Vuc2l0aXZlIGNvbnRhaW5lciB0aGF0IHByb3ZpZGVzIGFuIG9uUmVzaXplIGNhbGxiYWNrIHRoYXRcclxuICogaXMgaW52b2tlZCB3aXRoIHRoZSBjb250YWluZXIncyB3aWR0aCBhbmQgaGVpZ2h0IHdoZW5ldmVyIGl0IGNoYW5nZXMuXHJcbiAqXHJcbiAqIE5PVEU6IFRoaXMgY29tcG9uZW50IGlzIG1lYW50IHRvIGJlIHVzZWQgdG8gZGV0ZWN0IHNpemUgY2hhbmdlcyB0aGF0XHJcbiAqICAgICAgIGFyZSBub3QgYSByZXN1bHQgb2YgYSBET00gbXV0YXRpb24uIElmIHlvdSBvbmx5IGNhcmUgYWJvdXQgc2l6ZVxyXG4gKiAgICAgICBjaGFuZ2VzIGFzIGEgcmVzdWx0IG9mIGEgRE9NIG11dGF0aW9uLCB1c2UgTWVhc3VyZWRDb21wb25lbnRcclxuICogICAgICAgaW5zdGVhZC5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBSZXNpemVTZW5zaXRpdmVDb250YWluZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8UHJvcHMsIFN0YXRlPiB7XHJcbiAgX2NvbnRhaW5lcjogP0hUTUxFbGVtZW50O1xyXG4gIF9yZXNpemVFdmVudHM6IFN1YmplY3Q8dm9pZD4gPSBuZXcgU3ViamVjdCgpO1xyXG4gIF9yZXNpemVTdWJzY3JpcHRpb246ID9yeGpzJFN1YnNjcmlwdGlvbjtcclxuXHJcbiAgY29uc3RydWN0b3IocHJvcHM6IFByb3BzKSB7XHJcbiAgICBzdXBlcihwcm9wcyk7XHJcbiAgICB0aGlzLnN0YXRlID0ge1xyXG4gICAgICBoZWlnaHQ6IC0xLFxyXG4gICAgICB3aWR0aDogLTEsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgY29tcG9uZW50RGlkTW91bnQoKTogdm9pZCB7XHJcbiAgICB0aGlzLl9yZXNpemVTdWJzY3JpcHRpb24gPSB0aGlzLl9yZXNpemVFdmVudHNcclxuICAgICAgLnN3aXRjaE1hcCgoKSA9PiBuZXh0QW5pbWF0aW9uRnJhbWUpXHJcbiAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZUNvbnRhaW5lclNpemUoKTtcclxuICAgICAgfSk7XHJcbiAgfVxyXG5cclxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpOiB2b2lkIHtcclxuICAgIG51bGx0aHJvd3ModGhpcy5fcmVzaXplU3Vic2NyaXB0aW9uKS51bnN1YnNjcmliZSgpO1xyXG4gIH1cclxuXHJcbiAgX2NvbnRhaW5lclJlbmRlcmVkKCk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuaGVpZ2h0ICE9PSAtMSAmJiB0aGlzLnN0YXRlLndpZHRoICE9PSAtMTtcclxuICB9XHJcblxyXG4gIF9oYW5kbGVDb250YWluZXIgPSAoZWw6ID9IVE1MRWxlbWVudCk6IHZvaWQgPT4ge1xyXG4gICAgdGhpcy5fY29udGFpbmVyID0gZWw7XHJcbiAgICB0aGlzLl91cGRhdGVDb250YWluZXJTaXplKCk7XHJcbiAgfTtcclxuXHJcbiAgX3VwZGF0ZUNvbnRhaW5lclNpemUgPSAoKTogdm9pZCA9PiB7XHJcbiAgICBpZiAodGhpcy5fY29udGFpbmVyID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHtvZmZzZXRIZWlnaHQsIG9mZnNldFdpZHRofSA9IHRoaXMuX2NvbnRhaW5lcjtcclxuICAgIGNvbnN0IHtoZWlnaHQsIHdpZHRofSA9IHRoaXMuc3RhdGU7XHJcbiAgICBpZiAob2Zmc2V0SGVpZ2h0ID09PSBoZWlnaHQgJiYgb2Zmc2V0V2lkdGggPT09IHdpZHRoKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnNldFN0YXRlKHtcclxuICAgICAgaGVpZ2h0OiBvZmZzZXRIZWlnaHQsXHJcbiAgICAgIHdpZHRoOiBvZmZzZXRXaWR0aCxcclxuICAgIH0pO1xyXG4gICAgdGhpcy5wcm9wcy5vblJlc2l6ZShvZmZzZXRIZWlnaHQsIG9mZnNldFdpZHRoKTtcclxuICB9O1xyXG5cclxuICBfaGFuZGxlUmVzaXplID0gKCk6IHZvaWQgPT4ge1xyXG4gICAgdGhpcy5fcmVzaXplRXZlbnRzLm5leHQoKTtcclxuICB9O1xyXG5cclxuICByZW5kZXIoKTogUmVhY3QuTm9kZSB7XHJcbiAgICBjb25zdCB7Y2hpbGRyZW4sIGNsYXNzTmFtZSwgdGFiSW5kZXh9ID0gdGhpcy5wcm9wcztcclxuICAgIGNvbnN0IHtoZWlnaHQsIHdpZHRofSA9IHRoaXMuc3RhdGU7XHJcbiAgICBjb25zdCBjb250YWluZXJDbGFzc2VzID0gY2xhc3NuYW1lcyhcclxuICAgICAgJ251Y2xpZGUtcmVzaXplLXNlbnNpdGl2ZS1jb250YWluZXInLFxyXG4gICAgICBjbGFzc05hbWUsXHJcbiAgICApO1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJudWNsaWRlLXJlc2l6ZS1zZW5zaXRpdmUtY29udGFpbmVyLXdyYXBwZXJcIj5cclxuICAgICAgICA8ZGl2XHJcbiAgICAgICAgICByZWY9e3RoaXMuX2hhbmRsZUNvbnRhaW5lcn1cclxuICAgICAgICAgIGNsYXNzTmFtZT17Y29udGFpbmVyQ2xhc3Nlc31cclxuICAgICAgICAgIHRhYkluZGV4PXt0YWJJbmRleH0+XHJcbiAgICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAge3RoaXMuX2NvbnRhaW5lclJlbmRlcmVkKCkgPyAoXHJcbiAgICAgICAgICA8UmVzaXplU2Vuc29yXHJcbiAgICAgICAgICAgIHRhcmdldEhlaWdodD17aGVpZ2h0fVxyXG4gICAgICAgICAgICB0YXJnZXRXaWR0aD17d2lkdGh9XHJcbiAgICAgICAgICAgIG9uRGV0ZWN0ZWRSZXNpemU9e3RoaXMuX2hhbmRsZVJlc2l6ZX1cclxuICAgICAgICAgIC8+XHJcbiAgICAgICAgKSA6IG51bGx9XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuIl19