"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tree = void 0;

var _collection = require("@atom-ide-community/nuclide-commons/collection");

var _UniversalDisposable = _interopRequireDefault(require("@atom-ide-community/nuclide-commons/UniversalDisposable"));

var React = _interopRequireWildcard(require("react"));

var _classnames = _interopRequireDefault(require("classnames"));

var _assert = _interopRequireDefault(require("assert"));

var _rxjsCompatUmdMin = require("rxjs-compat/bundles/rxjs-compat.umd.min.js");

var _shallowequal = _interopRequireDefault(require("shallowequal"));

var _nullthrows = _interopRequireDefault(require("nullthrows"));

var _scrollIntoView = require("./scrollIntoView");

var _Tree = require("./Tree");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */

/* eslint-env browser */
class Tree extends React.Component {
  constructor(...args) {
    super(...args);
    this._rootNode = void 0;
    this._subscriptions = void 0;
    this.state = {
      isFocused: false,
      focusedPath: null
    };

    this._selectNext = () => {
      let nextNodePath;

      if (this.state.focusedPath == null) {
        nextNodePath = [0];
      } else {
        nextNodePath = getNextNodePath(this.props.items, this.state.focusedPath, this.props.collapsedPaths);
      }

      if (nextNodePath != null) {
        this.props.onSelect(nextNodePath);
        this.setState({
          focusedPath: nextNodePath
        });
      }
    };

    this._selectPrev = () => {
      let prevNodePath;

      if (this.state.focusedPath == null) {
        prevNodePath = [0];
      } else {
        prevNodePath = getPrevNodePath(this.props.items, this.state.focusedPath, this.props.collapsedPaths);
      }

      if (prevNodePath != null) {
        this.props.onSelect(prevNodePath);
      }
    };

    this._collapseNodeViaKeyboard = e => {
      if (this.state.focusedPath == null) {
        return;
      }

      let collapsablePath = [...this.state.focusedPath];
      let collapsableNode = selectNodeAtPath(this.props.items, collapsablePath);

      while (collapsableNode != null && collapsableNode.type !== 'NESTED') {
        collapsablePath = collapsablePath.slice(0, collapsablePath.length - 1);
        collapsableNode = selectNodeAtPath(this.props.items, collapsablePath);
      }

      if (collapsableNode == null) {
        return;
      }

      this.props.onCollapse(collapsablePath); // if a descendant of this node was selected when this node was collapsed,
      // moving selection to this node seems like intuitive behavior (see Chrome's
      // Elements tree)

      this.props.onSelect(collapsablePath);
    };

    this._expandNodeViaKeyboard = e => {
      const {
        focusedPath
      } = this.state;

      if (focusedPath == null) {
        return;
      }

      const focusedNode = selectNodeAtPath(this.props.items, focusedPath);

      if (focusedNode != null && focusedNode.type === 'NESTED') {
        this.props.onExpand(focusedPath);
      }
    };

    this._handleSelect = path => {
      this.props.onSelect(path);
    };

    this._handleConfirm = path => {
      this.props.onConfirm(path);
    };
  }

  componentDidMount() {
    const rootNode = (0, _nullthrows.default)(this._rootNode);
    this._subscriptions = new _UniversalDisposable.default(atom.commands.add(rootNode, {
      'core:move-up': this._selectPrev,
      'core:move-down': this._selectNext,
      'core:move-left': this._collapseNodeViaKeyboard,
      'core:move-right': this._expandNodeViaKeyboard,
      'core:confirm': () => this.state.focusedPath && this._handleConfirm(this.state.focusedPath)
    }), _rxjsCompatUmdMin.Observable.merge(_rxjsCompatUmdMin.Observable.fromEvent(rootNode, 'focusin').mapTo(true), _rxjsCompatUmdMin.Observable.fromEvent(rootNode, 'focusout').mapTo(false)).subscribe(isFocused => this.setState({
      isFocused
    })));
  }

  componentWillUnmount() {
    this._subscriptions.dispose();
  }

  UNSAFE_componentWillReceiveProps() {
    this.setState((state, props) => ({
      focusedPath: props.selectedPaths[props.selectedPaths.length - 1]
    }));
  }

  render() {
    const {
      className,
      collapsedPaths,
      itemClassName,
      items: nodes,
      selectedPaths
    } = this.props;
    const {
      focusedPath,
      isFocused
    } = this.state;
    return /*#__PURE__*/React.createElement("ol", {
      className: (0, _classnames.default)('list-tree', 'nuclide-selectable-tree', 'has-collapsable-children', className, {
        focused: isFocused
      }),
      ref: node => this._rootNode = node,
      role: "tree",
      style: {
        position: 'relative'
      },
      tabIndex: "0"
    }, nodes.map((node, i) => /*#__PURE__*/React.createElement(AbstractTreeItem, {
      key: i,
      node: node,
      path: [i],
      focusedPath: focusedPath,
      collapsedPaths: collapsedPaths,
      selectedPaths: selectedPaths,
      className: itemClassName,
      onSelect: this._handleSelect,
      onConfirm: this._handleConfirm,
      onTripleClick: this.props.onTripleClick,
      onCollapse: this.props.onCollapse,
      onExpand: this.props.onExpand
    })));
  }

}

exports.Tree = Tree;

function AbstractTreeItem({
  className,
  collapsedPaths,
  focusedPath,
  onConfirm,
  onSelect,
  onTripleClick,
  onCollapse,
  onExpand,
  node,
  path,
  selectedPaths
}) {
  if (node.hidden) {
    return null;
  }

  if (node.type === 'LEAF') {
    return (
      /*#__PURE__*/
      // $FlowIgnore
      React.createElement(TreeItem, {
        className: className,
        isFocused: focusedPath && (0, _collection.arrayEqual)(focusedPath, path),
        onConfirm: onConfirm,
        onSelect: onSelect,
        onTripleClick: onTripleClick,
        path: path,
        selectedPaths: selectedPaths
      }, node.label)
    );
  }

  const hasFlatChildren = node.children.every(child => child.type === 'LEAF');
  return (
    /*#__PURE__*/
    // $FlowIgnore
    React.createElement(NestedTreeItem, {
      className: className,
      collapsed: false,
      hasFlatChildren: hasFlatChildren,
      focusedPath: focusedPath,
      onConfirm: onConfirm,
      onSelect: onSelect,
      onTripleClick: onTripleClick,
      onCollapse: onCollapse,
      onExpand: onExpand,
      path: path,
      collapsedPaths: collapsedPaths,
      selectedPaths: selectedPaths,
      label: node.label
    }, node.children.map((child, i) => {
      const childPath = path.concat([i]);
      return /*#__PURE__*/React.createElement(AbstractTreeItem, {
        className: className,
        collapsedPaths: collapsedPaths,
        focusedPath: focusedPath,
        key: childPath.join('.'),
        node: child,
        onConfirm: onConfirm,
        onSelect: onSelect,
        onTripleClick: onTripleClick,
        onCollapse: onCollapse,
        onExpand: onExpand,
        path: childPath,
        selectedPaths: selectedPaths
      });
    }))
  );
}

class TreeItem extends React.Component {
  constructor(...args) {
    super(...args);
    this._liNode = void 0;

    this._handleClick = e => {
      const {
        onSelect,
        onConfirm,
        onTripleClick
      } = this.props;
      const numberOfClicks = e.detail;

      switch (numberOfClicks) {
        case 1:
          onSelect && onSelect(this.props.path);
          break;

        case 2:
          onConfirm && onConfirm(this.props.path);
          break;

        case 3:
          onTripleClick && onTripleClick(this.props.path);
          break;

        default:
          break;
      }
    };
  }

  scrollIntoView() {
    if (this._liNode != null) {
      (0, _scrollIntoView.scrollIntoView)(this._liNode);
    }
  }

  render() {
    const {
      className,
      isFocused,
      path,
      selectedPaths,
      children
    } = this.props;
    const isSelected = selectedPaths.some(selectedPath => (0, _shallowequal.default)(path, selectedPath));

    if (isSelected) {
      process.nextTick(() => {
        // We *are* using `scrollIntoView()` instead of the raw DOM API
        // eslint-disable-next-line nuclide-internal/dom-apis
        this.scrollIntoView();
      });
    }

    return /*#__PURE__*/React.createElement("li", {
      "aria-activedescendant": isFocused,
      "aria-selected": isSelected,
      className: (0, _classnames.default)('list-item', className, {
        selected: isSelected
      }),
      onClick: this._handleClick,
      ref: liNode => this._liNode = liNode,
      role: "treeitem"
    }, isSelected && typeof children === 'string' ?
    /*#__PURE__*/
    // String children must be wrapped to receive correct styles when selected.
    React.createElement("span", null, children) : children);
  }

}

class NestedTreeItem extends React.Component {
  constructor(...args) {
    super(...args);
    this._itemNode = void 0;
    this._subscriptions = void 0;

    this._handleClick = e => {
      const itemNode = this._itemNode;

      if (itemNode == null) {
        return;
      }

      (0, _assert.default)(e.target instanceof Element);

      if (e.target.closest('.list-item') !== itemNode) {
        // this was a click on a descendant node in the inner list
        return;
      } // TODO: This is gross. It assumes that the expand chevron is present in the
      // `before` pseudoelement (as is with most themes), and measures the space
      // it occupies using computed style properties, not actual measurements.
      // The toggle chevron should be reimplemented as a true dom node instead,
      // bypassing themes. Though this is more visually consistent, it's probably
      // not worth the hassle.


      const beforeStyle = window.getComputedStyle(this._itemNode, ':before');
      const itemStyle = window.getComputedStyle(this._itemNode);
      const chevronWidth = parsePx(itemStyle.paddingLeft) + parsePx(beforeStyle.paddingLeft) + parsePx(beforeStyle.paddingRight) + parsePx(beforeStyle.marginLeft) + parsePx(beforeStyle.marginRight) + parsePx(beforeStyle.width) + parsePx(beforeStyle.left);
      const {
        path,
        collapsedPaths
      } = this.props;
      (0, _assert.default)(e.nativeEvent instanceof MouseEvent);

      if (e.nativeEvent.offsetX <= chevronWidth) {
        if (collapsedPaths.some(collapsedPath => (0, _collection.arrayEqual)(path, collapsedPath))) {
          this.props.onExpand(path);
        } else {
          this.props.onCollapse(path);
        }

        return;
      }

      const {
        onSelect,
        onConfirm,
        onTripleClick
      } = this.props;
      const numberOfClicks = e.detail;

      if (numberOfClicks === 1 && onSelect != null) {
        onSelect(path);
      } else if (numberOfClicks === 2 && onConfirm != null) {
        onConfirm(path);
      } else if (numberOfClicks === 3 && onTripleClick != null) {
        onTripleClick(path);
      }
    };
  }

  render() {
    const {
      className,
      hasFlatChildren,
      focusedPath,
      selectedPaths,
      collapsedPaths,
      path,
      label,
      children
    } = this.props;
    const isFocused = focusedPath && (0, _collection.arrayEqual)(path, focusedPath);
    const isSelected = selectedPaths.some(selectedPath => (0, _shallowequal.default)(path, selectedPath));
    const isCollapsed = collapsedPaths.some(collapsedPath => (0, _shallowequal.default)(path, collapsedPath));
    return /*#__PURE__*/React.createElement("li", {
      "aria-activedescendant": isFocused,
      "aria-selected": isSelected,
      "aria-expanded": !isCollapsed,
      className: (0, _classnames.default)('list-nested-item', className, {
        collapsed: isCollapsed,
        selected: isSelected
      }),
      onClick: this._handleClick,
      role: "treeitem"
    }, label == null ? null : /*#__PURE__*/React.createElement("div", {
      className: "list-item",
      ref: node => this._itemNode = node
    }, label), /*#__PURE__*/React.createElement(_Tree.TreeList, {
      hasFlatChildren: hasFlatChildren
    }, children));
  }

}

function selectNodeAtPath(roots, path) {
  if (path.length === 0) {
    return;
  }

  let node = roots[path[0]];

  for (let i = 1; i < path.length; i++) {
    (0, _assert.default)(node.type === 'NESTED');
    node = node.children[path[i]];
  }

  return node;
}

function getNextNodePath(roots, path, collapsedPaths) {
  if (path.length === 0) {
    return null;
  }

  const currentNode = selectNodeAtPath(roots, path);

  if (currentNode == null) {
    return;
  }

  if (currentNode.type === 'NESTED' && currentNode.children.length > 0 && // don't traverse children of collapsed nodes
  !collapsedPaths.find(collapsedPath => (0, _collection.arrayEqual)(collapsedPath, path))) {
    // 'down' was pressed on a nested item. most of the time we want go to its
    // first child, but we need to make sure it's not hidden (eg filtered by
    // a search) first
    const firstVisibleChildIndex = currentNode.children.findIndex(n => !n.hidden);

    if (firstVisibleChildIndex >= 0) {
      return path.concat([firstVisibleChildIndex]);
    }
  }

  return findNextSibling(roots, path, collapsedPaths);
}

function findNextSibling(roots, path, collapsedPaths) {
  if (path.length === 0) {
    return null;
  }

  const leadingIndexes = path.slice(0, path.length - 1);
  const tailIndex = path[path.length - 1];
  const nextSiblingPath = [...leadingIndexes, tailIndex + 1];
  const nextSibling = selectNodeAtPath(roots, nextSiblingPath);

  if (nextSibling != null) {
    if (nextSibling.hidden) {
      // skip over next hidden nodes by finding *their* next sibling
      return findNextSibling(roots, nextSiblingPath, collapsedPaths);
    }

    return nextSiblingPath;
  } // there's no next sibling. let's navigate to this node's parent's siblings


  return findNextSibling(roots, leadingIndexes, collapsedPaths);
}

function getPrevNodePath(roots, path, collapsedPaths) {
  if (path.length === 0) {
    return null;
  }

  const leadingIndexes = path.slice(0, path.length - 1);
  const tailIndex = path[path.length - 1];
  const prevSiblingPath = [...leadingIndexes, tailIndex - 1];
  const prevSibling = selectNodeAtPath(roots, prevSiblingPath);

  if (prevSibling != null) {
    if (prevSibling.hidden) {
      return getPrevNodePath(roots, prevSiblingPath, collapsedPaths);
    }

    if (prevSibling.type === 'NESTED' && prevSibling.children.length > 0 && // don't traverse children of collapsed nodes
    !collapsedPaths.find(collapsedPath => (0, _collection.arrayEqual)(collapsedPath, prevSiblingPath))) {
      // pressed 'up' on a node just after an expanded nested item. Normally this
      // should take us to the last item inside the expanded node, but some may
      // be hidden. Find the last in the list that's visible.
      const lastVisibleChildIndex = (0, _collection.arrayFindLastIndex)(prevSibling.children, n => !n.hidden);

      if (lastVisibleChildIndex >= 0) {
        return prevSiblingPath.concat([lastVisibleChildIndex]);
      }
    }

    return prevSiblingPath;
  } // return the parent if it's a valid path


  if (leadingIndexes.length > 0) {
    return leadingIndexes;
  }
}

function parsePx(px) {
  return px.length === 0 ? 0 : Number(px.replace('px', ''));
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zLXVpL1NlbGVjdGFibGVUcmVlLmpzIl0sIm5hbWVzIjpbIlRyZWUiLCJSZWFjdCIsIkNvbXBvbmVudCIsIl9yb290Tm9kZSIsIl9zdWJzY3JpcHRpb25zIiwic3RhdGUiLCJpc0ZvY3VzZWQiLCJmb2N1c2VkUGF0aCIsIl9zZWxlY3ROZXh0IiwibmV4dE5vZGVQYXRoIiwiZ2V0TmV4dE5vZGVQYXRoIiwicHJvcHMiLCJpdGVtcyIsImNvbGxhcHNlZFBhdGhzIiwib25TZWxlY3QiLCJzZXRTdGF0ZSIsIl9zZWxlY3RQcmV2IiwicHJldk5vZGVQYXRoIiwiZ2V0UHJldk5vZGVQYXRoIiwiX2NvbGxhcHNlTm9kZVZpYUtleWJvYXJkIiwiZSIsImNvbGxhcHNhYmxlUGF0aCIsImNvbGxhcHNhYmxlTm9kZSIsInNlbGVjdE5vZGVBdFBhdGgiLCJ0eXBlIiwic2xpY2UiLCJsZW5ndGgiLCJvbkNvbGxhcHNlIiwiX2V4cGFuZE5vZGVWaWFLZXlib2FyZCIsImZvY3VzZWROb2RlIiwib25FeHBhbmQiLCJfaGFuZGxlU2VsZWN0IiwicGF0aCIsIl9oYW5kbGVDb25maXJtIiwib25Db25maXJtIiwiY29tcG9uZW50RGlkTW91bnQiLCJyb290Tm9kZSIsIlVuaXZlcnNhbERpc3Bvc2FibGUiLCJhdG9tIiwiY29tbWFuZHMiLCJhZGQiLCJPYnNlcnZhYmxlIiwibWVyZ2UiLCJmcm9tRXZlbnQiLCJtYXBUbyIsInN1YnNjcmliZSIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwiZGlzcG9zZSIsIlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwic2VsZWN0ZWRQYXRocyIsInJlbmRlciIsImNsYXNzTmFtZSIsIml0ZW1DbGFzc05hbWUiLCJub2RlcyIsImZvY3VzZWQiLCJub2RlIiwicG9zaXRpb24iLCJtYXAiLCJpIiwib25UcmlwbGVDbGljayIsIkFic3RyYWN0VHJlZUl0ZW0iLCJoaWRkZW4iLCJsYWJlbCIsImhhc0ZsYXRDaGlsZHJlbiIsImNoaWxkcmVuIiwiZXZlcnkiLCJjaGlsZCIsImNoaWxkUGF0aCIsImNvbmNhdCIsImpvaW4iLCJUcmVlSXRlbSIsIl9saU5vZGUiLCJfaGFuZGxlQ2xpY2siLCJudW1iZXJPZkNsaWNrcyIsImRldGFpbCIsInNjcm9sbEludG9WaWV3IiwiaXNTZWxlY3RlZCIsInNvbWUiLCJzZWxlY3RlZFBhdGgiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJzZWxlY3RlZCIsImxpTm9kZSIsIk5lc3RlZFRyZWVJdGVtIiwiX2l0ZW1Ob2RlIiwiaXRlbU5vZGUiLCJ0YXJnZXQiLCJFbGVtZW50IiwiY2xvc2VzdCIsImJlZm9yZVN0eWxlIiwid2luZG93IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsIml0ZW1TdHlsZSIsImNoZXZyb25XaWR0aCIsInBhcnNlUHgiLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdSaWdodCIsIm1hcmdpbkxlZnQiLCJtYXJnaW5SaWdodCIsIndpZHRoIiwibGVmdCIsIm5hdGl2ZUV2ZW50IiwiTW91c2VFdmVudCIsIm9mZnNldFgiLCJjb2xsYXBzZWRQYXRoIiwiaXNDb2xsYXBzZWQiLCJjb2xsYXBzZWQiLCJyb290cyIsImN1cnJlbnROb2RlIiwiZmluZCIsImZpcnN0VmlzaWJsZUNoaWxkSW5kZXgiLCJmaW5kSW5kZXgiLCJuIiwiZmluZE5leHRTaWJsaW5nIiwibGVhZGluZ0luZGV4ZXMiLCJ0YWlsSW5kZXgiLCJuZXh0U2libGluZ1BhdGgiLCJuZXh0U2libGluZyIsInByZXZTaWJsaW5nUGF0aCIsInByZXZTaWJsaW5nIiwibGFzdFZpc2libGVDaGlsZEluZGV4IiwicHgiLCJOdW1iZXIiLCJyZXBsYWNlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBY0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7O0FBdkJBOzs7Ozs7Ozs7Ozs7QUFZQTtBQStDTyxNQUFNQSxJQUFOLFNBQW1CQyxLQUFLLENBQUNDLFNB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ZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIEBmbG93XHJcbiAqIEBmb3JtYXRcclxuICovXHJcblxyXG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cclxuXHJcbmltcG9ydCB7YXJyYXlFcXVhbCwgYXJyYXlGaW5kTGFzdEluZGV4fSBmcm9tICdAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtY29tbW9ucy9jb2xsZWN0aW9uJztcclxuaW1wb3J0IFVuaXZlcnNhbERpc3Bvc2FibGUgZnJvbSAnQGF0b20taWRlLWNvbW11bml0eS9udWNsaWRlLWNvbW1vbnMvVW5pdmVyc2FsRGlzcG9zYWJsZSc7XHJcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnYXNzZXJ0JztcclxuaW1wb3J0IHtPYnNlcnZhYmxlfSBmcm9tICdyeGpzLWNvbXBhdC9idW5kbGVzL3J4anMtY29tcGF0LnVtZC5taW4uanMnO1xyXG5pbXBvcnQgc2hhbGxvd0VxdWFsIGZyb20gJ3NoYWxsb3dlcXVhbCc7XHJcbmltcG9ydCBudWxsdGhyb3dzIGZyb20gJ251bGx0aHJvd3MnO1xyXG5pbXBvcnQge3Njcm9sbEludG9WaWV3fSBmcm9tICcuL3Njcm9sbEludG9WaWV3JztcclxuaW1wb3J0IHtUcmVlTGlzdH0gZnJvbSAnLi9UcmVlJztcclxuXHJcbmV4cG9ydCB0eXBlIE5vZGVQYXRoID0gQXJyYXk8bnVtYmVyPjtcclxuZXhwb3J0IHR5cGUgVHJlZU5vZGUgPSBUcmVlTGVhZk5vZGUgfCBUcmVlTmVzdGVkTm9kZTtcclxuXHJcbnR5cGUgVHJlZUxlYWZOb2RlID0ge3xcclxuICB0eXBlOiAnTEVBRicsXHJcbiAgbGFiZWw6IFJlYWN0Lk5vZGUsXHJcbiAgaGlkZGVuPzogYm9vbGVhbixcclxufH07XHJcblxyXG50eXBlIFRyZWVOZXN0ZWROb2RlID0ge3xcclxuICB0eXBlOiAnTkVTVEVEJyxcclxuICBjaGlsZHJlbjogQXJyYXk8VHJlZU5vZGU+LFxyXG4gIGxhYmVsOiBSZWFjdC5Ob2RlLFxyXG4gIGhpZGRlbj86IGJvb2xlYW4sXHJcbnx9O1xyXG5cclxudHlwZSBUcmVlUHJvcHMgPSB7fFxyXG4gIGNsYXNzTmFtZT86IHN0cmluZyxcclxuICBpdGVtQ2xhc3NOYW1lPzogc3RyaW5nLFxyXG4gIGl0ZW1zOiBBcnJheTxUcmVlTm9kZT4sXHJcbiAgb25TZWxlY3Q6IChwYXRoOiBOb2RlUGF0aCkgPT4gbWl4ZWQsXHJcbiAgb25Db25maXJtOiAocGF0aDogTm9kZVBhdGgpID0+IG1peGVkLFxyXG4gIG9uVHJpcGxlQ2xpY2s6IChwYXRoOiBOb2RlUGF0aCkgPT4gbWl4ZWQsXHJcbiAgc2VsZWN0ZWRQYXRoczogQXJyYXk8Tm9kZVBhdGg+LFxyXG4gIGNvbGxhcHNlZFBhdGhzOiBBcnJheTxOb2RlUGF0aD4sXHJcbiAgb25Db2xsYXBzZTogKHBhdGg6IE5vZGVQYXRoKSA9PiBtaXhlZCxcclxuICBvbkV4cGFuZDogKHBhdGg6IE5vZGVQYXRoKSA9PiBtaXhlZCxcclxufH07XHJcblxyXG50eXBlIFRyZWVTdGF0ZSA9IHt8XHJcbiAgZm9jdXNlZFBhdGg6ID9Ob2RlUGF0aCxcclxuICBpc0ZvY3VzZWQ6IGJvb2xlYW4sXHJcbnx9O1xyXG5cclxuZXhwb3J0IGNsYXNzIFRyZWUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8VHJlZVByb3BzLCBUcmVlU3RhdGU+IHtcclxuICBfcm9vdE5vZGU6ID9IVE1MT0xpc3RFbGVtZW50O1xyXG4gIF9zdWJzY3JpcHRpb25zOiBVbml2ZXJzYWxEaXNwb3NhYmxlO1xyXG4gIHN0YXRlID0ge1xyXG4gICAgaXNGb2N1c2VkOiBmYWxzZSxcclxuICAgIGZvY3VzZWRQYXRoOiBudWxsLFxyXG4gIH07XHJcblxyXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xyXG4gICAgY29uc3Qgcm9vdE5vZGUgPSBudWxsdGhyb3dzKHRoaXMuX3Jvb3ROb2RlKTtcclxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMgPSBuZXcgVW5pdmVyc2FsRGlzcG9zYWJsZShcclxuICAgICAgYXRvbS5jb21tYW5kcy5hZGQocm9vdE5vZGUsIHtcclxuICAgICAgICAnY29yZTptb3ZlLXVwJzogdGhpcy5fc2VsZWN0UHJldixcclxuICAgICAgICAnY29yZTptb3ZlLWRvd24nOiB0aGlzLl9zZWxlY3ROZXh0LFxyXG4gICAgICAgICdjb3JlOm1vdmUtbGVmdCc6IHRoaXMuX2NvbGxhcHNlTm9kZVZpYUtleWJvYXJkLFxyXG4gICAgICAgICdjb3JlOm1vdmUtcmlnaHQnOiB0aGlzLl9leHBhbmROb2RlVmlhS2V5Ym9hcmQsXHJcbiAgICAgICAgJ2NvcmU6Y29uZmlybSc6ICgpID0+XHJcbiAgICAgICAgICB0aGlzLnN0YXRlLmZvY3VzZWRQYXRoICYmIHRoaXMuX2hhbmRsZUNvbmZpcm0odGhpcy5zdGF0ZS5mb2N1c2VkUGF0aCksXHJcbiAgICAgIH0pLFxyXG4gICAgICBPYnNlcnZhYmxlLm1lcmdlKFxyXG4gICAgICAgIE9ic2VydmFibGUuZnJvbUV2ZW50KHJvb3ROb2RlLCAnZm9jdXNpbicpLm1hcFRvKHRydWUpLFxyXG4gICAgICAgIE9ic2VydmFibGUuZnJvbUV2ZW50KHJvb3ROb2RlLCAnZm9jdXNvdXQnKS5tYXBUbyhmYWxzZSksXHJcbiAgICAgICkuc3Vic2NyaWJlKGlzRm9jdXNlZCA9PiB0aGlzLnNldFN0YXRlKHtpc0ZvY3VzZWR9KSksXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XHJcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zLmRpc3Bvc2UoKTtcclxuICB9XHJcblxyXG4gIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCkge1xyXG4gICAgdGhpcy5zZXRTdGF0ZSgoc3RhdGUsIHByb3BzKSA9PiAoe1xyXG4gICAgICBmb2N1c2VkUGF0aDogcHJvcHMuc2VsZWN0ZWRQYXRoc1twcm9wcy5zZWxlY3RlZFBhdGhzLmxlbmd0aCAtIDFdLFxyXG4gICAgfSkpO1xyXG4gIH1cclxuXHJcbiAgX3NlbGVjdE5leHQgPSAoKSA9PiB7XHJcbiAgICBsZXQgbmV4dE5vZGVQYXRoO1xyXG4gICAgaWYgKHRoaXMuc3RhdGUuZm9jdXNlZFBhdGggPT0gbnVsbCkge1xyXG4gICAgICBuZXh0Tm9kZVBhdGggPSBbMF07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBuZXh0Tm9kZVBhdGggPSBnZXROZXh0Tm9kZVBhdGgoXHJcbiAgICAgICAgdGhpcy5wcm9wcy5pdGVtcyxcclxuICAgICAgICB0aGlzLnN0YXRlLmZvY3VzZWRQYXRoLFxyXG4gICAgICAgIHRoaXMucHJvcHMuY29sbGFwc2VkUGF0aHMsXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICBpZiAobmV4dE5vZGVQYXRoICE9IG51bGwpIHtcclxuICAgICAgdGhpcy5wcm9wcy5vblNlbGVjdChuZXh0Tm9kZVBhdGgpO1xyXG4gICAgICB0aGlzLnNldFN0YXRlKHtmb2N1c2VkUGF0aDogbmV4dE5vZGVQYXRofSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgX3NlbGVjdFByZXYgPSAoKSA9PiB7XHJcbiAgICBsZXQgcHJldk5vZGVQYXRoO1xyXG4gICAgaWYgKHRoaXMuc3RhdGUuZm9jdXNlZFBhdGggPT0gbnVsbCkge1xyXG4gICAgICBwcmV2Tm9kZVBhdGggPSBbMF07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBwcmV2Tm9kZVBhdGggPSBnZXRQcmV2Tm9kZVBhdGgoXHJcbiAgICAgICAgdGhpcy5wcm9wcy5pdGVtcyxcclxuICAgICAgICB0aGlzLnN0YXRlLmZvY3VzZWRQYXRoLFxyXG4gICAgICAgIHRoaXMucHJvcHMuY29sbGFwc2VkUGF0aHMsXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICBpZiAocHJldk5vZGVQYXRoICE9IG51bGwpIHtcclxuICAgICAgdGhpcy5wcm9wcy5vblNlbGVjdChwcmV2Tm9kZVBhdGgpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIF9jb2xsYXBzZU5vZGVWaWFLZXlib2FyZCA9IChlOiBhdG9tJEN1c3RvbUV2ZW50KSA9PiB7XHJcbiAgICBpZiAodGhpcy5zdGF0ZS5mb2N1c2VkUGF0aCA9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgY29sbGFwc2FibGVQYXRoID0gWy4uLnRoaXMuc3RhdGUuZm9jdXNlZFBhdGhdO1xyXG4gICAgbGV0IGNvbGxhcHNhYmxlTm9kZSA9IHNlbGVjdE5vZGVBdFBhdGgodGhpcy5wcm9wcy5pdGVtcywgY29sbGFwc2FibGVQYXRoKTtcclxuICAgIHdoaWxlIChjb2xsYXBzYWJsZU5vZGUgIT0gbnVsbCAmJiBjb2xsYXBzYWJsZU5vZGUudHlwZSAhPT0gJ05FU1RFRCcpIHtcclxuICAgICAgY29sbGFwc2FibGVQYXRoID0gY29sbGFwc2FibGVQYXRoLnNsaWNlKDAsIGNvbGxhcHNhYmxlUGF0aC5sZW5ndGggLSAxKTtcclxuICAgICAgY29sbGFwc2FibGVOb2RlID0gc2VsZWN0Tm9kZUF0UGF0aCh0aGlzLnByb3BzLml0ZW1zLCBjb2xsYXBzYWJsZVBhdGgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjb2xsYXBzYWJsZU5vZGUgPT0gbnVsbCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5wcm9wcy5vbkNvbGxhcHNlKGNvbGxhcHNhYmxlUGF0aCk7XHJcbiAgICAvLyBpZiBhIGRlc2NlbmRhbnQgb2YgdGhpcyBub2RlIHdhcyBzZWxlY3RlZCB3aGVuIHRoaXMgbm9kZSB3YXMgY29sbGFwc2VkLFxyXG4gICAgLy8gbW92aW5nIHNlbGVjdGlvbiB0byB0aGlzIG5vZGUgc2VlbXMgbGlrZSBpbnR1aXRpdmUgYmVoYXZpb3IgKHNlZSBDaHJvbWUnc1xyXG4gICAgLy8gRWxlbWVudHMgdHJlZSlcclxuICAgIHRoaXMucHJvcHMub25TZWxlY3QoY29sbGFwc2FibGVQYXRoKTtcclxuICB9O1xyXG5cclxuICBfZXhwYW5kTm9kZVZpYUtleWJvYXJkID0gKGU6IGF0b20kQ3VzdG9tRXZlbnQpID0+IHtcclxuICAgIGNvbnN0IHtmb2N1c2VkUGF0aH0gPSB0aGlzLnN0YXRlO1xyXG4gICAgaWYgKGZvY3VzZWRQYXRoID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGZvY3VzZWROb2RlID0gc2VsZWN0Tm9kZUF0UGF0aCh0aGlzLnByb3BzLml0ZW1zLCBmb2N1c2VkUGF0aCk7XHJcbiAgICBpZiAoZm9jdXNlZE5vZGUgIT0gbnVsbCAmJiBmb2N1c2VkTm9kZS50eXBlID09PSAnTkVTVEVEJykge1xyXG4gICAgICB0aGlzLnByb3BzLm9uRXhwYW5kKGZvY3VzZWRQYXRoKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBfaGFuZGxlU2VsZWN0ID0gKHBhdGg6IE5vZGVQYXRoKSA9PiB7XHJcbiAgICB0aGlzLnByb3BzLm9uU2VsZWN0KHBhdGgpO1xyXG4gIH07XHJcblxyXG4gIF9oYW5kbGVDb25maXJtID0gKHBhdGg6IE5vZGVQYXRoKSA9PiB7XHJcbiAgICB0aGlzLnByb3BzLm9uQ29uZmlybShwYXRoKTtcclxuICB9O1xyXG5cclxuICByZW5kZXIoKSB7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgIGNsYXNzTmFtZSxcclxuICAgICAgY29sbGFwc2VkUGF0aHMsXHJcbiAgICAgIGl0ZW1DbGFzc05hbWUsXHJcbiAgICAgIGl0ZW1zOiBub2RlcyxcclxuICAgICAgc2VsZWN0ZWRQYXRocyxcclxuICAgIH0gPSB0aGlzLnByb3BzO1xyXG4gICAgY29uc3Qge2ZvY3VzZWRQYXRoLCBpc0ZvY3VzZWR9ID0gdGhpcy5zdGF0ZTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICA8b2xcclxuICAgICAgICBjbGFzc05hbWU9e2NsYXNzbmFtZXMoXHJcbiAgICAgICAgICAnbGlzdC10cmVlJyxcclxuICAgICAgICAgICdudWNsaWRlLXNlbGVjdGFibGUtdHJlZScsXHJcbiAgICAgICAgICAnaGFzLWNvbGxhcHNhYmxlLWNoaWxkcmVuJyxcclxuICAgICAgICAgIGNsYXNzTmFtZSxcclxuICAgICAgICAgIHtmb2N1c2VkOiBpc0ZvY3VzZWR9LFxyXG4gICAgICAgICl9XHJcbiAgICAgICAgcmVmPXtub2RlID0+ICh0aGlzLl9yb290Tm9kZSA9IG5vZGUpfVxyXG4gICAgICAgIHJvbGU9XCJ0cmVlXCJcclxuICAgICAgICBzdHlsZT17e3Bvc2l0aW9uOiAncmVsYXRpdmUnfX1cclxuICAgICAgICB0YWJJbmRleD1cIjBcIj5cclxuICAgICAgICB7bm9kZXMubWFwKChub2RlLCBpKSA9PiAoXHJcbiAgICAgICAgICA8QWJzdHJhY3RUcmVlSXRlbVxyXG4gICAgICAgICAgICBrZXk9e2l9XHJcbiAgICAgICAgICAgIG5vZGU9e25vZGV9XHJcbiAgICAgICAgICAgIHBhdGg9e1tpXX1cclxuICAgICAgICAgICAgZm9jdXNlZFBhdGg9e2ZvY3VzZWRQYXRofVxyXG4gICAgICAgICAgICBjb2xsYXBzZWRQYXRocz17Y29sbGFwc2VkUGF0aHN9XHJcbiAgICAgICAgICAgIHNlbGVjdGVkUGF0aHM9e3NlbGVjdGVkUGF0aHN9XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZT17aXRlbUNsYXNzTmFtZX1cclxuICAgICAgICAgICAgb25TZWxlY3Q9e3RoaXMuX2hhbmRsZVNlbGVjdH1cclxuICAgICAgICAgICAgb25Db25maXJtPXt0aGlzLl9oYW5kbGVDb25maXJtfVxyXG4gICAgICAgICAgICBvblRyaXBsZUNsaWNrPXt0aGlzLnByb3BzLm9uVHJpcGxlQ2xpY2t9XHJcbiAgICAgICAgICAgIG9uQ29sbGFwc2U9e3RoaXMucHJvcHMub25Db2xsYXBzZX1cclxuICAgICAgICAgICAgb25FeHBhbmQ9e3RoaXMucHJvcHMub25FeHBhbmR9XHJcbiAgICAgICAgICAvPlxyXG4gICAgICAgICkpfVxyXG4gICAgICA8L29sPlxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEFic3RyYWN0VHJlZUl0ZW0oe1xyXG4gIGNsYXNzTmFtZSxcclxuICBjb2xsYXBzZWRQYXRocyxcclxuICBmb2N1c2VkUGF0aCxcclxuICBvbkNvbmZpcm0sXHJcbiAgb25TZWxlY3QsXHJcbiAgb25UcmlwbGVDbGljayxcclxuICBvbkNvbGxhcHNlLFxyXG4gIG9uRXhwYW5kLFxyXG4gIG5vZGUsXHJcbiAgcGF0aCxcclxuICBzZWxlY3RlZFBhdGhzLFxyXG59OiB7XHJcbiAgY2xhc3NOYW1lOiA/c3RyaW5nLFxyXG4gIGNvbGxhcHNlZFBhdGhzOiBBcnJheTxOb2RlUGF0aD4sXHJcbiAgZm9jdXNlZFBhdGg6ID9Ob2RlUGF0aCxcclxuICBvbkNvbmZpcm06IChwYXRoOiBOb2RlUGF0aCkgPT4gbWl4ZWQsXHJcbiAgb25TZWxlY3Q6IChwYXRoOiBOb2RlUGF0aCkgPT4gbWl4ZWQsXHJcbiAgb25UcmlwbGVDbGljazogKHBhdGg6IE5vZGVQYXRoKSA9PiBtaXhlZCxcclxuICBvbkNvbGxhcHNlOiAocGF0aDogTm9kZVBhdGgpID0+IG1peGVkLFxyXG4gIG9uRXhwYW5kOiAocGF0aDogTm9kZVBhdGgpID0+IG1peGVkLFxyXG4gIG5vZGU6IFRyZWVOb2RlLFxyXG4gIHBhdGg6IE5vZGVQYXRoLFxyXG4gIHNlbGVjdGVkUGF0aHM6IEFycmF5PE5vZGVQYXRoPixcclxufSk6IFJlYWN0Lk5vZGUge1xyXG4gIGlmIChub2RlLmhpZGRlbikge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICBpZiAobm9kZS50eXBlID09PSAnTEVBRicpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIC8vICRGbG93SWdub3JlXHJcbiAgICAgIDxUcmVlSXRlbVxyXG4gICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lfVxyXG4gICAgICAgIGlzRm9jdXNlZD17Zm9jdXNlZFBhdGggJiYgYXJyYXlFcXVhbChmb2N1c2VkUGF0aCwgcGF0aCl9XHJcbiAgICAgICAgb25Db25maXJtPXtvbkNvbmZpcm19XHJcbiAgICAgICAgb25TZWxlY3Q9e29uU2VsZWN0fVxyXG4gICAgICAgIG9uVHJpcGxlQ2xpY2s9e29uVHJpcGxlQ2xpY2t9XHJcbiAgICAgICAgcGF0aD17cGF0aH1cclxuICAgICAgICBzZWxlY3RlZFBhdGhzPXtzZWxlY3RlZFBhdGhzfT5cclxuICAgICAgICB7bm9kZS5sYWJlbH1cclxuICAgICAgPC9UcmVlSXRlbT5cclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBoYXNGbGF0Q2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLmV2ZXJ5KGNoaWxkID0+IGNoaWxkLnR5cGUgPT09ICdMRUFGJyk7XHJcbiAgcmV0dXJuIChcclxuICAgIC8vICRGbG93SWdub3JlXHJcbiAgICA8TmVzdGVkVHJlZUl0ZW1cclxuICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWV9XHJcbiAgICAgIGNvbGxhcHNlZD17ZmFsc2V9XHJcbiAgICAgIGhhc0ZsYXRDaGlsZHJlbj17aGFzRmxhdENoaWxkcmVufVxyXG4gICAgICBmb2N1c2VkUGF0aD17Zm9jdXNlZFBhdGh9XHJcbiAgICAgIG9uQ29uZmlybT17b25Db25maXJtfVxyXG4gICAgICBvblNlbGVjdD17b25TZWxlY3R9XHJcbiAgICAgIG9uVHJpcGxlQ2xpY2s9e29uVHJpcGxlQ2xpY2t9XHJcbiAgICAgIG9uQ29sbGFwc2U9e29uQ29sbGFwc2V9XHJcbiAgICAgIG9uRXhwYW5kPXtvbkV4cGFuZH1cclxuICAgICAgcGF0aD17cGF0aH1cclxuICAgICAgY29sbGFwc2VkUGF0aHM9e2NvbGxhcHNlZFBhdGhzfVxyXG4gICAgICBzZWxlY3RlZFBhdGhzPXtzZWxlY3RlZFBhdGhzfVxyXG4gICAgICBsYWJlbD17bm9kZS5sYWJlbH0+XHJcbiAgICAgIHtub2RlLmNoaWxkcmVuLm1hcCgoY2hpbGQsIGkpID0+IHtcclxuICAgICAgICBjb25zdCBjaGlsZFBhdGggPSBwYXRoLmNvbmNhdChbaV0pO1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICA8QWJzdHJhY3RUcmVlSXRlbVxyXG4gICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZX1cclxuICAgICAgICAgICAgY29sbGFwc2VkUGF0aHM9e2NvbGxhcHNlZFBhdGhzfVxyXG4gICAgICAgICAgICBmb2N1c2VkUGF0aD17Zm9jdXNlZFBhdGh9XHJcbiAgICAgICAgICAgIGtleT17Y2hpbGRQYXRoLmpvaW4oJy4nKX1cclxuICAgICAgICAgICAgbm9kZT17Y2hpbGR9XHJcbiAgICAgICAgICAgIG9uQ29uZmlybT17b25Db25maXJtfVxyXG4gICAgICAgICAgICBvblNlbGVjdD17b25TZWxlY3R9XHJcbiAgICAgICAgICAgIG9uVHJpcGxlQ2xpY2s9e29uVHJpcGxlQ2xpY2t9XHJcbiAgICAgICAgICAgIG9uQ29sbGFwc2U9e29uQ29sbGFwc2V9XHJcbiAgICAgICAgICAgIG9uRXhwYW5kPXtvbkV4cGFuZH1cclxuICAgICAgICAgICAgcGF0aD17Y2hpbGRQYXRofVxyXG4gICAgICAgICAgICBzZWxlY3RlZFBhdGhzPXtzZWxlY3RlZFBhdGhzfVxyXG4gICAgICAgICAgLz5cclxuICAgICAgICApO1xyXG4gICAgICB9KX1cclxuICAgIDwvTmVzdGVkVHJlZUl0ZW0+XHJcbiAgKTtcclxufVxyXG5cclxudHlwZSBUcmVlSXRlbVByb3BzID0ge3xcclxuICBjaGlsZHJlbj86IFJlYWN0Lk5vZGUsXHJcbiAgY2xhc3NOYW1lPzogP3N0cmluZyxcclxuICBpc0ZvY3VzZWQ6IGJvb2xlYW4sXHJcbiAgb25TZWxlY3Q6IChwYXRoOiBOb2RlUGF0aCkgPT4gbWl4ZWQsXHJcbiAgb25Db25maXJtOiAocGF0aDogTm9kZVBhdGgpID0+IG1peGVkLFxyXG4gIG9uVHJpcGxlQ2xpY2s6IChwYXRoOiBOb2RlUGF0aCkgPT4gbWl4ZWQsXHJcbiAgcGF0aDogTm9kZVBhdGgsXHJcbiAgc2VsZWN0ZWRQYXRoczogQXJyYXk8Tm9kZVBhdGg+LFxyXG58fTtcclxuXHJcbmNsYXNzIFRyZWVJdGVtIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFRyZWVJdGVtUHJvcHM+IHtcclxuICBfbGlOb2RlOiA/SFRNTExJRWxlbWVudDtcclxuICBfaGFuZGxlQ2xpY2sgPSAoZTogU3ludGhldGljTW91c2VFdmVudDw+KSA9PiB7XHJcbiAgICBjb25zdCB7b25TZWxlY3QsIG9uQ29uZmlybSwgb25UcmlwbGVDbGlja30gPSB0aGlzLnByb3BzO1xyXG5cclxuICAgIGNvbnN0IG51bWJlck9mQ2xpY2tzID0gZS5kZXRhaWw7XHJcbiAgICBzd2l0Y2ggKG51bWJlck9mQ2xpY2tzKSB7XHJcbiAgICAgIGNhc2UgMTpcclxuICAgICAgICBvblNlbGVjdCAmJiBvblNlbGVjdCh0aGlzLnByb3BzLnBhdGgpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDI6XHJcbiAgICAgICAgb25Db25maXJtICYmIG9uQ29uZmlybSh0aGlzLnByb3BzLnBhdGgpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDM6XHJcbiAgICAgICAgb25UcmlwbGVDbGljayAmJiBvblRyaXBsZUNsaWNrKHRoaXMucHJvcHMucGF0aCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgc2Nyb2xsSW50b1ZpZXcoKSB7XHJcbiAgICBpZiAodGhpcy5fbGlOb2RlICE9IG51bGwpIHtcclxuICAgICAgc2Nyb2xsSW50b1ZpZXcodGhpcy5fbGlOb2RlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJlbmRlcigpIHtcclxuICAgIGNvbnN0IHtjbGFzc05hbWUsIGlzRm9jdXNlZCwgcGF0aCwgc2VsZWN0ZWRQYXRocywgY2hpbGRyZW59ID0gdGhpcy5wcm9wcztcclxuICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSBzZWxlY3RlZFBhdGhzLnNvbWUoc2VsZWN0ZWRQYXRoID0+XHJcbiAgICAgIHNoYWxsb3dFcXVhbChwYXRoLCBzZWxlY3RlZFBhdGgpLFxyXG4gICAgKTtcclxuICAgIGlmIChpc1NlbGVjdGVkKSB7XHJcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xyXG4gICAgICAgIC8vIFdlICphcmUqIHVzaW5nIGBzY3JvbGxJbnRvVmlldygpYCBpbnN0ZWFkIG9mIHRoZSByYXcgRE9NIEFQSVxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBudWNsaWRlLWludGVybmFsL2RvbS1hcGlzXHJcbiAgICAgICAgdGhpcy5zY3JvbGxJbnRvVmlldygpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiAoXHJcbiAgICAgIDxsaVxyXG4gICAgICAgIGFyaWEtYWN0aXZlZGVzY2VuZGFudD17aXNGb2N1c2VkfVxyXG4gICAgICAgIGFyaWEtc2VsZWN0ZWQ9e2lzU2VsZWN0ZWR9XHJcbiAgICAgICAgY2xhc3NOYW1lPXtjbGFzc25hbWVzKCdsaXN0LWl0ZW0nLCBjbGFzc05hbWUsIHtcclxuICAgICAgICAgIHNlbGVjdGVkOiBpc1NlbGVjdGVkLFxyXG4gICAgICAgIH0pfVxyXG4gICAgICAgIG9uQ2xpY2s9e3RoaXMuX2hhbmRsZUNsaWNrfVxyXG4gICAgICAgIHJlZj17bGlOb2RlID0+ICh0aGlzLl9saU5vZGUgPSBsaU5vZGUpfVxyXG4gICAgICAgIHJvbGU9XCJ0cmVlaXRlbVwiPlxyXG4gICAgICAgIHtpc1NlbGVjdGVkICYmIHR5cGVvZiBjaGlsZHJlbiA9PT0gJ3N0cmluZycgPyAoXHJcbiAgICAgICAgICAvLyBTdHJpbmcgY2hpbGRyZW4gbXVzdCBiZSB3cmFwcGVkIHRvIHJlY2VpdmUgY29ycmVjdCBzdHlsZXMgd2hlbiBzZWxlY3RlZC5cclxuICAgICAgICAgIDxzcGFuPntjaGlsZHJlbn08L3NwYW4+XHJcbiAgICAgICAgKSA6IChcclxuICAgICAgICAgIGNoaWxkcmVuXHJcbiAgICAgICAgKX1cclxuICAgICAgPC9saT5cclxuICAgICk7XHJcbiAgfVxyXG59XHJcblxyXG50eXBlIE5lc3RlZFRyZWVJdGVtUHJvcHMgPSB7XHJcbiAgbGFiZWw/OiBSZWFjdC5Ob2RlLFxyXG4gIGNoaWxkcmVuPzogUmVhY3QuTm9kZSxcclxuICBjbGFzc05hbWU/OiA/c3RyaW5nLFxyXG4gIGhhc0ZsYXRDaGlsZHJlbj86IGJvb2xlYW4sIC8vIHBhc3N0aHJvdWdoIHRvIGlubmVyIFRyZWVMaXN0XHJcbiAgZm9jdXNlZFBhdGg6IE5vZGVQYXRoLFxyXG4gIG9uU2VsZWN0OiAocGF0aDogTm9kZVBhdGgpID0+IG1peGVkLFxyXG4gIG9uQ29uZmlybTogKHBhdGg6IE5vZGVQYXRoKSA9PiBtaXhlZCxcclxuICBvblRyaXBsZUNsaWNrOiAocGF0aDogTm9kZVBhdGgpID0+IG1peGVkLFxyXG4gIG9uQ29sbGFwc2U6IChwYXRoOiBOb2RlUGF0aCkgPT4gbWl4ZWQsXHJcbiAgb25FeHBhbmQ6IChwYXRoOiBOb2RlUGF0aCkgPT4gbWl4ZWQsXHJcbiAgcGF0aDogTm9kZVBhdGgsXHJcbiAgc2VsZWN0ZWRQYXRoczogQXJyYXk8Tm9kZVBhdGg+LFxyXG4gIGNvbGxhcHNlZFBhdGhzOiBBcnJheTxOb2RlUGF0aD4sXHJcbn07XHJcblxyXG5jbGFzcyBOZXN0ZWRUcmVlSXRlbSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxOZXN0ZWRUcmVlSXRlbVByb3BzPiB7XHJcbiAgX2l0ZW1Ob2RlOiA/SFRNTERpdkVsZW1lbnQ7XHJcbiAgX3N1YnNjcmlwdGlvbnM6IFVuaXZlcnNhbERpc3Bvc2FibGU7XHJcblxyXG4gIF9oYW5kbGVDbGljayA9IChlOiBTeW50aGV0aWNNb3VzZUV2ZW50PD4pID0+IHtcclxuICAgIGNvbnN0IGl0ZW1Ob2RlID0gdGhpcy5faXRlbU5vZGU7XHJcbiAgICBpZiAoaXRlbU5vZGUgPT0gbnVsbCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaW52YXJpYW50KGUudGFyZ2V0IGluc3RhbmNlb2YgRWxlbWVudCk7XHJcbiAgICBpZiAoZS50YXJnZXQuY2xvc2VzdCgnLmxpc3QtaXRlbScpICE9PSBpdGVtTm9kZSkge1xyXG4gICAgICAvLyB0aGlzIHdhcyBhIGNsaWNrIG9uIGEgZGVzY2VuZGFudCBub2RlIGluIHRoZSBpbm5lciBsaXN0XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUT0RPOiBUaGlzIGlzIGdyb3NzLiBJdCBhc3N1bWVzIHRoYXQgdGhlIGV4cGFuZCBjaGV2cm9uIGlzIHByZXNlbnQgaW4gdGhlXHJcbiAgICAvLyBgYmVmb3JlYCBwc2V1ZG9lbGVtZW50IChhcyBpcyB3aXRoIG1vc3QgdGhlbWVzKSwgYW5kIG1lYXN1cmVzIHRoZSBzcGFjZVxyXG4gICAgLy8gaXQgb2NjdXBpZXMgdXNpbmcgY29tcHV0ZWQgc3R5bGUgcHJvcGVydGllcywgbm90IGFjdHVhbCBtZWFzdXJlbWVudHMuXHJcbiAgICAvLyBUaGUgdG9nZ2xlIGNoZXZyb24gc2hvdWxkIGJlIHJlaW1wbGVtZW50ZWQgYXMgYSB0cnVlIGRvbSBub2RlIGluc3RlYWQsXHJcbiAgICAvLyBieXBhc3NpbmcgdGhlbWVzLiBUaG91Z2ggdGhpcyBpcyBtb3JlIHZpc3VhbGx5IGNvbnNpc3RlbnQsIGl0J3MgcHJvYmFibHlcclxuICAgIC8vIG5vdCB3b3J0aCB0aGUgaGFzc2xlLlxyXG4gICAgY29uc3QgYmVmb3JlU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9pdGVtTm9kZSwgJzpiZWZvcmUnKTtcclxuICAgIGNvbnN0IGl0ZW1TdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuX2l0ZW1Ob2RlKTtcclxuICAgIGNvbnN0IGNoZXZyb25XaWR0aCA9XHJcbiAgICAgIHBhcnNlUHgoaXRlbVN0eWxlLnBhZGRpbmdMZWZ0KSArXHJcbiAgICAgIHBhcnNlUHgoYmVmb3JlU3R5bGUucGFkZGluZ0xlZnQpICtcclxuICAgICAgcGFyc2VQeChiZWZvcmVTdHlsZS5wYWRkaW5nUmlnaHQpICtcclxuICAgICAgcGFyc2VQeChiZWZvcmVTdHlsZS5tYXJnaW5MZWZ0KSArXHJcbiAgICAgIHBhcnNlUHgoYmVmb3JlU3R5bGUubWFyZ2luUmlnaHQpICtcclxuICAgICAgcGFyc2VQeChiZWZvcmVTdHlsZS53aWR0aCkgK1xyXG4gICAgICBwYXJzZVB4KGJlZm9yZVN0eWxlLmxlZnQpO1xyXG5cclxuICAgIGNvbnN0IHtwYXRoLCBjb2xsYXBzZWRQYXRoc30gPSB0aGlzLnByb3BzO1xyXG4gICAgaW52YXJpYW50KGUubmF0aXZlRXZlbnQgaW5zdGFuY2VvZiBNb3VzZUV2ZW50KTtcclxuICAgIGlmIChlLm5hdGl2ZUV2ZW50Lm9mZnNldFggPD0gY2hldnJvbldpZHRoKSB7XHJcbiAgICAgIGlmIChcclxuICAgICAgICBjb2xsYXBzZWRQYXRocy5zb21lKGNvbGxhcHNlZFBhdGggPT4gYXJyYXlFcXVhbChwYXRoLCBjb2xsYXBzZWRQYXRoKSlcclxuICAgICAgKSB7XHJcbiAgICAgICAgdGhpcy5wcm9wcy5vbkV4cGFuZChwYXRoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLnByb3BzLm9uQ29sbGFwc2UocGF0aCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHtvblNlbGVjdCwgb25Db25maXJtLCBvblRyaXBsZUNsaWNrfSA9IHRoaXMucHJvcHM7XHJcbiAgICBjb25zdCBudW1iZXJPZkNsaWNrcyA9IGUuZGV0YWlsO1xyXG4gICAgaWYgKG51bWJlck9mQ2xpY2tzID09PSAxICYmIG9uU2VsZWN0ICE9IG51bGwpIHtcclxuICAgICAgb25TZWxlY3QocGF0aCk7XHJcbiAgICB9IGVsc2UgaWYgKG51bWJlck9mQ2xpY2tzID09PSAyICYmIG9uQ29uZmlybSAhPSBudWxsKSB7XHJcbiAgICAgIG9uQ29uZmlybShwYXRoKTtcclxuICAgIH0gZWxzZSBpZiAobnVtYmVyT2ZDbGlja3MgPT09IDMgJiYgb25UcmlwbGVDbGljayAhPSBudWxsKSB7XHJcbiAgICAgIG9uVHJpcGxlQ2xpY2socGF0aCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgcmVuZGVyKCkge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICBjbGFzc05hbWUsXHJcbiAgICAgIGhhc0ZsYXRDaGlsZHJlbixcclxuICAgICAgZm9jdXNlZFBhdGgsXHJcbiAgICAgIHNlbGVjdGVkUGF0aHMsXHJcbiAgICAgIGNvbGxhcHNlZFBhdGhzLFxyXG4gICAgICBwYXRoLFxyXG4gICAgICBsYWJlbCxcclxuICAgICAgY2hpbGRyZW4sXHJcbiAgICB9ID0gdGhpcy5wcm9wcztcclxuICAgIGNvbnN0IGlzRm9jdXNlZCA9IGZvY3VzZWRQYXRoICYmIGFycmF5RXF1YWwocGF0aCwgZm9jdXNlZFBhdGgpO1xyXG4gICAgY29uc3QgaXNTZWxlY3RlZCA9IHNlbGVjdGVkUGF0aHMuc29tZShzZWxlY3RlZFBhdGggPT5cclxuICAgICAgc2hhbGxvd0VxdWFsKHBhdGgsIHNlbGVjdGVkUGF0aCksXHJcbiAgICApO1xyXG4gICAgY29uc3QgaXNDb2xsYXBzZWQgPSBjb2xsYXBzZWRQYXRocy5zb21lKGNvbGxhcHNlZFBhdGggPT5cclxuICAgICAgc2hhbGxvd0VxdWFsKHBhdGgsIGNvbGxhcHNlZFBhdGgpLFxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICA8bGlcclxuICAgICAgICBhcmlhLWFjdGl2ZWRlc2NlbmRhbnQ9e2lzRm9jdXNlZH1cclxuICAgICAgICBhcmlhLXNlbGVjdGVkPXtpc1NlbGVjdGVkfVxyXG4gICAgICAgIGFyaWEtZXhwYW5kZWQ9eyFpc0NvbGxhcHNlZH1cclxuICAgICAgICBjbGFzc05hbWU9e2NsYXNzbmFtZXMoJ2xpc3QtbmVzdGVkLWl0ZW0nLCBjbGFzc05hbWUsIHtcclxuICAgICAgICAgIGNvbGxhcHNlZDogaXNDb2xsYXBzZWQsXHJcbiAgICAgICAgICBzZWxlY3RlZDogaXNTZWxlY3RlZCxcclxuICAgICAgICB9KX1cclxuICAgICAgICBvbkNsaWNrPXt0aGlzLl9oYW5kbGVDbGlja31cclxuICAgICAgICByb2xlPVwidHJlZWl0ZW1cIj5cclxuICAgICAgICB7bGFiZWwgPT0gbnVsbCA/IG51bGwgOiAoXHJcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImxpc3QtaXRlbVwiIHJlZj17bm9kZSA9PiAodGhpcy5faXRlbU5vZGUgPSBub2RlKX0+XHJcbiAgICAgICAgICAgIHtsYWJlbH1cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICl9XHJcbiAgICAgICAgPFRyZWVMaXN0IGhhc0ZsYXRDaGlsZHJlbj17aGFzRmxhdENoaWxkcmVufT57Y2hpbGRyZW59PC9UcmVlTGlzdD5cclxuICAgICAgPC9saT5cclxuICAgICk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBzZWxlY3ROb2RlQXRQYXRoKHJvb3RzOiBBcnJheTxUcmVlTm9kZT4sIHBhdGg6IE5vZGVQYXRoKTogP1RyZWVOb2RlIHtcclxuICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIGxldCBub2RlID0gcm9vdHNbcGF0aFswXV07XHJcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBpbnZhcmlhbnQobm9kZS50eXBlID09PSAnTkVTVEVEJyk7XHJcbiAgICBub2RlID0gbm9kZS5jaGlsZHJlbltwYXRoW2ldXTtcclxuICB9XHJcbiAgcmV0dXJuIG5vZGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldE5leHROb2RlUGF0aChcclxuICByb290czogQXJyYXk8VHJlZU5vZGU+LFxyXG4gIHBhdGg6IE5vZGVQYXRoLFxyXG4gIGNvbGxhcHNlZFBhdGhzOiBBcnJheTxOb2RlUGF0aD4sXHJcbik6ID9Ob2RlUGF0aCB7XHJcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIGNvbnN0IGN1cnJlbnROb2RlID0gc2VsZWN0Tm9kZUF0UGF0aChyb290cywgcGF0aCk7XHJcbiAgaWYgKGN1cnJlbnROb2RlID09IG51bGwpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIGlmIChcclxuICAgIGN1cnJlbnROb2RlLnR5cGUgPT09ICdORVNURUQnICYmXHJcbiAgICBjdXJyZW50Tm9kZS5jaGlsZHJlbi5sZW5ndGggPiAwICYmXHJcbiAgICAvLyBkb24ndCB0cmF2ZXJzZSBjaGlsZHJlbiBvZiBjb2xsYXBzZWQgbm9kZXNcclxuICAgICFjb2xsYXBzZWRQYXRocy5maW5kKGNvbGxhcHNlZFBhdGggPT4gYXJyYXlFcXVhbChjb2xsYXBzZWRQYXRoLCBwYXRoKSlcclxuICApIHtcclxuICAgIC8vICdkb3duJyB3YXMgcHJlc3NlZCBvbiBhIG5lc3RlZCBpdGVtLiBtb3N0IG9mIHRoZSB0aW1lIHdlIHdhbnQgZ28gdG8gaXRzXHJcbiAgICAvLyBmaXJzdCBjaGlsZCwgYnV0IHdlIG5lZWQgdG8gbWFrZSBzdXJlIGl0J3Mgbm90IGhpZGRlbiAoZWcgZmlsdGVyZWQgYnlcclxuICAgIC8vIGEgc2VhcmNoKSBmaXJzdFxyXG4gICAgY29uc3QgZmlyc3RWaXNpYmxlQ2hpbGRJbmRleCA9IGN1cnJlbnROb2RlLmNoaWxkcmVuLmZpbmRJbmRleChcclxuICAgICAgbiA9PiAhbi5oaWRkZW4sXHJcbiAgICApO1xyXG4gICAgaWYgKGZpcnN0VmlzaWJsZUNoaWxkSW5kZXggPj0gMCkge1xyXG4gICAgICByZXR1cm4gcGF0aC5jb25jYXQoW2ZpcnN0VmlzaWJsZUNoaWxkSW5kZXhdKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBmaW5kTmV4dFNpYmxpbmcocm9vdHMsIHBhdGgsIGNvbGxhcHNlZFBhdGhzKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZmluZE5leHRTaWJsaW5nKFxyXG4gIHJvb3RzOiBBcnJheTxUcmVlTm9kZT4sXHJcbiAgcGF0aDogTm9kZVBhdGgsXHJcbiAgY29sbGFwc2VkUGF0aHM6IEFycmF5PE5vZGVQYXRoPixcclxuKTogP05vZGVQYXRoIHtcclxuICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgbGVhZGluZ0luZGV4ZXMgPSBwYXRoLnNsaWNlKDAsIHBhdGgubGVuZ3RoIC0gMSk7XHJcbiAgY29uc3QgdGFpbEluZGV4ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xyXG4gIGNvbnN0IG5leHRTaWJsaW5nUGF0aCA9IFsuLi5sZWFkaW5nSW5kZXhlcywgdGFpbEluZGV4ICsgMV07XHJcbiAgY29uc3QgbmV4dFNpYmxpbmcgPSBzZWxlY3ROb2RlQXRQYXRoKHJvb3RzLCBuZXh0U2libGluZ1BhdGgpO1xyXG4gIGlmIChuZXh0U2libGluZyAhPSBudWxsKSB7XHJcbiAgICBpZiAobmV4dFNpYmxpbmcuaGlkZGVuKSB7XHJcbiAgICAgIC8vIHNraXAgb3ZlciBuZXh0IGhpZGRlbiBub2RlcyBieSBmaW5kaW5nICp0aGVpciogbmV4dCBzaWJsaW5nXHJcbiAgICAgIHJldHVybiBmaW5kTmV4dFNpYmxpbmcocm9vdHMsIG5leHRTaWJsaW5nUGF0aCwgY29sbGFwc2VkUGF0aHMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5leHRTaWJsaW5nUGF0aDtcclxuICB9XHJcblxyXG4gIC8vIHRoZXJlJ3Mgbm8gbmV4dCBzaWJsaW5nLiBsZXQncyBuYXZpZ2F0ZSB0byB0aGlzIG5vZGUncyBwYXJlbnQncyBzaWJsaW5nc1xyXG4gIHJldHVybiBmaW5kTmV4dFNpYmxpbmcocm9vdHMsIGxlYWRpbmdJbmRleGVzLCBjb2xsYXBzZWRQYXRocyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFByZXZOb2RlUGF0aChcclxuICByb290czogQXJyYXk8VHJlZU5vZGU+LFxyXG4gIHBhdGg6IE5vZGVQYXRoLFxyXG4gIGNvbGxhcHNlZFBhdGhzOiBBcnJheTxOb2RlUGF0aD4sXHJcbik6ID9Ob2RlUGF0aCB7XHJcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIGNvbnN0IGxlYWRpbmdJbmRleGVzID0gcGF0aC5zbGljZSgwLCBwYXRoLmxlbmd0aCAtIDEpO1xyXG4gIGNvbnN0IHRhaWxJbmRleCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcclxuICBjb25zdCBwcmV2U2libGluZ1BhdGggPSBbLi4ubGVhZGluZ0luZGV4ZXMsIHRhaWxJbmRleCAtIDFdO1xyXG4gIGNvbnN0IHByZXZTaWJsaW5nID0gc2VsZWN0Tm9kZUF0UGF0aChyb290cywgcHJldlNpYmxpbmdQYXRoKTtcclxuICBpZiAocHJldlNpYmxpbmcgIT0gbnVsbCkge1xyXG4gICAgaWYgKHByZXZTaWJsaW5nLmhpZGRlbikge1xyXG4gICAgICByZXR1cm4gZ2V0UHJldk5vZGVQYXRoKHJvb3RzLCBwcmV2U2libGluZ1BhdGgsIGNvbGxhcHNlZFBhdGhzKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoXHJcbiAgICAgIHByZXZTaWJsaW5nLnR5cGUgPT09ICdORVNURUQnICYmXHJcbiAgICAgIHByZXZTaWJsaW5nLmNoaWxkcmVuLmxlbmd0aCA+IDAgJiZcclxuICAgICAgLy8gZG9uJ3QgdHJhdmVyc2UgY2hpbGRyZW4gb2YgY29sbGFwc2VkIG5vZGVzXHJcbiAgICAgICFjb2xsYXBzZWRQYXRocy5maW5kKGNvbGxhcHNlZFBhdGggPT5cclxuICAgICAgICBhcnJheUVxdWFsKGNvbGxhcHNlZFBhdGgsIHByZXZTaWJsaW5nUGF0aCksXHJcbiAgICAgIClcclxuICAgICkge1xyXG4gICAgICAvLyBwcmVzc2VkICd1cCcgb24gYSBub2RlIGp1c3QgYWZ0ZXIgYW4gZXhwYW5kZWQgbmVzdGVkIGl0ZW0uIE5vcm1hbGx5IHRoaXNcclxuICAgICAgLy8gc2hvdWxkIHRha2UgdXMgdG8gdGhlIGxhc3QgaXRlbSBpbnNpZGUgdGhlIGV4cGFuZGVkIG5vZGUsIGJ1dCBzb21lIG1heVxyXG4gICAgICAvLyBiZSBoaWRkZW4uIEZpbmQgdGhlIGxhc3QgaW4gdGhlIGxpc3QgdGhhdCdzIHZpc2libGUuXHJcbiAgICAgIGNvbnN0IGxhc3RWaXNpYmxlQ2hpbGRJbmRleCA9IGFycmF5RmluZExhc3RJbmRleChcclxuICAgICAgICBwcmV2U2libGluZy5jaGlsZHJlbixcclxuICAgICAgICBuID0+ICFuLmhpZGRlbixcclxuICAgICAgKTtcclxuICAgICAgaWYgKGxhc3RWaXNpYmxlQ2hpbGRJbmRleCA+PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHByZXZTaWJsaW5nUGF0aC5jb25jYXQoW2xhc3RWaXNpYmxlQ2hpbGRJbmRleF0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHByZXZTaWJsaW5nUGF0aDtcclxuICB9XHJcblxyXG4gIC8vIHJldHVybiB0aGUgcGFyZW50IGlmIGl0J3MgYSB2YWxpZCBwYXRoXHJcbiAgaWYgKGxlYWRpbmdJbmRleGVzLmxlbmd0aCA+IDApIHtcclxuICAgIHJldHVybiBsZWFkaW5nSW5kZXhlcztcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlUHgocHg6IHN0cmluZyk6IG51bWJlciB7XHJcbiAgcmV0dXJuIHB4Lmxlbmd0aCA9PT0gMCA/IDAgOiBOdW1iZXIocHgucmVwbGFjZSgncHgnLCAnJykpO1xyXG59XHJcbiJdfQ==