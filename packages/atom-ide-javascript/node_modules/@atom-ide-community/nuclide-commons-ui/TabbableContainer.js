"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(require("react"));

var _assert = _interopRequireDefault(require("assert"));

var _rxjsCompatUmdMin = require("rxjs-compat/bundles/rxjs-compat.umd.min.js");

var _tabbable = _interopRequireDefault(require("tabbable"));

var _classnames = _interopRequireDefault(require("classnames"));

var _UniversalDisposable = _interopRequireDefault(require("@atom-ide-community/nuclide-commons/UniversalDisposable"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */

/* eslint-env browser */
const TABBABLE_CLASS_NAME = 'nuclide-tabbable';
/**
 * Enables focusing between inputs with tab and shift-tab. Can also be used to
 * trap focus within the container by using the contained property.
 */

class TabbableContainer extends _react.default.Component {
  constructor(...args) {
    super(...args);
    this._disposables = void 0;
    this._rootNode = void 0;
  }

  componentDidMount() {
    const rootNode = this._rootNode;
    (0, _assert.default)(rootNode != null);
    const {
      focusOnMount
    } = this.props; // If focus has been deliberately set inside the container, don't try
    // to override it

    if (focusOnMount && !rootNode.contains(document.activeElement)) {
      const tabbableElements = (0, _tabbable.default)(rootNode);
      const firstTabbableElement = tabbableElements[0];

      if (firstTabbableElement instanceof HTMLElement) {
        firstTabbableElement.focus();
      }
    }

    this._disposables = new _UniversalDisposable.default(_rxjsCompatUmdMin.Observable.fromEvent(rootNode, 'keydown').subscribe(event => {
      if (event.altKey || event.ctrlKey || event.metaKey) {
        return;
      }

      if (event.key === 'Tab') {
        if (event.shiftKey) {
          focusPrevious();
        } else {
          focusNext();
        }

        event.preventDefault();
        event.stopPropagation();
      }
    }));
  }

  componentWillUnmount() {
    this._disposables.dispose();
  }

  render() {
    return /*#__PURE__*/_react.default.createElement("div", {
      className: (0, _classnames.default)(TABBABLE_CLASS_NAME, this.props.className),
      "data-contained": this.props.contained,
      ref: node => this._rootNode = node
    }, this.props.children);
  }

}

exports.default = TabbableContainer;
TabbableContainer.defaultProps = {
  contained: false,
  focusOnMount: true
};

function focusNext() {
  const currentElement = getFocusedElement();

  if (!(currentElement instanceof HTMLElement)) {
    return;
  }

  const focusedTabIndex = currentElement.tabIndex >= 0 ? currentElement.tabIndex : -Infinity;
  let nextElement = null;
  let nextTabIndex = Infinity;
  let lowestElement = null;
  let lowestTabIndex = Infinity;
  let container = findParentElement(currentElement, element => {
    return element.classList.contains(TABBABLE_CLASS_NAME);
  });

  if (container instanceof HTMLElement && container.dataset.contained === 'false') {
    container = null;
  }

  eachTabIndexedElement(currentElement, false
  /* reverse */
  , (element, tabIndex) => {
    if (tabIndex < lowestTabIndex) {
      lowestTabIndex = tabIndex;
      lowestElement = element;
    }

    if (focusedTabIndex <= tabIndex && tabIndex < nextTabIndex) {
      nextTabIndex = tabIndex;
      nextElement = element;

      if (focusedTabIndex === tabIndex || focusedTabIndex + 1 === tabIndex) {
        return true; // doneSearching
      }
    }

    return false; // doneSearching
  }, container);

  if (nextElement) {
    nextElement.focus();
  } else if (lowestElement) {
    lowestElement.focus();
  }
}

function focusPrevious() {
  const currentElement = getFocusedElement();

  if (!(currentElement instanceof HTMLElement)) {
    return;
  }

  const focusedTabIndex = currentElement.tabIndex >= 0 ? currentElement.tabIndex : Infinity;
  let previousElement = null;
  let previousTabIndex = -Infinity;
  let highestElement = null;
  let highestTabIndex = -Infinity;
  let container = findParentElement(currentElement, element => {
    return element.classList.contains(TABBABLE_CLASS_NAME);
  });

  if (container instanceof HTMLElement && container.dataset.contained === 'false') {
    container = null;
  }

  eachTabIndexedElement(currentElement, true
  /* reverse */
  , (element, tabIndex) => {
    if (tabIndex > highestTabIndex) {
      highestTabIndex = tabIndex;
      highestElement = element;
    }

    if (focusedTabIndex >= tabIndex && tabIndex > previousTabIndex) {
      previousTabIndex = tabIndex;
      previousElement = element;

      if (focusedTabIndex === tabIndex || focusedTabIndex - 1 === tabIndex) {
        return true; // doneSearching
      }
    }

    return false; // doneSearching
  }, container);

  if (previousElement) {
    previousElement.focus();
  } else if (highestElement) {
    highestElement.focus();
  }
}
/**
 * Traverses all focusable elements for the next element to focus.
 * curentElement is where the traversal starts.
 * reverse determines whether to traverse backwards or forwards.
 * updateNextCandidate is a method that determines if the element is the best
 *                     candidate to be focused next. A boolean is returned to
 *                     stop the traversal if that element is guaranteed to be
 *                     the next candidate.
 * container is where all of the focusable elements are searched.
 *           Default value is document.
 */


function eachTabIndexedElement(currentElement, reverse, updateNextCandidate, container) {
  const elements = (container || document).querySelectorAll('a, input, button, [tabindex]');
  let index = Array.from(elements).indexOf(currentElement);
  const increment = reverse ? -1 : 1;

  for (let i = 1; i < elements.length; ++i) {
    index = (index + elements.length + increment) % elements.length;
    const element = elements[index];

    if ( // $FlowFixMe(>=0.68.0) Flow suppress (T27187857)
    element.disabled === true || element.tabIndex == null || element.tabIndex < 0) {
      continue;
    }

    if (updateNextCandidate(element, element.tabIndex)) {
      break;
    }
  }
}

function getFocusedElement() {
  return document.activeElement;
}
/**
 * Finds a parent of currentElement that satisfies the condition.
 */


function findParentElement(currentElement, condition) {
  let element = currentElement;

  while (element && !condition(element)) {
    element = element.parentElement;
  }

  return element;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zLXVpL1RhYmJhYmxlQ29udGFpbmVyLmpzIl0sIm5hbWVzIjpbIlRBQkJBQkxFX0NMQVNTX05BTUUiLCJUYWJiYWJsZUNvbnRhaW5lciIsIlJlYWN0IiwiQ29tcG9uZW50IiwiX2Rpc3Bvc2FibGVzIiwiX3Jvb3ROb2RlIiwiY29tcG9uZW50RGlkTW91bnQiLCJyb290Tm9kZSIsImZvY3VzT25Nb3VudCIsInByb3BzIiwiY29udGFpbnMiLCJkb2N1bWVudCIsImFjdGl2ZUVsZW1lbnQiLCJ0YWJiYWJsZUVsZW1lbnRzIiwiZmlyc3RUYWJiYWJsZUVsZW1lbnQiLCJIVE1MRWxlbWVudCIsImZvY3VzIiwiVW5pdmVyc2FsRGlzcG9zYWJsZSIsIk9ic2VydmFibGUiLCJmcm9tRXZlbnQiLCJzdWJzY3JpYmUiLCJldmVudCIsImFsdEtleSIsImN0cmxLZXkiLCJtZXRhS2V5Iiwia2V5Iiwic2hpZnRLZXkiLCJmb2N1c1ByZXZpb3VzIiwiZm9jdXNOZXh0IiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJjb21wb25lbnRXaWxsVW5tb3VudCIsImRpc3Bvc2UiLCJyZW5kZXIiLCJjbGFzc05hbWUiLCJjb250YWluZWQiLCJub2RlIiwiY2hpbGRyZW4iLCJkZWZhdWx0UHJvcHMiLCJjdXJyZW50RWxlbWVudCIsImdldEZvY3VzZWRFbGVtZW50IiwiZm9jdXNlZFRhYkluZGV4IiwidGFiSW5kZXgiLCJJbmZpbml0eSIsIm5leHRFbGVtZW50IiwibmV4dFRhYkluZGV4IiwibG93ZXN0RWxlbWVudCIsImxvd2VzdFRhYkluZGV4IiwiY29udGFpbmVyIiwiZmluZFBhcmVudEVsZW1lbnQiLCJlbGVtZW50IiwiY2xhc3NMaXN0IiwiZGF0YXNldCIsImVhY2hUYWJJbmRleGVkRWxlbWVudCIsInByZXZpb3VzRWxlbWVudCIsInByZXZpb3VzVGFiSW5kZXgiLCJoaWdoZXN0RWxlbWVudCIsImhpZ2hlc3RUYWJJbmRleCIsInJldmVyc2UiLCJ1cGRhdGVOZXh0Q2FuZGlkYXRlIiwiZWxlbWVudHMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiaW5kZXgiLCJBcnJheSIsImZyb20iLCJpbmRleE9mIiwiaW5jcmVtZW50IiwiaSIsImxlbmd0aCIsImRpc2FibGVkIiwiY29uZGl0aW9uIiwicGFyZW50RWxlbWVudCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQWNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7O0FBbkJBOzs7Ozs7Ozs7Ozs7QUFZQTtBQXFCQSxNQUFNQSxtQkFBbUIsR0FBRyxrQkFBNUI7QUFFQTs7Ozs7QUFJZSxNQUFNQyxpQkFBTixTQUFnQ0MsZUFBTUMsU0FBdEMsQ0FBdUQ7QUFBQTtBQUFBO0FBQUEsU0FDcEVDLFlBRG9FO0FBQUEsU0FFcEVDLFNBRm9FO0FBQUE7O0FBU3BFQyxFQUFBQSxpQkFBaUIsR0FBRztBQUNsQixVQUFNQyxRQUFRLEdBQUcsS0FBS0YsU0FBdEI7QUFDQSx5QkFBVUUsUUFBUSxJQUFJLElBQXRCO0FBQ0EsVUFBTTtBQUFDQyxNQUFBQTtBQUFELFFBQWlCLEtBQUtDLEtBQTVCLENBSGtCLENBS2xCO0FBQ0E7O0FBQ0EsUUFBSUQsWUFBWSxJQUFJLENBQUNELFFBQVEsQ0FBQ0csUUFBVCxDQUFrQkMsUUFBUSxDQUFDQyxhQUEzQixDQUFyQixFQUFnRTtBQUM5RCxZQUFNQyxnQkFBZ0IsR0FBRyx1QkFBU04sUUFBVCxDQUF6QjtBQUNBLFlBQU1PLG9CQUFvQixHQUFHRCxnQkFBZ0IsQ0FBQyxDQUFELENBQTdDOztBQUNBLFVBQUlDLG9CQUFvQixZQUFZQyxXQUFwQyxFQUFpRDtBQUMvQ0QsUUFBQUEsb0JBQW9CLENBQUNFLEtBQXJCO0FBQ0Q7QUFDRjs7QUFFRCxTQUFLWixZQUFMLEdBQW9CLElBQUlhLDRCQUFKLENBQ2xCQyw2QkFBV0MsU0FBWCxDQUFxQlosUUFBckIsRUFBK0IsU0FBL0IsRUFBMENhLFNBQTFDLENBQ0dDLEtBQUQsSUFBMEI7QUFDeEIsVUFBSUEs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QU8sQ0FBQ21CLFFBQVIsS0FBcUIsSUFBckIsSUFDQW5CLE9BQU8sQ0FBQ1IsUUFBUixJQUFvQixJQURwQixJQUVBUSxPQUFPLENBQUNSLFFBQVIsR0FBbUIsQ0FKckIsRUFLRTtBQUNBO0FBQ0Q7O0FBQ0QsUUFBSWlCLG1CQUFtQixDQUFDVCxPQUFELEVBQVVBLE9BQU8sQ0FBQ1IsUUFBbEIsQ0FBdkIsRUFBb0Q7QUFDbEQ7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsU0FBU0YsaUJBQVQsR0FBdUM7QUFDckMsU0FBTzdCLFFBQVEsQ0FBQ0MsYUFBaEI7QUFDRDtBQUVEOzs7OztBQUdBLFNBQVNxQyxpQkFBVCxDQUNFVixjQURGLEVBRUUrQixTQUZGLEVBR1k7QUFDVixNQUFJcEIsT0FBTyxHQUFHWCxjQUFkOztBQUNBLFNBQU9XLE9BQU8sSUFBSSxDQUFDb0IsU0FBUyxDQUFDcEIsT0FBRCxDQUE1QixFQUF1QztBQUNyQ0EsSUFBQUEsT0FBTyxHQUFHQSxPQUFPLENBQUNxQixhQUFsQjtBQUNEOztBQUNELFNBQU9yQixPQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIEBmbG93IHN0cmljdC1sb2NhbFxyXG4gKiBAZm9ybWF0XHJcbiAqL1xyXG5cclxuLyogZXNsaW50LWVudiBicm93c2VyICovXHJcblxyXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2Fzc2VydCc7XHJcbmltcG9ydCB7T2JzZXJ2YWJsZX0gZnJvbSAncnhqcy1jb21wYXQvYnVuZGxlcy9yeGpzLWNvbXBhdC51bWQubWluLmpzJztcclxuaW1wb3J0IHRhYmJhYmxlIGZyb20gJ3RhYmJhYmxlJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcbmltcG9ydCBVbml2ZXJzYWxEaXNwb3NhYmxlIGZyb20gJ0BhdG9tLWlkZS1jb21tdW5pdHkvbnVjbGlkZS1jb21tb25zL1VuaXZlcnNhbERpc3Bvc2FibGUnO1xyXG5cclxudHlwZSBEZWZhdWx0UHJvcHMgPSB7XHJcbiAgY29udGFpbmVkOiBib29sZWFuLFxyXG4gIGZvY3VzT25Nb3VudDogYm9vbGVhbixcclxufTtcclxuXHJcbnR5cGUgUHJvcHMgPSB7XHJcbiAgY2hpbGRyZW4/OiBSZWFjdCROb2RlLFxyXG4gIGNvbnRhaW5lZDogYm9vbGVhbixcclxuICBmb2N1c09uTW91bnQ6IGJvb2xlYW4sXHJcbiAgY2xhc3NOYW1lPzogc3RyaW5nLFxyXG59O1xyXG5cclxuY29uc3QgVEFCQkFCTEVfQ0xBU1NfTkFNRSA9ICdudWNsaWRlLXRhYmJhYmxlJztcclxuXHJcbi8qKlxyXG4gKiBFbmFibGVzIGZvY3VzaW5nIGJldHdlZW4gaW5wdXRzIHdpdGggdGFiIGFuZCBzaGlmdC10YWIuIENhbiBhbHNvIGJlIHVzZWQgdG9cclxuICogdHJhcCBmb2N1cyB3aXRoaW4gdGhlIGNvbnRhaW5lciBieSB1c2luZyB0aGUgY29udGFpbmVkIHByb3BlcnR5LlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGFiYmFibGVDb250YWluZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8UHJvcHM+IHtcclxuICBfZGlzcG9zYWJsZXM6IFVuaXZlcnNhbERpc3Bvc2FibGU7XHJcbiAgX3Jvb3ROb2RlOiA/SFRNTERpdkVsZW1lbnQ7XHJcblxyXG4gIHN0YXRpYyBkZWZhdWx0UHJvcHM6IERlZmF1bHRQcm9wcyA9IHtcclxuICAgIGNvbnRhaW5lZDogZmFsc2UsXHJcbiAgICBmb2N1c09uTW91bnQ6IHRydWUsXHJcbiAgfTtcclxuXHJcbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XHJcbiAgICBjb25zdCByb290Tm9kZSA9IHRoaXMuX3Jvb3ROb2RlO1xyXG4gICAgaW52YXJpYW50KHJvb3ROb2RlICE9IG51bGwpO1xyXG4gICAgY29uc3Qge2ZvY3VzT25Nb3VudH0gPSB0aGlzLnByb3BzO1xyXG5cclxuICAgIC8vIElmIGZvY3VzIGhhcyBiZWVuIGRlbGliZXJhdGVseSBzZXQgaW5zaWRlIHRoZSBjb250YWluZXIsIGRvbid0IHRyeVxyXG4gICAgLy8gdG8gb3ZlcnJpZGUgaXRcclxuICAgIGlmIChmb2N1c09uTW91bnQgJiYgIXJvb3ROb2RlLmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XHJcbiAgICAgIGNvbnN0IHRhYmJhYmxlRWxlbWVudHMgPSB0YWJiYWJsZShyb290Tm9kZSk7XHJcbiAgICAgIGNvbnN0IGZpcnN0VGFiYmFibGVFbGVtZW50ID0gdGFiYmFibGVFbGVtZW50c1swXTtcclxuICAgICAgaWYgKGZpcnN0VGFiYmFibGVFbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcclxuICAgICAgICBmaXJzdFRhYmJhYmxlRWxlbWVudC5mb2N1cygpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fZGlzcG9zYWJsZXMgPSBuZXcgVW5pdmVyc2FsRGlzcG9zYWJsZShcclxuICAgICAgT2JzZXJ2YWJsZS5mcm9tRXZlbnQocm9vdE5vZGUsICdrZXlkb3duJykuc3Vic2NyaWJlKFxyXG4gICAgICAgIChldmVudDogS2V5Ym9hcmRFdmVudCkgPT4ge1xyXG4gICAgICAgICAgaWYgKGV2ZW50LmFsdEtleSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmIChldmVudC5rZXkgPT09ICdUYWInKSB7XHJcbiAgICAgICAgICAgIGlmIChldmVudC5zaGlmdEtleSkge1xyXG4gICAgICAgICAgICAgIGZvY3VzUHJldmlvdXMoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBmb2N1c05leHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICApLFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xyXG4gICAgdGhpcy5fZGlzcG9zYWJsZXMuZGlzcG9zZSgpO1xyXG4gIH1cclxuXHJcbiAgcmVuZGVyKCk6IFJlYWN0JE5vZGUge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgPGRpdlxyXG4gICAgICAgIGNsYXNzTmFtZT17Y2xhc3NuYW1lcyhUQUJCQUJMRV9DTEFTU19OQU1FLCB0aGlzLnByb3BzLmNsYXNzTmFtZSl9XHJcbiAgICAgICAgZGF0YS1jb250YWluZWQ9e3RoaXMucHJvcHMuY29udGFpbmVkfVxyXG4gICAgICAgIHJlZj17bm9kZSA9PiAodGhpcy5fcm9vdE5vZGUgPSBub2RlKX0+XHJcbiAgICAgICAge3RoaXMucHJvcHMuY2hpbGRyZW59XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZvY3VzTmV4dCgpOiB2b2lkIHtcclxuICBjb25zdCBjdXJyZW50RWxlbWVudCA9IGdldEZvY3VzZWRFbGVtZW50KCk7XHJcbiAgaWYgKCEoY3VycmVudEVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgY29uc3QgZm9jdXNlZFRhYkluZGV4ID1cclxuICAgIGN1cnJlbnRFbGVtZW50LnRhYkluZGV4ID49IDAgPyBjdXJyZW50RWxlbWVudC50YWJJbmRleCA6IC1JbmZpbml0eTtcclxuXHJcbiAgbGV0IG5leHRFbGVtZW50ID0gbnVsbDtcclxuICBsZXQgbmV4dFRhYkluZGV4ID0gSW5maW5pdHk7XHJcbiAgbGV0IGxvd2VzdEVsZW1lbnQgPSBudWxsO1xyXG4gIGxldCBsb3dlc3RUYWJJbmRleCA9IEluZmluaXR5O1xyXG5cclxuICBsZXQgY29udGFpbmVyID0gZmluZFBhcmVudEVsZW1lbnQoY3VycmVudEVsZW1lbnQsIGVsZW1lbnQgPT4ge1xyXG4gICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKFRBQkJBQkxFX0NMQVNTX05BTUUpO1xyXG4gIH0pO1xyXG4gIGlmIChcclxuICAgIGNvbnRhaW5lciBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmXHJcbiAgICBjb250YWluZXIuZGF0YXNldC5jb250YWluZWQgPT09ICdmYWxzZSdcclxuICApIHtcclxuICAgIGNvbnRhaW5lciA9IG51bGw7XHJcbiAgfVxyXG5cclxuICBlYWNoVGFiSW5kZXhlZEVsZW1lbnQoXHJcbiAgICBjdXJyZW50RWxlbWVudCxcclxuICAgIGZhbHNlIC8qIHJldmVyc2UgKi8sXHJcbiAgICAoZWxlbWVudCwgdGFiSW5kZXgpID0+IHtcclxuICAgICAgaWYgKHRhYkluZGV4IDwgbG93ZXN0VGFiSW5kZXgpIHtcclxuICAgICAgICBsb3dlc3RUYWJJbmRleCA9IHRhYkluZGV4O1xyXG4gICAgICAgIGxvd2VzdEVsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoZm9jdXNlZFRhYkluZGV4IDw9IHRhYkluZGV4ICYmIHRhYkluZGV4IDwgbmV4dFRhYkluZGV4KSB7XHJcbiAgICAgICAgbmV4dFRhYkluZGV4ID0gdGFiSW5kZXg7XHJcbiAgICAgICAgbmV4dEVsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgICAgIGlmIChmb2N1c2VkVGFiSW5kZXggPT09IHRhYkluZGV4IHx8IGZvY3VzZWRUYWJJbmRleCArIDEgPT09IHRhYkluZGV4KSB7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gZG9uZVNlYXJjaGluZ1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGZhbHNlOyAvLyBkb25lU2VhcmNoaW5nXHJcbiAgICB9LFxyXG4gICAgY29udGFpbmVyLFxyXG4gICk7XHJcblxyXG4gIGlmIChuZXh0RWxlbWVudCkge1xyXG4gICAgbmV4dEVsZW1lbnQuZm9jdXMoKTtcclxuICB9IGVsc2UgaWYgKGxvd2VzdEVsZW1lbnQpIHtcclxuICAgIGxvd2VzdEVsZW1lbnQuZm9jdXMoKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZvY3VzUHJldmlvdXMoKTogdm9pZCB7XHJcbiAgY29uc3QgY3VycmVudEVsZW1lbnQgPSBnZXRGb2N1c2VkRWxlbWVudCgpO1xyXG4gIGlmICghKGN1cnJlbnRFbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGNvbnN0IGZvY3VzZWRUYWJJbmRleCA9XHJcbiAgICBjdXJyZW50RWxlbWVudC50YWJJbmRleCA+PSAwID8gY3VycmVudEVsZW1lbnQudGFiSW5kZXggOiBJbmZpbml0eTtcclxuXHJcbiAgbGV0IHByZXZpb3VzRWxlbWVudCA9IG51bGw7XHJcbiAgbGV0IHByZXZpb3VzVGFiSW5kZXggPSAtSW5maW5pdHk7XHJcbiAgbGV0IGhpZ2hlc3RFbGVtZW50ID0gbnVsbDtcclxuICBsZXQgaGlnaGVzdFRhYkluZGV4ID0gLUluZmluaXR5O1xyXG5cclxuICBsZXQgY29udGFpbmVyID0gZmluZFBhcmVudEVsZW1lbnQoY3VycmVudEVsZW1lbnQsIGVsZW1lbnQgPT4ge1xyXG4gICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKFRBQkJBQkxFX0NMQVNTX05BTUUpO1xyXG4gIH0pO1xyXG4gIGlmIChcclxuICAgIGNvbnRhaW5lciBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmXHJcbiAgICBjb250YWluZXIuZGF0YXNldC5jb250YWluZWQgPT09ICdmYWxzZSdcclxuICApIHtcclxuICAgIGNvbnRhaW5lciA9IG51bGw7XHJcbiAgfVxyXG5cclxuICBlYWNoVGFiSW5kZXhlZEVsZW1lbnQoXHJcbiAgICBjdXJyZW50RWxlbWVudCxcclxuICAgIHRydWUgLyogcmV2ZXJzZSAqLyxcclxuICAgIChlbGVtZW50LCB0YWJJbmRleCkgPT4ge1xyXG4gICAgICBpZiAodGFiSW5kZXggPiBoaWdoZXN0VGFiSW5kZXgpIHtcclxuICAgICAgICBoaWdoZXN0VGFiSW5kZXggPSB0YWJJbmRleDtcclxuICAgICAgICBoaWdoZXN0RWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChmb2N1c2VkVGFiSW5kZXggPj0gdGFiSW5kZXggJiYgdGFiSW5kZXggPiBwcmV2aW91c1RhYkluZGV4KSB7XHJcbiAgICAgICAgcHJldmlvdXNUYWJJbmRleCA9IHRhYkluZGV4O1xyXG4gICAgICAgIHByZXZpb3VzRWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKGZvY3VzZWRUYWJJbmRleCA9PT0gdGFiSW5kZXggfHwgZm9jdXNlZFRhYkluZGV4IC0gMSA9PT0gdGFiSW5kZXgpIHtcclxuICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBkb25lU2VhcmNoaW5nXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gZmFsc2U7IC8vIGRvbmVTZWFyY2hpbmdcclxuICAgIH0sXHJcbiAgICBjb250YWluZXIsXHJcbiAgKTtcclxuXHJcbiAgaWYgKHByZXZpb3VzRWxlbWVudCkge1xyXG4gICAgcHJldmlvdXNFbGVtZW50LmZvY3VzKCk7XHJcbiAgfSBlbHNlIGlmIChoaWdoZXN0RWxlbWVudCkge1xyXG4gICAgaGlnaGVzdEVsZW1lbnQuZm9jdXMoKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUcmF2ZXJzZXMgYWxsIGZvY3VzYWJsZSBlbGVtZW50cyBmb3IgdGhlIG5leHQgZWxlbWVudCB0byBmb2N1cy5cclxuICogY3VyZW50RWxlbWVudCBpcyB3aGVyZSB0aGUgdHJhdmVyc2FsIHN0YXJ0cy5cclxuICogcmV2ZXJzZSBkZXRlcm1pbmVzIHdoZXRoZXIgdG8gdHJhdmVyc2UgYmFja3dhcmRzIG9yIGZvcndhcmRzLlxyXG4gKiB1cGRhdGVOZXh0Q2FuZGlkYXRlIGlzIGEgbWV0aG9kIHRoYXQgZGV0ZXJtaW5lcyBpZiB0aGUgZWxlbWVudCBpcyB0aGUgYmVzdFxyXG4gKiAgICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZSB0byBiZSBmb2N1c2VkIG5leHQuIEEgYm9vbGVhbiBpcyByZXR1cm5lZCB0b1xyXG4gKiAgICAgICAgICAgICAgICAgICAgIHN0b3AgdGhlIHRyYXZlcnNhbCBpZiB0aGF0IGVsZW1lbnQgaXMgZ3VhcmFudGVlZCB0byBiZVxyXG4gKiAgICAgICAgICAgICAgICAgICAgIHRoZSBuZXh0IGNhbmRpZGF0ZS5cclxuICogY29udGFpbmVyIGlzIHdoZXJlIGFsbCBvZiB0aGUgZm9jdXNhYmxlIGVsZW1lbnRzIGFyZSBzZWFyY2hlZC5cclxuICogICAgICAgICAgIERlZmF1bHQgdmFsdWUgaXMgZG9jdW1lbnQuXHJcbiAqL1xyXG5mdW5jdGlvbiBlYWNoVGFiSW5kZXhlZEVsZW1lbnQoXHJcbiAgY3VycmVudEVsZW1lbnQ6IEVsZW1lbnQsXHJcbiAgcmV2ZXJzZTogYm9vbGVhbixcclxuICB1cGRhdGVOZXh0Q2FuZGlkYXRlOiAoZWxlbWVudDogRWxlbWVudCwgdGFiSW5kZXg6IG51bWJlcikgPT4gYm9vbGVhbixcclxuICBjb250YWluZXI6ID9FbGVtZW50LFxyXG4pOiB2b2lkIHtcclxuICBjb25zdCBlbGVtZW50cyA9IChjb250YWluZXIgfHwgZG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3JBbGwoXHJcbiAgICAnYSwgaW5wdXQsIGJ1dHRvbiwgW3RhYmluZGV4XScsXHJcbiAgKTtcclxuICBsZXQgaW5kZXggPSBBcnJheS5mcm9tKGVsZW1lbnRzKS5pbmRleE9mKGN1cnJlbnRFbGVtZW50KTtcclxuICBjb25zdCBpbmNyZW1lbnQgPSByZXZlcnNlID8gLTEgOiAxO1xyXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgZWxlbWVudHMubGVuZ3RoOyArK2kpIHtcclxuICAgIGluZGV4ID0gKGluZGV4ICsgZWxlbWVudHMubGVuZ3RoICsgaW5jcmVtZW50KSAlIGVsZW1lbnRzLmxlbmd0aDtcclxuICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpbmRleF07XHJcbiAgICBpZiAoXHJcbiAgICAgIC8vICRGbG93Rml4TWUoPj0wLjY4LjApIEZsb3cgc3VwcHJlc3MgKFQyNzE4Nzg1NylcclxuICAgICAgZWxlbWVudC5kaXNhYmxlZCA9PT0gdHJ1ZSB8fFxyXG4gICAgICBlbGVtZW50LnRhYkluZGV4ID09IG51bGwgfHxcclxuICAgICAgZWxlbWVudC50YWJJbmRleCA8IDBcclxuICAgICkge1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIGlmICh1cGRhdGVOZXh0Q2FuZGlkYXRlKGVsZW1lbnQsIGVsZW1lbnQudGFiSW5kZXgpKSB7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0Rm9jdXNlZEVsZW1lbnQoKTogP0VsZW1lbnQge1xyXG4gIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xyXG59XHJcblxyXG4vKipcclxuICogRmluZHMgYSBwYXJlbnQgb2YgY3VycmVudEVsZW1lbnQgdGhhdCBzYXRpc2ZpZXMgdGhlIGNvbmRpdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIGZpbmRQYXJlbnRFbGVtZW50KFxyXG4gIGN1cnJlbnRFbGVtZW50OiA/RWxlbWVudCxcclxuICBjb25kaXRpb246IChlbGVtZW50OiBFbGVtZW50KSA9PiBib29sZWFuLFxyXG4pOiA/RWxlbWVudCB7XHJcbiAgbGV0IGVsZW1lbnQgPSBjdXJyZW50RWxlbWVudDtcclxuICB3aGlsZSAoZWxlbWVudCAmJiAhY29uZGl0aW9uKGVsZW1lbnQpKSB7XHJcbiAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xyXG4gIH1cclxuICByZXR1cm4gZWxlbWVudDtcclxufVxyXG4iXX0=