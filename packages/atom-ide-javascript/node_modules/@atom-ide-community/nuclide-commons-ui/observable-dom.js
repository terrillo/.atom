"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ResizeObservable = exports.PerformanceObservable = exports.MutationObservable = exports.IntersectionObservable = exports._DOMObserverObservable = void 0;

var _assert = _interopRequireDefault(require("assert"));

var _os = _interopRequireDefault(require("os"));

var _rxjsCompatUmdMin = require("rxjs-compat/bundles/rxjs-compat.umd.min.js");

var _shallowequal = _interopRequireDefault(require("shallowequal"));

var _collection = require("@atom-ide-community/nuclide-commons/collection");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */

/* eslint-env browser */

/* global IntersectionObserver, PerformanceObserver, ResizeObserver, DOMRect */

/**
 * Creates an observable sequence from a DOM-style Observer.
 *
 * **Use this sparingly: prefer to use the extended, specialized classes below
 *   or add a new one below when a new DOM-style Observer comes along*
 *
 * Emits the same array or EntryList (as with PerformanceObservers) as the
 * original DOM Observable.
 *
 * Known to work with DOM `MutationObserver`, `IntersectionObserver`,
 * `ResizeObserver`, and `PerformanceObserver`
 *
 * A DOM-style Observer is defined as implementing the `DOMObserver` interface
 * below. Here's an example with `MutationObserver`:
 *
 *   const mutations = DOMObserverObservable.create(
 *    MutationObserver,
 *    document.getElementById('bar'),
 *    { attributes: true, childList: true, characterData: true }
 *   );
 *
 *   mutations.subscribe(record => console.log(record));
 *
 * This emits and logs each batch of MutationRecords unmodified as an array. To
 * emit and log each record individually on the observable, call
 * `.flattenEntries()` before subscribing:
 *
 *   const mutations = DOMObserverObservable.create(
 *    MutationObserver,
 *    document.getElementById('bar'),
 *    { attributes: true, childList: true, characterData: true }
 *   ).flattenEntries();
 *
 *   mutations.subscribe(record => console.log(record));
 *
 * This results in MutationRecord objects emitted *individually* and
 * synchonrously every time a mutation occurs.
 *
 * To add additional observations to the observable, use `observe`:
 *
 *   const mutations = DOMObserverObservable.create(MutationObserver)
 *      .observe(
 *        document.getElementById('bar'),
 *        {attributes: true, childList: true, characterData: true}
 *      )
 *      .observe(
 *        document.getElementById('bar'),
 *        {attributes: true}
 *      )
 *      .flattenEntries();
 *
 *   mutations.subscribe(record => console.log(record));
 */
// A bug in Chrome < 62 frees PerformanceObservers and their listeners
// once the PerformanceObserver is eligible for GC:
// https://bugs.chromium.org/p/chromium/issues/detail?id=742530
//
// This means that callbacks for a PerformanceObserver will stop getting called
// (and themselves GCed) at an abitrary time.
//
// Intentionally hold references to all DOM Observers in this set, and delete
// them when the last subscriber unsubscribes.
const observers = new Set(); // $FlowFixMe(>=0.55.0) Flow suppress

class DOMObserverObservable extends _rxjsCompatUmdMin.Observable {
  constructor(DOMObserverCtor, ...observeArgs) {
    super();
    this._DOMObserverCtor = void 0;
    this._observations = [];
    this._domObserver = void 0;
    this._refs = 0;
    this._DOMObserverCtor = DOMObserverCtor;

    if (observeArgs.length > 0) {
      this.observe(...observeArgs);
    }
  }

  lift(operator) {
    const Constructor = this.constructor;
    const [firstObservation, ...restObservations] = this._observations;
    const obs = new Constructor(this._DOMObserverCtor, ...firstObservation);

    for (const observation of restObservations) {
      obs.observe(...observation);
    }

    obs.source = this;
    obs.operator = operator;
    return obs;
  }

  observe(...observeArgs) {
    this._observations.push(observeArgs);

    if (this._domObserver != null) {
      this._domObserver.observe(...observeArgs);
    }
  }

  unobserve(...unobserveArgs) {
    if (this._domObserver != null && this._domObserver.unobserve == null) {
      throw new Error(`Cannot unobserve: This observable has an active ${this._DOMObserverCtor.name} and it does not support unobserve`);
    }

    for (let i = 0; i < this._observations.length; i++) {
      if ((0, _shallowequal.default)(this._observations[i], unobserveArgs)) {
        this._observations.splice(i, 1);

        break;
      }
    }

    if (this._domObserver != null && this._domObserver.unobserve != null) {
      this._domObserver.unobserve(...unobserveArgs);
    }
  }

  flattenEntries() {
    return this.mergeMap(records => {
      if ((0, _collection.isIterable)(records)) {
        // $FlowFixMe
        return _rxjsCompatUmdMin.Observable.from(records); // $FlowFixMe
      } else if (typeof records.getEntries === 'function') {
        return _rxjsCompatUmdMin.Observable.from(records.getEntries());
      }

      return _rxjsCompatUmdMin.Observable.throw(new Error('Tried to merge DOM Observer entries, but they were not iterable nor were they an EntryList.'));
    });
  }

  _subscribe(subscriber) {
    if (this._refs === 0) {
      (0, _assert.default)(this._domObserver == null);
      this._domObserver = new this._DOMObserverCtor(records => {
        subscriber.next(records);
      });

      for (const observation of this._observations) {
        this._domObserver.observe(...observation);
      }

      observers.add(this._domObserver);
    }

    const subscription = new _rxjsCompatUmdMin.Subscription();
    this._refs++;
    subscription.add(() => {
      this._refs--; // the underlying observer should only disconnect when all subscribers have
      // unsubscribed

      if (this._refs === 0) {
        (0, _assert.default)(this._domObserver != null);

        this._domObserver.disconnect();

        this._domObserver = null;
        observers.delete(this._domObserver);
      }
    });
    return subscription;
  }

}

const _DOMObserverObservable = DOMObserverObservable;
/**
 * Returns an RxJS Observable that wraps an IntersectionObserver
 */

exports._DOMObserverObservable = _DOMObserverObservable;

class IntersectionObservable extends DOMObserverObservable {
  constructor(target) {
    (0, _assert.default)( // eslint-disable-next-line eqeqeq
    global.IntersectionObserver !== null, 'environment must contain IntersectionObserver'); // $FlowFixMe(>=0.55.0) Flow suppress

    super(IntersectionObserver, target);
  }

}
/**
 * Returns an RxJS Observable that wraps a MutationObserver
 */


exports.IntersectionObservable = IntersectionObservable;

class MutationObservable extends DOMObserverObservable {
  constructor(target, options) {
    (0, _assert.default)( // eslint-disable-next-line eqeqeq
    global.MutationObserver !== null, 'environment must contain MutationObserver'); // $FlowFixMe(>=0.55.0) Flow suppress

    super(MutationObserver, target, options);
  }

}
/**
 * Returns an RxJS Observable that wraps a PerformanceObserver
 */


exports.MutationObservable = MutationObservable;

class PerformanceObservable extends DOMObserverObservable {
  constructor(options) {
    (0, _assert.default)( // eslint-disable-next-line eqeqeq
    global.PerformanceObserver !== null, 'environment must contain PerformanceObserver'); // $FlowFixMe(>=0.55.0) Flow suppress

    super(PerformanceObserver, options);
  }

}
/**
 * Returns an RxJS Observable that wraps a ResizeObserver
 */


exports.PerformanceObservable = PerformanceObservable;

class ResizeObservable extends DOMObserverObservable {
  constructor(target) {
    (0, _assert.default)( // eslint-disable-next-line eqeqeq
    global.ResizeObserver !== null, 'environment must contain ResizeObserver');

    if (_os.default.platform() === 'win32' || _os.default.platform() === 'linux') {
      super(WindowsResizeMeasurementPatchingObserver, target);
    } else {
      // $FlowFixMe(>=0.55.0) Flow suppress
      super(ResizeObserver, target);
    }
  }

}

exports.ResizeObservable = ResizeObservable;

function lastRectPerTarget(entries) {
  const rectMap = new Map();
  entries.forEach(entry => rectMap.set(entry.target, entry.contentRect));
  return rectMap;
}

function remeasureContentRect(element, contentRect) {
  const {
    clientHeight,
    clientWidth
  } = element; // Client height/width include padding
  // https://developer.mozilla.org/en-US/docs/Web/API/Element/clientWidth
  // We have to strip it to obtain result similar to what the original computed style provided

  const computedStyle = window.getComputedStyle(element);
  const {
    paddingLeft,
    paddingRight,
    paddingTop,
    paddingBottom
  } = computedStyle;
  const height = clientHeight - parseFloat(paddingTop) - parseFloat(paddingBottom);
  const width = clientWidth - parseFloat(paddingLeft) - parseFloat(paddingRight);
  return new DOMRectReadOnly(contentRect.x, contentRect.y, width, height);
}
/*
 * The values provided by the ResizeOverver on Windows do not seem to reflect the actual size
 * of the element (!!!), so we need to "fix" them before passing on to the downstream subscriber
 * We're wrapping the ResizeObserver instance and are patching the last result of the array with
 * a set of custom measured values
 */


class WindowsResizeMeasurementPatchingObserver {
  constructor(callback, ...rest) {
    this._resizeObserver = void 0;

    const remeasuringCallback = entries => {
      const rebuiltEntries = [];
      const mappedRects = lastRectPerTarget(entries);
      mappedRects.forEach((originalRect, target) => {
        const contentRect = remeasureContentRect(target, originalRect);
        rebuiltEntries.push({
          target,
          contentRect
        });
      });
      callback(rebuiltEntries);
    };

    this._resizeObserver = new ResizeObserver(remeasuringCallback, ...rest); // To make flow happy

    return this;
  }

  observe(...observeArgs) {
    this._resizeObserver.observe(...observeArgs);
  }

  disconnect() {
    this._resizeObserver.disconnect();
  }

  unobserve(...unobserveArgs) {
    if (typeof this._resizeObserver.unobserve === 'function') {
      this._resizeObserver.unobserve(...unobserveArgs);
    }
  }

}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zLXVpL29ic2VydmFibGUtZG9tLmpzIl0sIm5hbWVzIjpbIm9ic2VydmVycyIsIlNldCIsIkRPTU9ic2VydmVyT2JzZXJ2YWJsZSIsIk9ic2VydmFibGUiLCJjb25zdHJ1Y3RvciIsIkRPTU9ic2VydmVyQ3RvciIsIm9ic2VydmVBcmdzIiwiX0RPTU9ic2VydmVyQ3RvciIsIl9vYnNlcnZhdGlvbnMiLCJfZG9tT2JzZXJ2ZXIiLCJfcmVmcyIsImxlbmd0aCIsIm9ic2VydmUiLCJsaWZ0Iiwib3BlcmF0b3IiLCJDb25zdHJ1Y3RvciIsImZpcnN0T2JzZXJ2YXRpb24iLCJyZXN0T2JzZXJ2YXRpb25zIiwib2JzIiwib2JzZXJ2YXRpb24iLCJzb3VyY2UiLCJwdXNoIiwidW5vYnNlcnZlIiwidW5vYnNlcnZlQXJncyIsIkVycm9yIiwibmFtZSIsImkiLCJzcGxpY2UiLCJmbGF0dGVuRW50cmllcyIsIm1lcmdlTWFwIiwicmVjb3JkcyIsImZyb20iLCJnZXRFbnRyaWVzIiwidGhyb3ciLCJfc3Vic2NyaWJlIiwic3Vic2NyaWJlciIsIm5leHQiLCJhZGQiLCJzdWJzY3JpcHRpb24iLCJTdWJzY3JpcHRpb24iLCJkaXNjb25uZWN0IiwiZGVsZXRlIiwiX0RPTU9ic2VydmVyT2JzZXJ2YWJsZSIsIkludGVyc2VjdGlvbk9ic2VydmFibGUiLCJ0YXJnZXQiLCJnbG9iYWwiLCJJbnRlcnNlY3Rpb25PYnNlcnZlciIsIk11dGF0aW9uT2JzZXJ2YWJsZSIsIm9wdGlvbnMiLCJNdXRhdGlvbk9ic2VydmVyIiwiUGVyZm9ybWFuY2VPYnNlcnZhYmxlIiwiUGVyZm9ybWFuY2VPYnNlcnZlciIsIlJlc2l6ZU9ic2VydmFibGUiLCJSZXNpemVPYnNlcnZlciIsIm9zIiwicGxhdGZvcm0iLCJXaW5kb3dzUmVzaXplTWVhc3VyZW1lbnRQYXRjaGluZ09ic2VydmVyIiwibGFzdFJlY3RQZXJUYXJnZXQiLCJlbnRyaWVzIiwicmVjdE1hcCIsIk1hcCIsImZvckVhY2giLCJlbnRyeSIsInNldCIsImNvbnRlbnRSZWN0IiwicmVtZWFzdXJlQ29udGVudFJlY3QiLCJlbGVtZW50IiwiY2xpZW50SGVpZ2h0IiwiY2xpZW50V2lkdGgiLCJjb21wdXRlZFN0eWxlIiwid2luZG93IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInBhZGRpbmdMZWZ0IiwicGFkZGluZ1JpZ2h0IiwicGFkZGluZ1RvcCIsInBhZGRpbmdCb3R0b20iLCJoZWlnaHQiLCJwYXJzZUZsb2F0Iiwid2lkdGgiLCJET01SZWN0UmVhZE9ubHkiLCJ4IiwieSIsImNhbGxiYWNrIiwicmVzdCIsIl9yZXNpemVPYnNlcnZlciIsInJlbWVhc3VyaW5nQ2FsbGJhY2siLCJyZWJ1aWx0RW50cmllcyIsIm1hcHBlZFJlY3RzIiwib3JpZ2luYWxSZWN0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBZUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFuQkE7Ozs7Ozs7Ozs7OztBQVlBOztBQUNBOztBQVFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNQSxTQUFTLEdBQUcsSUFBSUMsR0FBSixFQUFsQixDLENBRUE7O0FBU0EsTUFBTUMscUJBQU4sU0FJVUMsNEJBSlYsQ0FJNEI7QUFNMUJDLEVBQUFBLFdBQVcsQ0FDVEMsZUFEUyxFQUVULEdBQUdDLFdBRk0sRUFHSDtBQUNOO0FBRE0sU0FSUkMsZ0JBUVE7QUFBQSxTQVBSQyxhQU9RLEdBUDZCLEVBTzdCO0FBQUEsU0FOUkMsWUFNUTtBQUFBLFNBTFJDLEtBS1EsR0FMUSxDQUtSO0FBRU4sU0FBS0gsZ0JBQUwsR0FBd0JGLGVBQXhCOztBQUNBLFFBQUlDLFdBQVcsQ0FBQ0ssTUFBWixHQUFxQixDQUF6QixFQUE0QjtBQUMxQixXQUFLQyxPQUFMLENBQWEsR0FBR04sV0FBaEI7QUFDRDtBQUNG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RixlQUFMLEdBQXVCLElBQUkvQixjQUFKLENBQW1CZ0MsbUJBQW5CLEVBQXdDLEdBQUdGLElBQTNDLENBQXZCLENBWHNFLENBYXRFOztBQUNBLFdBQU8sSUFBUDtBQUNEOztBQUVEdkUsRUFBQUEsT0FBTyxDQUFDLEdBQUdOLFdBQUosRUFBbUM7QUFDeEMsU0FBSzhFLGVBQUwsQ0FBcUJ4RSxPQUFyQixDQUE2QixHQUFHTixXQUFoQztBQUNEOztBQUVEa0MsRUFBQUEsVUFBVSxHQUFTO0FBQ2pCLFNBQUs0QyxlQUFMLENBQXFCNUMsVUFBckI7QUFDRDs7QUFFRGxCLEVBQUFBLFNBQVMsQ0FBQyxHQUFHQyxhQUFKLEVBQXFDO0FBQzVDLFFBQUksT0FBTyxLQUFLNkQsZUFBTCxDQUFxQjlELFNBQTVCLEtBQTBDLFVBQTlDLEVBQTBEO0FBQ3hELFdBQUs4RCxlQUFMLENBQXFCOUQsU0FBckIsQ0FBK0IsR0FBR0MsYUFBbEM7QUFDRDtBQUNGOztBQWhDbUUiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIEBmbG93XHJcbiAqIEBmb3JtYXRcclxuICovXHJcblxyXG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cclxuLyogZ2xvYmFsIEludGVyc2VjdGlvbk9ic2VydmVyLCBQZXJmb3JtYW5jZU9ic2VydmVyLCBSZXNpemVPYnNlcnZlciwgRE9NUmVjdCAqL1xyXG5cclxuaW1wb3J0IGludmFyaWFudCBmcm9tICdhc3NlcnQnO1xyXG5pbXBvcnQgb3MgZnJvbSAnb3MnO1xyXG5pbXBvcnQge09ic2VydmFibGUsIFN1YnNjcmlwdGlvbn0gZnJvbSAncnhqcy1jb21wYXQvYnVuZGxlcy9yeGpzLWNvbXBhdC51bWQubWluLmpzJztcclxuaW1wb3J0IHNoYWxsb3dFcXVhbCBmcm9tICdzaGFsbG93ZXF1YWwnO1xyXG5pbXBvcnQge2lzSXRlcmFibGV9IGZyb20gJ0BhdG9tLWlkZS1jb21tdW5pdHkvbnVjbGlkZS1jb21tb25zL2NvbGxlY3Rpb24nO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBmcm9tIGEgRE9NLXN0eWxlIE9ic2VydmVyLlxyXG4gKlxyXG4gKiAqKlVzZSB0aGlzIHNwYXJpbmdseTogcHJlZmVyIHRvIHVzZSB0aGUgZXh0ZW5kZWQsIHNwZWNpYWxpemVkIGNsYXNzZXMgYmVsb3dcclxuICogICBvciBhZGQgYSBuZXcgb25lIGJlbG93IHdoZW4gYSBuZXcgRE9NLXN0eWxlIE9ic2VydmVyIGNvbWVzIGFsb25nKlxyXG4gKlxyXG4gKiBFbWl0cyB0aGUgc2FtZSBhcnJheSBvciBFbnRyeUxpc3QgKGFzIHdpdGggUGVyZm9ybWFuY2VPYnNlcnZlcnMpIGFzIHRoZVxyXG4gKiBvcmlnaW5hbCBET00gT2JzZXJ2YWJsZS5cclxuICpcclxuICogS25vd24gdG8gd29yayB3aXRoIERPTSBgTXV0YXRpb25PYnNlcnZlcmAsIGBJbnRlcnNlY3Rpb25PYnNlcnZlcmAsXHJcbiAqIGBSZXNpemVPYnNlcnZlcmAsIGFuZCBgUGVyZm9ybWFuY2VPYnNlcnZlcmBcclxuICpcclxuICogQSBET00tc3R5bGUgT2JzZXJ2ZXIgaXMgZGVmaW5lZCBhcyBpbXBsZW1lbnRpbmcgdGhlIGBET01PYnNlcnZlcmAgaW50ZXJmYWNlXHJcbiAqIGJlbG93LiBIZXJlJ3MgYW4gZXhhbXBsZSB3aXRoIGBNdXRhdGlvbk9ic2VydmVyYDpcclxuICpcclxuICogICBjb25zdCBtdXRhdGlvbnMgPSBET01PYnNlcnZlck9ic2VydmFibGUuY3JlYXRlKFxyXG4gKiAgICBNdXRhdGlvbk9ic2VydmVyLFxyXG4gKiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYmFyJyksXHJcbiAqICAgIHsgYXR0cmlidXRlczogdHJ1ZSwgY2hpbGRMaXN0OiB0cnVlLCBjaGFyYWN0ZXJEYXRhOiB0cnVlIH1cclxuICogICApO1xyXG4gKlxyXG4gKiAgIG11dGF0aW9ucy5zdWJzY3JpYmUocmVjb3JkID0+IGNvbnNvbGUubG9nKHJlY29yZCkpO1xyXG4gKlxyXG4gKiBUaGlzIGVtaXRzIGFuZCBsb2dzIGVhY2ggYmF0Y2ggb2YgTXV0YXRpb25SZWNvcmRzIHVubW9kaWZpZWQgYXMgYW4gYXJyYXkuIFRvXHJcbiAqIGVtaXQgYW5kIGxvZyBlYWNoIHJlY29yZCBpbmRpdmlkdWFsbHkgb24gdGhlIG9ic2VydmFibGUsIGNhbGxcclxuICogYC5mbGF0dGVuRW50cmllcygpYCBiZWZvcmUgc3Vic2NyaWJpbmc6XHJcbiAqXHJcbiAqICAgY29uc3QgbXV0YXRpb25zID0gRE9NT2JzZXJ2ZXJPYnNlcnZhYmxlLmNyZWF0ZShcclxuICogICAgTXV0YXRpb25PYnNlcnZlcixcclxuICogICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2JhcicpLFxyXG4gKiAgICB7IGF0dHJpYnV0ZXM6IHRydWUsIGNoaWxkTGlzdDogdHJ1ZSwgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9XHJcbiAqICAgKS5mbGF0dGVuRW50cmllcygpO1xyXG4gKlxyXG4gKiAgIG11dGF0aW9ucy5zdWJzY3JpYmUocmVjb3JkID0+IGNvbnNvbGUubG9nKHJlY29yZCkpO1xyXG4gKlxyXG4gKiBUaGlzIHJlc3VsdHMgaW4gTXV0YXRpb25SZWNvcmQgb2JqZWN0cyBlbWl0dGVkICppbmRpdmlkdWFsbHkqIGFuZFxyXG4gKiBzeW5jaG9ucm91c2x5IGV2ZXJ5IHRpbWUgYSBtdXRhdGlvbiBvY2N1cnMuXHJcbiAqXHJcbiAqIFRvIGFkZCBhZGRpdGlvbmFsIG9ic2VydmF0aW9ucyB0byB0aGUgb2JzZXJ2YWJsZSwgdXNlIGBvYnNlcnZlYDpcclxuICpcclxuICogICBjb25zdCBtdXRhdGlvbnMgPSBET01PYnNlcnZlck9ic2VydmFibGUuY3JlYXRlKE11dGF0aW9uT2JzZXJ2ZXIpXHJcbiAqICAgICAgLm9ic2VydmUoXHJcbiAqICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYmFyJyksXHJcbiAqICAgICAgICB7YXR0cmlidXRlczogdHJ1ZSwgY2hpbGRMaXN0OiB0cnVlLCBjaGFyYWN0ZXJEYXRhOiB0cnVlfVxyXG4gKiAgICAgIClcclxuICogICAgICAub2JzZXJ2ZShcclxuICogICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdiYXInKSxcclxuICogICAgICAgIHthdHRyaWJ1dGVzOiB0cnVlfVxyXG4gKiAgICAgIClcclxuICogICAgICAuZmxhdHRlbkVudHJpZXMoKTtcclxuICpcclxuICogICBtdXRhdGlvbnMuc3Vic2NyaWJlKHJlY29yZCA9PiBjb25zb2xlLmxvZyhyZWNvcmQpKTtcclxuICovXHJcblxyXG4vLyBBIGJ1ZyBpbiBDaHJvbWUgPCA2MiBmcmVlcyBQZXJmb3JtYW5jZU9ic2VydmVycyBhbmQgdGhlaXIgbGlzdGVuZXJzXHJcbi8vIG9uY2UgdGhlIFBlcmZvcm1hbmNlT2JzZXJ2ZXIgaXMgZWxpZ2libGUgZm9yIEdDOlxyXG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD03NDI1MzBcclxuLy9cclxuLy8gVGhpcyBtZWFucyB0aGF0IGNhbGxiYWNrcyBmb3IgYSBQZXJmb3JtYW5jZU9ic2VydmVyIHdpbGwgc3RvcCBnZXR0aW5nIGNhbGxlZFxyXG4vLyAoYW5kIHRoZW1zZWx2ZXMgR0NlZCkgYXQgYW4gYWJpdHJhcnkgdGltZS5cclxuLy9cclxuLy8gSW50ZW50aW9uYWxseSBob2xkIHJlZmVyZW5jZXMgdG8gYWxsIERPTSBPYnNlcnZlcnMgaW4gdGhpcyBzZXQsIGFuZCBkZWxldGVcclxuLy8gdGhlbSB3aGVuIHRoZSBsYXN0IHN1YnNjcmliZXIgdW5zdWJzY3JpYmVzLlxyXG5jb25zdCBvYnNlcnZlcnMgPSBuZXcgU2V0KCk7XHJcblxyXG4vLyAkRmxvd0ZpeE1lKD49MC41NS4wKSBGbG93IHN1cHByZXNzXHJcbnR5cGUgUmVjb3JkQ2FsbGJhY2sgPSAocmVjb3JkczogYW55LCAuLi5yZXN0OiBBcnJheTxhbnk+KSA9PiBtaXhlZDtcclxuaW50ZXJmYWNlIERPTU9ic2VydmVyIHtcclxuICBjb25zdHJ1Y3RvcihjYWxsYmFjazogUmVjb3JkQ2FsbGJhY2ssIC4uLnJlc3Q6IEFycmF5PGFueT4pOiBET01PYnNlcnZlcjtcclxuICBvYnNlcnZlKC4uLm9ic2VydmVBcmdzOiBBcnJheTxhbnk+KTogdm9pZDtcclxuICBkaXNjb25uZWN0KCk6IHZvaWQ7XHJcbiAgK3Vub2JzZXJ2ZT86ICguLi51bm9ic2VydmVBcmdzOiBBcnJheTxhbnk+KSA9PiB2b2lkO1xyXG59XHJcblxyXG5jbGFzcyBET01PYnNlcnZlck9ic2VydmFibGU8XHJcbiAgVE5leHQsIC8vIHdoYXQgZG9lcyB0aGlzIG9ic2VydmFibGUgYG5leHQoKWA/XHJcbiAgVEVudHJ5LCAvLyB3aGF0IGlzIGFuIGluZGl2aWR1YWwgZW50cnk/XHJcbiAgVE9ic2VydmVBcmdzOiAkUmVhZE9ubHlBcnJheTxhbnk+LCAvLyB3aGF0IGFyZSB0aGUgYXJndW1lbnRzIHRvIGBvYnNlcnZlKClgIGFuZCBgdW5vYnNlcnZlYCgpP1xyXG4+IGV4dGVuZHMgT2JzZXJ2YWJsZTxUTmV4dD4ge1xyXG4gIF9ET01PYnNlcnZlckN0b3I6IENsYXNzPERPTU9ic2VydmVyPjtcclxuICBfb2JzZXJ2YXRpb25zOiBBcnJheTxUT2JzZXJ2ZUFyZ3M+ID0gW107XHJcbiAgX2RvbU9ic2VydmVyOiA/RE9NT2JzZXJ2ZXI7XHJcbiAgX3JlZnM6IG51bWJlciA9IDA7XHJcblxyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgRE9NT2JzZXJ2ZXJDdG9yOiBDbGFzczxET01PYnNlcnZlcj4sXHJcbiAgICAuLi5vYnNlcnZlQXJnczogVE9ic2VydmVBcmdzXHJcbiAgKTogdm9pZCB7XHJcbiAgICBzdXBlcigpO1xyXG4gICAgdGhpcy5fRE9NT2JzZXJ2ZXJDdG9yID0gRE9NT2JzZXJ2ZXJDdG9yO1xyXG4gICAgaWYgKG9ic2VydmVBcmdzLmxlbmd0aCA+IDApIHtcclxuICAgICAgdGhpcy5vYnNlcnZlKC4uLm9ic2VydmVBcmdzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGxpZnQ8Uj4ob3BlcmF0b3I6IHJ4anMkT3BlcmF0b3I8VE5leHQsIFI+KTogdGhpcyB7XHJcbiAgICBjb25zdCBDb25zdHJ1Y3RvciA9IHRoaXMuY29uc3RydWN0b3I7XHJcbiAgICBjb25zdCBbZmlyc3RPYnNlcnZhdGlvbiwgLi4ucmVzdE9ic2VydmF0aW9uc10gPSB0aGlzLl9vYnNlcnZhdGlvbnM7XHJcbiAgICBjb25zdCBvYnMgPSBuZXcgQ29uc3RydWN0b3IodGhpcy5fRE9NT2JzZXJ2ZXJDdG9yLCAuLi5maXJzdE9ic2VydmF0aW9uKTtcclxuICAgIGZvciAoY29uc3Qgb2JzZXJ2YXRpb24gb2YgcmVzdE9ic2VydmF0aW9ucykge1xyXG4gICAgICBvYnMub2JzZXJ2ZSguLi5vYnNlcnZhdGlvbik7XHJcbiAgICB9XHJcbiAgICBvYnMuc291cmNlID0gdGhpcztcclxuICAgIG9icy5vcGVyYXRvciA9IG9wZXJhdG9yO1xyXG4gICAgcmV0dXJuIG9icztcclxuICB9XHJcblxyXG4gIG9ic2VydmUoLi4ub2JzZXJ2ZUFyZ3M6IFRPYnNlcnZlQXJncyk6IHZvaWQge1xyXG4gICAgdGhpcy5fb2JzZXJ2YXRpb25zLnB1c2gob2JzZXJ2ZUFyZ3MpO1xyXG5cclxuICAgIGlmICh0aGlzLl9kb21PYnNlcnZlciAhPSBudWxsKSB7XHJcbiAgICAgIHRoaXMuX2RvbU9ic2VydmVyLm9ic2VydmUoLi4ub2JzZXJ2ZUFyZ3MpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdW5vYnNlcnZlKC4uLnVub2JzZXJ2ZUFyZ3M6IFRPYnNlcnZlQXJncyk6IHZvaWQge1xyXG4gICAgaWYgKHRoaXMuX2RvbU9ic2VydmVyICE9IG51bGwgJiYgdGhpcy5fZG9tT2JzZXJ2ZXIudW5vYnNlcnZlID09IG51bGwpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGBDYW5ub3QgdW5vYnNlcnZlOiBUaGlzIG9ic2VydmFibGUgaGFzIGFuIGFjdGl2ZSAke1xyXG4gICAgICAgICAgdGhpcy5fRE9NT2JzZXJ2ZXJDdG9yLm5hbWVcclxuICAgICAgICB9IGFuZCBpdCBkb2VzIG5vdCBzdXBwb3J0IHVub2JzZXJ2ZWAsXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9vYnNlcnZhdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKHNoYWxsb3dFcXVhbCh0aGlzLl9vYnNlcnZhdGlvbnNbaV0sIHVub2JzZXJ2ZUFyZ3MpKSB7XHJcbiAgICAgICAgdGhpcy5fb2JzZXJ2YXRpb25zLnNwbGljZShpLCAxKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9kb21PYnNlcnZlciAhPSBudWxsICYmIHRoaXMuX2RvbU9ic2VydmVyLnVub2JzZXJ2ZSAhPSBudWxsKSB7XHJcbiAgICAgIHRoaXMuX2RvbU9ic2VydmVyLnVub2JzZXJ2ZSguLi51bm9ic2VydmVBcmdzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZsYXR0ZW5FbnRyaWVzKCk6IE9ic2VydmFibGU8VEVudHJ5PiB7XHJcbiAgICByZXR1cm4gdGhpcy5tZXJnZU1hcChyZWNvcmRzID0+IHtcclxuICAgICAgaWYgKGlzSXRlcmFibGUocmVjb3JkcykpIHtcclxuICAgICAgICAvLyAkRmxvd0ZpeE1lXHJcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGUuZnJvbShyZWNvcmRzKTtcclxuICAgICAgICAvLyAkRmxvd0ZpeE1lXHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlY29yZHMuZ2V0RW50cmllcyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHJldHVybiBPYnNlcnZhYmxlLmZyb20ocmVjb3Jkcy5nZXRFbnRyaWVzKCkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gT2JzZXJ2YWJsZS50aHJvdyhcclxuICAgICAgICBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAnVHJpZWQgdG8gbWVyZ2UgRE9NIE9ic2VydmVyIGVudHJpZXMsIGJ1dCB0aGV5IHdlcmUgbm90IGl0ZXJhYmxlIG5vciB3ZXJlIHRoZXkgYW4gRW50cnlMaXN0LicsXHJcbiAgICAgICAgKSxcclxuICAgICAgKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgX3N1YnNjcmliZShzdWJzY3JpYmVyOiByeGpzJFN1YnNjcmliZXI8VE5leHQ+KTogcnhqcyRTdWJzY3JpcHRpb24ge1xyXG4gICAgaWYgKHRoaXMuX3JlZnMgPT09IDApIHtcclxuICAgICAgaW52YXJpYW50KHRoaXMuX2RvbU9ic2VydmVyID09IG51bGwpO1xyXG4gICAgICB0aGlzLl9kb21PYnNlcnZlciA9IG5ldyB0aGlzLl9ET01PYnNlcnZlckN0b3IocmVjb3JkcyA9PiB7XHJcbiAgICAgICAgc3Vic2NyaWJlci5uZXh0KHJlY29yZHMpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGZvciAoY29uc3Qgb2JzZXJ2YXRpb24gb2YgdGhpcy5fb2JzZXJ2YXRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5fZG9tT2JzZXJ2ZXIub2JzZXJ2ZSguLi5vYnNlcnZhdGlvbik7XHJcbiAgICAgIH1cclxuICAgICAgb2JzZXJ2ZXJzLmFkZCh0aGlzLl9kb21PYnNlcnZlcik7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbigpO1xyXG4gICAgdGhpcy5fcmVmcysrO1xyXG4gICAgc3Vic2NyaXB0aW9uLmFkZCgoKSA9PiB7XHJcbiAgICAgIHRoaXMuX3JlZnMtLTtcclxuXHJcbiAgICAgIC8vIHRoZSB1bmRlcmx5aW5nIG9ic2VydmVyIHNob3VsZCBvbmx5IGRpc2Nvbm5lY3Qgd2hlbiBhbGwgc3Vic2NyaWJlcnMgaGF2ZVxyXG4gICAgICAvLyB1bnN1YnNjcmliZWRcclxuICAgICAgaWYgKHRoaXMuX3JlZnMgPT09IDApIHtcclxuICAgICAgICBpbnZhcmlhbnQodGhpcy5fZG9tT2JzZXJ2ZXIgIT0gbnVsbCk7XHJcbiAgICAgICAgdGhpcy5fZG9tT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgIHRoaXMuX2RvbU9ic2VydmVyID0gbnVsbDtcclxuICAgICAgICBvYnNlcnZlcnMuZGVsZXRlKHRoaXMuX2RvbU9ic2VydmVyKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBfRE9NT2JzZXJ2ZXJPYnNlcnZhYmxlID0gRE9NT2JzZXJ2ZXJPYnNlcnZhYmxlO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gUnhKUyBPYnNlcnZhYmxlIHRoYXQgd3JhcHMgYW4gSW50ZXJzZWN0aW9uT2JzZXJ2ZXJcclxuICovXHJcbmV4cG9ydCBjbGFzcyBJbnRlcnNlY3Rpb25PYnNlcnZhYmxlIGV4dGVuZHMgRE9NT2JzZXJ2ZXJPYnNlcnZhYmxlPFxyXG4gIEFycmF5PEludGVyc2VjdGlvbk9ic2VydmVyRW50cnk+LFxyXG4gIEludGVyc2VjdGlvbk9ic2VydmVyRW50cnksXHJcbiAgW0hUTUxFbGVtZW50XSxcclxuPiB7XHJcbiAgY29uc3RydWN0b3IodGFyZ2V0OiBIVE1MRWxlbWVudCkge1xyXG4gICAgaW52YXJpYW50KFxyXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXHJcbiAgICAgIGdsb2JhbC5JbnRlcnNlY3Rpb25PYnNlcnZlciAhPT0gbnVsbCxcclxuICAgICAgJ2Vudmlyb25tZW50IG11c3QgY29udGFpbiBJbnRlcnNlY3Rpb25PYnNlcnZlcicsXHJcbiAgICApO1xyXG4gICAgLy8gJEZsb3dGaXhNZSg+PTAuNTUuMCkgRmxvdyBzdXBwcmVzc1xyXG4gICAgc3VwZXIoSW50ZXJzZWN0aW9uT2JzZXJ2ZXIsIHRhcmdldCk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhbiBSeEpTIE9ic2VydmFibGUgdGhhdCB3cmFwcyBhIE11dGF0aW9uT2JzZXJ2ZXJcclxuICovXHJcbmV4cG9ydCBjbGFzcyBNdXRhdGlvbk9ic2VydmFibGUgZXh0ZW5kcyBET01PYnNlcnZlck9ic2VydmFibGU8XHJcbiAgQXJyYXk8TXV0YXRpb25SZWNvcmQ+LFxyXG4gIE11dGF0aW9uUmVjb3JkLFxyXG4gIFtOb2RlLCBNdXRhdGlvbk9ic2VydmVySW5pdF0sXHJcbj4ge1xyXG4gIGNvbnN0cnVjdG9yKHRhcmdldDogTm9kZSwgb3B0aW9ucz86IE11dGF0aW9uT2JzZXJ2ZXJJbml0KSB7XHJcbiAgICBpbnZhcmlhbnQoXHJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcclxuICAgICAgZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgIT09IG51bGwsXHJcbiAgICAgICdlbnZpcm9ubWVudCBtdXN0IGNvbnRhaW4gTXV0YXRpb25PYnNlcnZlcicsXHJcbiAgICApO1xyXG4gICAgLy8gJEZsb3dGaXhNZSg+PTAuNTUuMCkgRmxvdyBzdXBwcmVzc1xyXG4gICAgc3VwZXIoTXV0YXRpb25PYnNlcnZlciwgdGFyZ2V0LCBvcHRpb25zKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIFJ4SlMgT2JzZXJ2YWJsZSB0aGF0IHdyYXBzIGEgUGVyZm9ybWFuY2VPYnNlcnZlclxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFBlcmZvcm1hbmNlT2JzZXJ2YWJsZSBleHRlbmRzIERPTU9ic2VydmVyT2JzZXJ2YWJsZTxcclxuICBQZXJmb3JtYW5jZU9ic2VydmVyRW50cnlMaXN0LFxyXG4gIFBlcmZvcm1hbmNlRW50cnksXHJcbiAgW1BlcmZvcm1hbmNlT2JzZXJ2ZXJJbml0XSxcclxuPiB7XHJcbiAgY29uc3RydWN0b3Iob3B0aW9uczogUGVyZm9ybWFuY2VPYnNlcnZlckluaXQpIHtcclxuICAgIGludmFyaWFudChcclxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxyXG4gICAgICBnbG9iYWwuUGVyZm9ybWFuY2VPYnNlcnZlciAhPT0gbnVsbCxcclxuICAgICAgJ2Vudmlyb25tZW50IG11c3QgY29udGFpbiBQZXJmb3JtYW5jZU9ic2VydmVyJyxcclxuICAgICk7XHJcbiAgICAvLyAkRmxvd0ZpeE1lKD49MC41NS4wKSBGbG93IHN1cHByZXNzXHJcbiAgICBzdXBlcihQZXJmb3JtYW5jZU9ic2VydmVyLCBvcHRpb25zKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIFJ4SlMgT2JzZXJ2YWJsZSB0aGF0IHdyYXBzIGEgUmVzaXplT2JzZXJ2ZXJcclxuICovXHJcbmV4cG9ydCBjbGFzcyBSZXNpemVPYnNlcnZhYmxlIGV4dGVuZHMgRE9NT2JzZXJ2ZXJPYnNlcnZhYmxlPFxyXG4gIEFycmF5PFJlc2l6ZU9ic2VydmVyRW50cnk+LFxyXG4gIFJlc2l6ZU9ic2VydmVyRW50cnksXHJcbiAgW0hUTUxFbGVtZW50XSxcclxuPiB7XHJcbiAgY29uc3RydWN0b3IodGFyZ2V0OiBIVE1MRWxlbWVudCkge1xyXG4gICAgaW52YXJpYW50KFxyXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXHJcbiAgICAgIGdsb2JhbC5SZXNpemVPYnNlcnZlciAhPT0gbnVsbCxcclxuICAgICAgJ2Vudmlyb25tZW50IG11c3QgY29udGFpbiBSZXNpemVPYnNlcnZlcicsXHJcbiAgICApO1xyXG5cclxuICAgIGlmIChvcy5wbGF0Zm9ybSgpID09PSAnd2luMzInIHx8IG9zLnBsYXRmb3JtKCkgPT09ICdsaW51eCcpIHtcclxuICAgICAgc3VwZXIoV2luZG93c1Jlc2l6ZU1lYXN1cmVtZW50UGF0Y2hpbmdPYnNlcnZlciwgdGFyZ2V0KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vICRGbG93Rml4TWUoPj0wLjU1LjApIEZsb3cgc3VwcHJlc3NcclxuICAgICAgc3VwZXIoUmVzaXplT2JzZXJ2ZXIsIHRhcmdldCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBsYXN0UmVjdFBlclRhcmdldChcclxuICBlbnRyaWVzOiBBcnJheTxSZXNpemVPYnNlcnZlckVudHJ5PixcclxuKTogTWFwPEhUTUxFbGVtZW50LCBET01SZWN0UmVhZE9ubHk+IHtcclxuICBjb25zdCByZWN0TWFwID0gbmV3IE1hcCgpO1xyXG4gIGVudHJpZXMuZm9yRWFjaChlbnRyeSA9PiByZWN0TWFwLnNldChlbnRyeS50YXJnZXQsIGVudHJ5LmNvbnRlbnRSZWN0KSk7XHJcbiAgcmV0dXJuIHJlY3RNYXA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbWVhc3VyZUNvbnRlbnRSZWN0KFxyXG4gIGVsZW1lbnQ6IEhUTUxFbGVtZW50LFxyXG4gIGNvbnRlbnRSZWN0OiBET01SZWN0UmVhZE9ubHksXHJcbik6IERPTVJlY3RSZWFkT25seSB7XHJcbiAgY29uc3Qge2NsaWVudEhlaWdodCwgY2xpZW50V2lkdGh9ID0gZWxlbWVudDtcclxuXHJcbiAgLy8gQ2xpZW50IGhlaWdodC93aWR0aCBpbmNsdWRlIHBhZGRpbmdcclxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9jbGllbnRXaWR0aFxyXG4gIC8vIFdlIGhhdmUgdG8gc3RyaXAgaXQgdG8gb2J0YWluIHJlc3VsdCBzaW1pbGFyIHRvIHdoYXQgdGhlIG9yaWdpbmFsIGNvbXB1dGVkIHN0eWxlIHByb3ZpZGVkXHJcbiAgY29uc3QgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xyXG4gIGNvbnN0IHtwYWRkaW5nTGVmdCwgcGFkZGluZ1JpZ2h0LCBwYWRkaW5nVG9wLCBwYWRkaW5nQm90dG9tfSA9IGNvbXB1dGVkU3R5bGU7XHJcblxyXG4gIGNvbnN0IGhlaWdodCA9XHJcbiAgICBjbGllbnRIZWlnaHQgLSBwYXJzZUZsb2F0KHBhZGRpbmdUb3ApIC0gcGFyc2VGbG9hdChwYWRkaW5nQm90dG9tKTtcclxuICBjb25zdCB3aWR0aCA9XHJcbiAgICBjbGllbnRXaWR0aCAtIHBhcnNlRmxvYXQocGFkZGluZ0xlZnQpIC0gcGFyc2VGbG9hdChwYWRkaW5nUmlnaHQpO1xyXG5cclxuICByZXR1cm4gbmV3IERPTVJlY3RSZWFkT25seShjb250ZW50UmVjdC54LCBjb250ZW50UmVjdC55LCB3aWR0aCwgaGVpZ2h0KTtcclxufVxyXG5cclxuLypcclxuICogVGhlIHZhbHVlcyBwcm92aWRlZCBieSB0aGUgUmVzaXplT3ZlcnZlciBvbiBXaW5kb3dzIGRvIG5vdCBzZWVtIHRvIHJlZmxlY3QgdGhlIGFjdHVhbCBzaXplXHJcbiAqIG9mIHRoZSBlbGVtZW50ICghISEpLCBzbyB3ZSBuZWVkIHRvIFwiZml4XCIgdGhlbSBiZWZvcmUgcGFzc2luZyBvbiB0byB0aGUgZG93bnN0cmVhbSBzdWJzY3JpYmVyXHJcbiAqIFdlJ3JlIHdyYXBwaW5nIHRoZSBSZXNpemVPYnNlcnZlciBpbnN0YW5jZSBhbmQgYXJlIHBhdGNoaW5nIHRoZSBsYXN0IHJlc3VsdCBvZiB0aGUgYXJyYXkgd2l0aFxyXG4gKiBhIHNldCBvZiBjdXN0b20gbWVhc3VyZWQgdmFsdWVzXHJcbiAqL1xyXG5jbGFzcyBXaW5kb3dzUmVzaXplTWVhc3VyZW1lbnRQYXRjaGluZ09ic2VydmVyIGltcGxlbWVudHMgRE9NT2JzZXJ2ZXIge1xyXG4gIF9yZXNpemVPYnNlcnZlcjogUmVzaXplT2JzZXJ2ZXI7XHJcblxyXG4gIGNvbnN0cnVjdG9yKGNhbGxiYWNrOiBSZWNvcmRDYWxsYmFjaywgLi4ucmVzdDogQXJyYXk8YW55Pik6IERPTU9ic2VydmVyIHtcclxuICAgIGNvbnN0IHJlbWVhc3VyaW5nQ2FsbGJhY2sgPSAoZW50cmllczogQXJyYXk8UmVzaXplT2JzZXJ2ZXJFbnRyeT4pOiB2b2lkID0+IHtcclxuICAgICAgY29uc3QgcmVidWlsdEVudHJpZXMgPSBbXTtcclxuICAgICAgY29uc3QgbWFwcGVkUmVjdHMgPSBsYXN0UmVjdFBlclRhcmdldChlbnRyaWVzKTtcclxuICAgICAgbWFwcGVkUmVjdHMuZm9yRWFjaCgob3JpZ2luYWxSZWN0LCB0YXJnZXQpID0+IHtcclxuICAgICAgICBjb25zdCBjb250ZW50UmVjdCA9IHJlbWVhc3VyZUNvbnRlbnRSZWN0KHRhcmdldCwgb3JpZ2luYWxSZWN0KTtcclxuICAgICAgICByZWJ1aWx0RW50cmllcy5wdXNoKHt0YXJnZXQsIGNvbnRlbnRSZWN0fSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgY2FsbGJhY2socmVidWlsdEVudHJpZXMpO1xyXG4gICAgfTtcclxuICAgIHRoaXMuX3Jlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKHJlbWVhc3VyaW5nQ2FsbGJhY2ssIC4uLnJlc3QpO1xyXG5cclxuICAgIC8vIFRvIG1ha2UgZmxvdyBoYXBweVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBvYnNlcnZlKC4uLm9ic2VydmVBcmdzOiBBcnJheTxhbnk+KTogdm9pZCB7XHJcbiAgICB0aGlzLl9yZXNpemVPYnNlcnZlci5vYnNlcnZlKC4uLm9ic2VydmVBcmdzKTtcclxuICB9XHJcblxyXG4gIGRpc2Nvbm5lY3QoKTogdm9pZCB7XHJcbiAgICB0aGlzLl9yZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XHJcbiAgfVxyXG5cclxuICB1bm9ic2VydmUoLi4udW5vYnNlcnZlQXJnczogQXJyYXk8YW55Pik6IHZvaWQge1xyXG4gICAgaWYgKHR5cGVvZiB0aGlzLl9yZXNpemVPYnNlcnZlci51bm9ic2VydmUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhpcy5fcmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKC4uLnVub2JzZXJ2ZUFyZ3MpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iXX0=