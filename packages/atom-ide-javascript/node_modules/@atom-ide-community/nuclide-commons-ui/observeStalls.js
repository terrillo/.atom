"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.intentionallyBlocksInResponseToUserAction = intentionallyBlocksInResponseToUserAction;
exports.default = void 0;

var _assert = _interopRequireDefault(require("assert"));

var _getDisplayName = _interopRequireDefault(require("@atom-ide-community/nuclide-commons/getDisplayName"));

var _electron = require("electron");

var _rxjsCompatUmdMin = require("rxjs-compat/bundles/rxjs-compat.umd.min.js");

var _observableDom = require("./observable-dom");

var _UniversalDisposable = _interopRequireDefault(require("@atom-ide-community/nuclide-commons/UniversalDisposable"));

var _once = _interopRequireDefault(require("@atom-ide-community/nuclide-commons/once"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */

/* eslint-env browser */
(0, _assert.default)(_electron.remote != null); // The startup period naturally causes many event loop blockages.
// Don't start checking blockages until some time has passed.

const BLOCKED_GRACE_PERIOD = 30; // Report all blockages over this threshold.

const BLOCKED_MIN = 100; // Discard overly long blockages as spurious (e.g. computer was asleep)

const BLOCKED_MAX = 60 * 1000; // 1 minute in ms
// Range padding on either side of long task interval.
// If an intentional block timestamp lies in this range,
// we consider it intentional.

const BLOCKED_RANGE_PADDING = 15;
let intentionalBlockTime = 0; // Share + cache the observable.
// $FlowFixMe (>=0.85.0) (T35986896) Flow upgrade suppress

const observeStalls = (0, _once.default)(() => {
  const browserWindow = _electron.remote.getCurrentWindow();

  const onIntentionalBlock = () => {
    intentionalBlockTime = performance.now();
  };

  const blockedEvents = new _observableDom.PerformanceObservable({
    entryTypes: ['longtask']
  }).flattenEntries() // only count if the window is focused when the task ran long
  .filter(() => document.hasFocus()) // discard early longtasks as the app is booting
  .filter(() => process.uptime() > BLOCKED_GRACE_PERIOD) // discard durations that are unrealistically long, or those that aren't
  // meaningful enough
  .filter(entry => entry.duration > BLOCKED_MIN && entry.duration < BLOCKED_MAX) // discard events that result from user interaction actually blocking the
  // thread when there is no other option (e.g. context menus)
  .filter(entry => // did the intentionalblocktime occur between the start and end,
  // accounting for some extra padding?
  !(intentionalBlockTime > entry.startTime - BLOCKED_RANGE_PADDING && intentionalBlockTime < entry.startTime + entry.duration + BLOCKED_RANGE_PADDING));
  return _rxjsCompatUmdMin.Observable.using(() => new _UniversalDisposable.default( // Confirmation dialogs also block the event loop.
  // This typically happens when you're about to close an unsaved file.
  atom.workspace.onWillDestroyPaneItem(onIntentionalBlock), // Electron context menus block the event loop.
  _rxjsCompatUmdMin.Observable.fromEvent(browserWindow, 'context-menu') // There appears to be an race with browser window shutdown where
  // the 'context-menu' event fires after window destruction.
  // Try to prevent this by removing the event on close.
  // https://github.com/facebook/nuclide/issues/1246
  .takeUntil(_rxjsCompatUmdMin.Observable.fromEvent(browserWindow, 'close')).subscribe(onIntentionalBlock)), () => {
    return _rxjsCompatUmdMin.Observable.merge( // kick off subscription with a one-time query on start
    _rxjsCompatUmdMin.Observable.of(document.hasFocus()), _rxjsCompatUmdMin.Observable.fromEvent(browserWindow, 'focus').mapTo(true), _rxjsCompatUmdMin.Observable.fromEvent(browserWindow, 'blur').mapTo(false)).distinctUntilChanged().switchMap(isFocused => isFocused ? blockedEvents : _rxjsCompatUmdMin.Observable.empty()).map(entry => entry.duration);
  }).share();
});
var _default = observeStalls;
/*
 * Often times users take an action and can resonably expect a long, blocking task
 * to run to completion before they can take action again:
 * https://developers.google.com/web/fundamentals/performance/rail#ux
 * This is analagous to a web page or app's initial loading, transitioning to
 * another significant view, etc.
 *
 * This is a decorator that wraps a function that pauses in response to user action,
 * opting it out of stall observation and forwarding any arguments passed and returning
 * the original function's return value.
 *
 * **Use this cautiously and deliberately, only in situations where it is
 * reasonable for a user to expect a pause!**
 *
 * If the action takes longer than 1s, we still record this as a stall, as it
 * fails the RAIL model's definition of responsive loading.
 */

exports.default = _default;

function intentionallyBlocksInResponseToUserAction(fn) {
  const intentionallyBlocks = function (...args) {
    const before = performance.now();
    const ret = fn.apply(this, args);

    if (performance.now() - before < 1000) {
      intentionalBlockTime = before;
    }

    return ret;
  };

  intentionallyBlocks.displayName = `intentionallyBlocks(${(0, _getDisplayName.default)(fn)})`;
  return intentionallyBlocks;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zLXVpL29ic2VydmVTdGFsbHMuanMiXSwibmFtZXMiOlsicmVtb3RlIiwiQkxPQ0tFRF9HUkFDRV9QRVJJT0QiLCJCTE9DS0VEX01JTiIsIkJMT0NLRURfTUFYIiwiQkxPQ0tFRF9SQU5HRV9QQURESU5HIiwiaW50ZW50aW9uYWxCbG9ja1RpbWUiLCJvYnNlcnZlU3RhbGxzIiwiYnJvd3NlcldpbmRvdyIsImdldEN1cnJlbnRXaW5kb3ciLCJvbkludGVudGlvbmFsQmxvY2siLCJwZXJmb3JtYW5jZSIsIm5vdyIsImJsb2NrZWRFdmVudHMiLCJQZXJmb3JtYW5jZU9ic2VydmFibGUiLCJlbnRyeVR5cGVzIiwiZmxhdHRlbkVudHJpZXMiLCJmaWx0ZXIiLCJkb2N1bWVudCIsImhhc0ZvY3VzIiwicHJvY2VzcyIsInVwdGltZSIsImVudHJ5IiwiZHVyYXRpb24iLCJzdGFydFRpbWUiLCJPYnNlcnZhYmxlIiwidXNpbmciLCJVbml2ZXJzYWxEaXNwb3NhYmxlIiwiYXRvbSIsIndvcmtzcGFjZSIsIm9uV2lsbERlc3Ryb3lQYW5lSXRlbSIsImZyb21FdmVudCIsInRha2VVbnRpbCIsInN1YnNjcmliZSIsIm1lcmdlIiwib2YiLCJtYXBUbyIsImRpc3RpbmN0VW50aWxDaGFuZ2VkIiwic3dpdGNoTWFwIiwiaXNGb2N1c2VkIiwiZW1wdHkiLCJtYXAiLCJzaGFyZSIsImludGVudGlvbmFsbHlCbG9ja3NJblJlc3BvbnNlVG9Vc2VyQWN0aW9uIiwiZm4iLCJpbnRlbnRpb25hbGx5QmxvY2tzIiwiYXJncyIsImJlZm9yZSIsInJldCIsImFwcGx5IiwiZGlzcGxheU5hbWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBY0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBQ0E7Ozs7QUFyQkE7Ozs7Ozs7Ozs7OztBQVlBO0FBV0EscUJBQVVBLG9CQUFVLElBQXBCLEUsQ0FFQTtBQUNBOztBQUNBLE1BQU1DLG9C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RUFBZUgsSUFBZixDQUFaOztBQUNBLFFBQUluQyxXQUFXLENBQUNDLEdBQVosS0FBb0JtQyxNQUFwQixHQUE2QixJQUFqQyxFQUF1QztBQUNyQ3pDLE1BQUFBLG9CQUFvQixHQUFHeUMsTUFBdkI7QUFDRDs7QUFFRCxXQUFPQyxHQUFQO0FBQ0QsR0FSRDs7QUFVQUgsRUFBQUEsbUJBQW1CLENBQUNLLFdBQXBCLEdBQW1DLHVCQUFzQiw2QkFDdkROLEVBRHVELENBRXZELEdBRkY7QUFHQSxTQUFPQyxtQkFBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBAZmxvdyBzdHJpY3QtbG9jYWxcclxuICogQGZvcm1hdFxyXG4gKi9cclxuXHJcbi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xyXG5cclxuaW1wb3J0IGludmFyaWFudCBmcm9tICdhc3NlcnQnO1xyXG5pbXBvcnQgZ2V0RGlzcGxheU5hbWUgZnJvbSAnQGF0b20taWRlLWNvbW11bml0eS9udWNsaWRlLWNvbW1vbnMvZ2V0RGlzcGxheU5hbWUnO1xyXG5pbXBvcnQge3JlbW90ZX0gZnJvbSAnZWxlY3Ryb24nO1xyXG5pbXBvcnQge09ic2VydmFibGV9IGZyb20gJ3J4anMtY29tcGF0L2J1bmRsZXMvcnhqcy1jb21wYXQudW1kLm1pbi5qcyc7XHJcbmltcG9ydCB7UGVyZm9ybWFuY2VPYnNlcnZhYmxlfSBmcm9tICcuL29ic2VydmFibGUtZG9tJztcclxuXHJcbmltcG9ydCBVbml2ZXJzYWxEaXNwb3NhYmxlIGZyb20gJ0BhdG9tLWlkZS1jb21tdW5pdHkvbnVjbGlkZS1jb21tb25zL1VuaXZlcnNhbERpc3Bvc2FibGUnO1xyXG5pbXBvcnQgb25jZSBmcm9tICdAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtY29tbW9ucy9vbmNlJztcclxuXHJcbmludmFyaWFudChyZW1vdGUgIT0gbnVsbCk7XHJcblxyXG4vLyBUaGUgc3RhcnR1cCBwZXJpb2QgbmF0dXJhbGx5IGNhdXNlcyBtYW55IGV2ZW50IGxvb3AgYmxvY2thZ2VzLlxyXG4vLyBEb24ndCBzdGFydCBjaGVja2luZyBibG9ja2FnZXMgdW50aWwgc29tZSB0aW1lIGhhcyBwYXNzZWQuXHJcbmNvbnN0IEJMT0NLRURfR1JBQ0VfUEVSSU9EID0gMzA7XHJcbi8vIFJlcG9ydCBhbGwgYmxvY2thZ2VzIG92ZXIgdGhpcyB0aHJlc2hvbGQuXHJcbmNvbnN0IEJMT0NLRURfTUlOID0gMTAwO1xyXG4vLyBEaXNjYXJkIG92ZXJseSBsb25nIGJsb2NrYWdlcyBhcyBzcHVyaW91cyAoZS5nLiBjb21wdXRlciB3YXMgYXNsZWVwKVxyXG5jb25zdCBCTE9DS0VEX01BWCA9IDYwICogMTAwMDsgLy8gMSBtaW51dGUgaW4gbXNcclxuLy8gUmFuZ2UgcGFkZGluZyBvbiBlaXRoZXIgc2lkZSBvZiBsb25nIHRhc2sgaW50ZXJ2YWwuXHJcbi8vIElmIGFuIGludGVudGlvbmFsIGJsb2NrIHRpbWVzdGFtcCBsaWVzIGluIHRoaXMgcmFuZ2UsXHJcbi8vIHdlIGNvbnNpZGVyIGl0IGludGVudGlvbmFsLlxyXG5jb25zdCBCTE9DS0VEX1JBTkdFX1BBRERJTkcgPSAxNTtcclxuXHJcbmxldCBpbnRlbnRpb25hbEJsb2NrVGltZSA9IDA7XHJcblxyXG4vLyBTaGFyZSArIGNhY2hlIHRoZSBvYnNlcnZhYmxlLlxyXG4vLyAkRmxvd0ZpeE1lICg+PTAuODUuMCkgKFQzNTk4Njg5NikgRmxvdyB1cGdyYWRlIHN1cHByZXNzXHJcbmNvbnN0IG9ic2VydmVTdGFsbHMgPSBvbmNlKFxyXG4gICgpOiBPYnNlcnZhYmxlPG51bWJlcj4gPT4ge1xyXG4gICAgY29uc3QgYnJvd3NlcldpbmRvdyA9IHJlbW90ZS5nZXRDdXJyZW50V2luZG93KCk7XHJcblxyXG4gICAgY29uc3Qgb25JbnRlbnRpb25hbEJsb2NrID0gKCkgPT4ge1xyXG4gICAgICBpbnRlbnRpb25hbEJsb2NrVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBibG9ja2VkRXZlbnRzID0gbmV3IFBlcmZvcm1hbmNlT2JzZXJ2YWJsZSh7ZW50cnlUeXBlczogWydsb25ndGFzayddfSlcclxuICAgICAgLmZsYXR0ZW5FbnRyaWVzKClcclxuICAgICAgLy8gb25seSBjb3VudCBpZiB0aGUgd2luZG93IGlzIGZvY3VzZWQgd2hlbiB0aGUgdGFzayByYW4gbG9uZ1xyXG4gICAgICAuZmlsdGVyKCgpID0+IGRvY3VtZW50Lmhhc0ZvY3VzKCkpXHJcbiAgICAgIC8vIGRpc2NhcmQgZWFybHkgbG9uZ3Rhc2tzIGFzIHRoZSBhcHAgaXMgYm9vdGluZ1xyXG4gICAgICAuZmlsdGVyKCgpID0+IHByb2Nlc3MudXB0aW1lKCkgPiBCTE9DS0VEX0dSQUNFX1BFUklPRClcclxuICAgICAgLy8gZGlzY2FyZCBkdXJhdGlvbnMgdGhhdCBhcmUgdW5yZWFsaXN0aWNhbGx5IGxvbmcsIG9yIHRob3NlIHRoYXQgYXJlbid0XHJcbiAgICAgIC8vIG1lYW5pbmdmdWwgZW5vdWdoXHJcbiAgICAgIC5maWx0ZXIoXHJcbiAgICAgICAgZW50cnkgPT4gZW50cnkuZHVyYXRpb24gPiBCTE9DS0VEX01JTiAmJiBlbnRyeS5kdXJhdGlvbiA8IEJMT0NLRURfTUFYLFxyXG4gICAgICApXHJcbiAgICAgIC8vIGRpc2NhcmQgZXZlbnRzIHRoYXQgcmVzdWx0IGZyb20gdXNlciBpbnRlcmFjdGlvbiBhY3R1YWxseSBibG9ja2luZyB0aGVcclxuICAgICAgLy8gdGhyZWFkIHdoZW4gdGhlcmUgaXMgbm8gb3RoZXIgb3B0aW9uIChlLmcuIGNvbnRleHQgbWVudXMpXHJcbiAgICAgIC5maWx0ZXIoXHJcbiAgICAgICAgZW50cnkgPT5cclxuICAgICAgICAgIC8vIGRpZCB0aGUgaW50ZW50aW9uYWxibG9ja3RpbWUgb2NjdXIgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZCxcclxuICAgICAgICAgIC8vIGFjY291bnRpbmcgZm9yIHNvbWUgZXh0cmEgcGFkZGluZz9cclxuICAgICAgICAgICEoXHJcbiAgICAgICAgICAgIGludGVudGlvbmFsQmxvY2tUaW1lID4gZW50cnkuc3RhcnRUaW1lIC0gQkxPQ0tFRF9SQU5HRV9QQURESU5HICYmXHJcbiAgICAgICAgICAgIGludGVudGlvbmFsQmxvY2tUaW1lIDxcclxuICAgICAgICAgICAgICBlbnRyeS5zdGFydFRpbWUgKyBlbnRyeS5kdXJhdGlvbiArIEJMT0NLRURfUkFOR0VfUEFERElOR1xyXG4gICAgICAgICAgKSxcclxuICAgICAgKTtcclxuXHJcbiAgICByZXR1cm4gT2JzZXJ2YWJsZS51c2luZyhcclxuICAgICAgKCkgPT5cclxuICAgICAgICBuZXcgVW5pdmVyc2FsRGlzcG9zYWJsZShcclxuICAgICAgICAgIC8vIENvbmZpcm1hdGlvbiBkaWFsb2dzIGFsc28gYmxvY2sgdGhlIGV2ZW50IGxvb3AuXHJcbiAgICAgICAgICAvLyBUaGlzIHR5cGljYWxseSBoYXBwZW5zIHdoZW4geW91J3JlIGFib3V0IHRvIGNsb3NlIGFuIHVuc2F2ZWQgZmlsZS5cclxuICAgICAgICAgIGF0b20ud29ya3NwYWNlLm9uV2lsbERlc3Ryb3lQYW5lSXRlbShvbkludGVudGlvbmFsQmxvY2spLFxyXG4gICAgICAgICAgLy8gRWxlY3Ryb24gY29udGV4dCBtZW51cyBibG9jayB0aGUgZXZlbnQgbG9vcC5cclxuICAgICAgICAgIE9ic2VydmFibGUuZnJvbUV2ZW50KGJyb3dzZXJXaW5kb3csICdjb250ZXh0LW1lbnUnKVxyXG4gICAgICAgICAgICAvLyBUaGVyZSBhcHBlYXJzIHRvIGJlIGFuIHJhY2Ugd2l0aCBicm93c2VyIHdpbmRvdyBzaHV0ZG93biB3aGVyZVxyXG4gICAgICAgICAgICAvLyB0aGUgJ2NvbnRleHQtbWVudScgZXZlbnQgZmlyZXMgYWZ0ZXIgd2luZG93IGRlc3RydWN0aW9uLlxyXG4gICAgICAgICAgICAvLyBUcnkgdG8gcHJldmVudCB0aGlzIGJ5IHJlbW92aW5nIHRoZSBldmVudCBvbiBjbG9zZS5cclxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL251Y2xpZGUvaXNzdWVzLzEyNDZcclxuICAgICAgICAgICAgLnRha2VVbnRpbChPYnNlcnZhYmxlLmZyb21FdmVudChicm93c2VyV2luZG93LCAnY2xvc2UnKSlcclxuICAgICAgICAgICAgLnN1YnNjcmliZShvbkludGVudGlvbmFsQmxvY2spLFxyXG4gICAgICAgICksXHJcbiAgICAgICgpID0+IHtcclxuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZS5tZXJnZShcclxuICAgICAgICAgIC8vIGtpY2sgb2ZmIHN1YnNjcmlwdGlvbiB3aXRoIGEgb25lLXRpbWUgcXVlcnkgb24gc3RhcnRcclxuICAgICAgICAgIE9ic2VydmFibGUub2YoZG9jdW1lbnQuaGFzRm9jdXMoKSksXHJcbiAgICAgICAgICBPYnNlcnZhYmxlLmZyb21FdmVudChicm93c2VyV2luZG93LCAnZm9jdXMnKS5tYXBUbyh0cnVlKSxcclxuICAgICAgICAgIE9ic2VydmFibGUuZnJvbUV2ZW50KGJyb3dzZXJXaW5kb3csICdibHVyJykubWFwVG8oZmFsc2UpLFxyXG4gICAgICAgIClcclxuICAgICAgICAgIC5kaXN0aW5jdFVudGlsQ2hhbmdlZCgpXHJcbiAgICAgICAgICAuc3dpdGNoTWFwKFxyXG4gICAgICAgICAgICBpc0ZvY3VzZWQgPT4gKGlzRm9jdXNlZCA/IGJsb2NrZWRFdmVudHMgOiBPYnNlcnZhYmxlLmVtcHR5KCkpLFxyXG4gICAgICAgICAgKVxyXG4gICAgICAgICAgLm1hcChlbnRyeSA9PiBlbnRyeS5kdXJhdGlvbik7XHJcbiAgICAgIH0sXHJcbiAgICApLnNoYXJlKCk7XHJcbiAgfSxcclxuKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IG9ic2VydmVTdGFsbHM7XHJcblxyXG4vKlxyXG4gKiBPZnRlbiB0aW1lcyB1c2VycyB0YWtlIGFuIGFjdGlvbiBhbmQgY2FuIHJlc29uYWJseSBleHBlY3QgYSBsb25nLCBibG9ja2luZyB0YXNrXHJcbiAqIHRvIHJ1biB0byBjb21wbGV0aW9uIGJlZm9yZSB0aGV5IGNhbiB0YWtlIGFjdGlvbiBhZ2FpbjpcclxuICogaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vd2ViL2Z1bmRhbWVudGFscy9wZXJmb3JtYW5jZS9yYWlsI3V4XHJcbiAqIFRoaXMgaXMgYW5hbGFnb3VzIHRvIGEgd2ViIHBhZ2Ugb3IgYXBwJ3MgaW5pdGlhbCBsb2FkaW5nLCB0cmFuc2l0aW9uaW5nIHRvXHJcbiAqIGFub3RoZXIgc2lnbmlmaWNhbnQgdmlldywgZXRjLlxyXG4gKlxyXG4gKiBUaGlzIGlzIGEgZGVjb3JhdG9yIHRoYXQgd3JhcHMgYSBmdW5jdGlvbiB0aGF0IHBhdXNlcyBpbiByZXNwb25zZSB0byB1c2VyIGFjdGlvbixcclxuICogb3B0aW5nIGl0IG91dCBvZiBzdGFsbCBvYnNlcnZhdGlvbiBhbmQgZm9yd2FyZGluZyBhbnkgYXJndW1lbnRzIHBhc3NlZCBhbmQgcmV0dXJuaW5nXHJcbiAqIHRoZSBvcmlnaW5hbCBmdW5jdGlvbidzIHJldHVybiB2YWx1ZS5cclxuICpcclxuICogKipVc2UgdGhpcyBjYXV0aW91c2x5IGFuZCBkZWxpYmVyYXRlbHksIG9ubHkgaW4gc2l0dWF0aW9ucyB3aGVyZSBpdCBpc1xyXG4gKiByZWFzb25hYmxlIGZvciBhIHVzZXIgdG8gZXhwZWN0IGEgcGF1c2UhKipcclxuICpcclxuICogSWYgdGhlIGFjdGlvbiB0YWtlcyBsb25nZXIgdGhhbiAxcywgd2Ugc3RpbGwgcmVjb3JkIHRoaXMgYXMgYSBzdGFsbCwgYXMgaXRcclxuICogZmFpbHMgdGhlIFJBSUwgbW9kZWwncyBkZWZpbml0aW9uIG9mIHJlc3BvbnNpdmUgbG9hZGluZy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpbnRlbnRpb25hbGx5QmxvY2tzSW5SZXNwb25zZVRvVXNlckFjdGlvbjxULCBVPihcclxuICBmbjogKC4uLmFyZ3M6IEFycmF5PFQ+KSA9PiBVLFxyXG4pOiAoLi4uYXJnczogQXJyYXk8VD4pID0+IFUge1xyXG4gIGNvbnN0IGludGVudGlvbmFsbHlCbG9ja3MgPSBmdW5jdGlvbiguLi5hcmdzOiBBcnJheTxUPikge1xyXG4gICAgY29uc3QgYmVmb3JlID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICBjb25zdCByZXQgPSBmbi5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgIGlmIChwZXJmb3JtYW5jZS5ub3coKSAtIGJlZm9yZSA8IDEwMDApIHtcclxuICAgICAgaW50ZW50aW9uYWxCbG9ja1RpbWUgPSBiZWZvcmU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJldDtcclxuICB9O1xyXG5cclxuICBpbnRlbnRpb25hbGx5QmxvY2tzLmRpc3BsYXlOYW1lID0gYGludGVudGlvbmFsbHlCbG9ja3MoJHtnZXREaXNwbGF5TmFtZShcclxuICAgIGZuLFxyXG4gICl9KWA7XHJcbiAgcmV0dXJuIGludGVudGlvbmFsbHlCbG9ja3M7XHJcbn1cclxuIl19