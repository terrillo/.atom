"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = showModal;

var _assert = _interopRequireDefault(require("assert"));

var React = _interopRequireWildcard(require("react"));

var _reactDom = _interopRequireDefault(require("react-dom"));

var _rxjsCompatUmdMin = require("rxjs-compat/bundles/rxjs-compat.umd.min.js");

var _UniversalDisposable = _interopRequireDefault(require("@atom-ide-community/nuclide-commons/UniversalDisposable"));

var _TabbableContainer = _interopRequireDefault(require("./TabbableContainer"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */

/* global Node */

/* global HTMLElement */

/**
 * Shows a modal dialog that renders a React element as its content.
 * The modal is automatically hidden when the user clicks outside of it, and on core:cancel (esc).
 * The modal panel unmounts its React component and destroys the panel as soon as it is hidden;
 * you may not hide the panel and then re-show it later.
 * Returns a disposable that you may use to hide and destroy the modal.
 */
function showModal(contentFactory, options = defaults) {
  const hostElement = document.createElement('div');
  const atomPanel = atom.workspace.addModalPanel({
    item: hostElement,
    priority: options.priority,
    className: options.className
  });

  const shouldDismissOnClickOutsideModal = options.shouldDismissOnClickOutsideModal || (() => true);

  const shouldDismissOnPressEscape = options.shouldDismissOnPressEscape || (() => true);

  const element = atomPanel.getElement();
  const previouslyFocusedElement = document.activeElement;
  const disposable = new _UniversalDisposable.default(_rxjsCompatUmdMin.Observable.fromEvent(document, 'mousedown').subscribe(({
    target
  }) => {
    if (!shouldDismissOnClickOutsideModal()) {
      return;
    }

    (0, _assert.default)(target instanceof Node);

    if (!atomPanel.getItem().contains(target) && // don't count clicks on notifications or tooltips as clicks 'outside'
    target.closest('atom-notifications, .tooltip') == null) {
      atomPanel.hide();
    }
  }), atomPanel.onDidChangeVisible(visible => {
    if (!visible) {
      disposable.dispose();
    }
  }), atom.commands.add('body', 'core:cancel', () => {
    if (shouldDismissOnPressEscape()) {
      disposable.dispose();
    }
  }), () => {
    // Call onDismiss before unmounting the component and destroying the panel:
    if (options.onDismiss) {
      options.onDismiss();
    }

    _reactDom.default.unmountComponentAtNode(hostElement);

    atomPanel.destroy();

    if (previouslyFocusedElement != null) {
      previouslyFocusedElement.focus();
    }
  });

  _reactDom.default.render( /*#__PURE__*/React.createElement(ModalContainer, null, contentFactory({
    dismiss: disposable.dispose.bind(disposable),
    element
  })), hostElement, () => {
    if (options.onOpen) {
      options.onOpen();
    }
  });

  return disposable;
}
/** Flow makes {} an unsealed object (eyeroll) */


const defaults = Object.freeze({});

/**
 * Just exists to provide a div that we can focus on mount. This ensures we steal focus from any
 * editors or other panes while the modal is present.
 */
class ModalContainer extends React.Component {
  render() {
    return /*#__PURE__*/React.createElement("div", {
      tabIndex: "-1"
    }, /*#__PURE__*/React.createElement(_TabbableContainer.default, {
      contained: true
    }, this.props.children));
  }

  componentDidMount() {
    const node = _reactDom.default.findDOMNode(this);

    (0, _assert.default)(node instanceof HTMLElement); // Steal the focus away from any active editor or pane, setting it on the modal;
    // but don't steal focus away from a descendant. This can happen if a React element focuses
    // during its componentDidMount. For example, <AtomInput> does this since the underlying
    // <atom-text-editor> does not support the autofocus attribute.

    if (!node.contains(document.activeElement)) {
      node.focus();
    }
  }

}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zLXVpL3Nob3dNb2RhbC5qcyJdLCJuYW1lcyI6WyJzaG93TW9kYWwiLCJjb250ZW50RmFjdG9yeSIsIm9wdGlvbnMiLCJkZWZhdWx0cyIsImhvc3RFbGVtZW50IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiYXRvbVBhbmVsIiwiYXRvbSIsIndvcmtzcGFjZSIsImFkZE1vZGFsUGFuZWwiLCJpdGVtIiwicHJpb3JpdHkiLCJjbGFzc05hbWUiLCJzaG91bGREaXNtaXNzT25DbGlja091dHNpZGVNb2RhbCIsInNob3VsZERpc21pc3NPblByZXNzRXNjYXBlIiwiZWxlbWVudCIsImdldEVsZW1lbnQiLCJwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQiLCJhY3RpdmVFbGVtZW50IiwiZGlzcG9zYWJsZSIsIlVuaXZlcnNhbERpc3Bvc2FibGUiLCJPYnNlcnZhYmxlIiwiZnJvbUV2ZW50Iiwic3Vic2NyaWJlIiwidGFyZ2V0IiwiTm9kZSIsImdldEl0ZW0iLCJjb250YWlucyIsImNsb3Nlc3QiLCJoaWRlIiwib25EaWRDaGFuZ2VWaXNpYmxlIiwidmlzaWJsZSIsImRpc3Bvc2UiLCJjb21tYW5kcyIsImFkZCIsIm9uRGlzbWlzcyIsIlJlYWN0RE9NIiwidW5tb3VudENvbXBvbmVudEF0Tm9kZSIsImRlc3Ryb3kiLCJmb2N1cyIsInJlbmRlciIsImRpc21pc3MiLCJiaW5kIiwib25PcGVuIiwiT2JqZWN0IiwiZnJlZXplIiwiTW9kYWxDb250YWluZXIiLCJSZWFjdCIsIkNvbXBvbmVudCIsInByb3BzIiwiY2hpbGRyZW4iLCJjb21wb25lbnREaWRNb3VudCIsIm5vZGUiLCJmaW5kRE9NTm9kZSIsIkhUTUxFbGVtZW50Il0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBZUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7Ozs7Ozs7O0FBckJBOzs7Ozs7Ozs7Ozs7QUFZQTs7QUFDQTs7QUF3Q0E7Ozs7Ozs7QUFP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QUFuQyxDQUFvRDtBQUNsRFIsRUFBQUEsTUFBTSxHQUFlO0FBQ25CLHdCQUNFO0FBQUssTUFBQSxRQUFRLEVBQUM7QUFBZCxvQkFDRSxvQkFBQywwQkFBRDtBQUFtQixNQUFBLFNBQVMsRUFBRTtBQUE5QixPQUNHLEtBQUtTLEtBQUwsQ0FBV0MsUUFEZCxDQURGLENBREY7QUFPRDs7QUFFREMsRUFBQUEsaUJBQWlCLEdBQVM7QUFDeEIsVUFBTUMsSUFBSSxHQUFHaEIsa0JBQVNpQixXQUFULENBQXFCLElBQXJCLENBQWI7O0FBQ0EseUJBQVVELElBQUksWUFBWUUsV0FBMUIsRUFGd0IsQ0FHeEI7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsUUFBSSxDQUFDRixJQUFJLENBQUN6QixRQUFMLENBQWN2QixRQUFRLENBQUNjLGFBQXZCLENBQUwsRUFBNEM7QUFDMUNrQyxNQUFBQSxJQUFJLENBQUNiLEtBQUw7QUFDRDtBQUNGOztBQXJCaUQiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIEBmbG93XHJcbiAqIEBmb3JtYXRcclxuICovXHJcblxyXG4vKiBnbG9iYWwgTm9kZSAqL1xyXG4vKiBnbG9iYWwgSFRNTEVsZW1lbnQgKi9cclxuXHJcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnYXNzZXJ0JztcclxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcclxuaW1wb3J0IHtPYnNlcnZhYmxlfSBmcm9tICdyeGpzLWNvbXBhdC9idW5kbGVzL3J4anMtY29tcGF0LnVtZC5taW4uanMnO1xyXG5pbXBvcnQgVW5pdmVyc2FsRGlzcG9zYWJsZSBmcm9tICdAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtY29tbW9ucy9Vbml2ZXJzYWxEaXNwb3NhYmxlJztcclxuXHJcbmltcG9ydCBUYWJiYWJsZUNvbnRhaW5lciBmcm9tICcuL1RhYmJhYmxlQ29udGFpbmVyJztcclxuXHJcbi8qKlxyXG4gKiBHaXZlbiBhIGZ1bmN0aW9uIHRvIGRpc21pc3MgdGhlIG1vZGFsLCByZXR1cm4gYSBSZWFjdCBlbGVtZW50IGZvciB0aGUgY29udGVudC5cclxuICogQ2FsbCB0aGUgZnVuY3Rpb24gd2hlbiBlLmcuIHRoZSB1c2VyIGNsaWNrcyBhIENhbmNlbCBvciBTdWJtaXQgYnV0dG9uLlxyXG4gKi9cclxudHlwZSBDb250ZW50RmFjdG9yeSA9ICh7XHJcbiAgZGlzbWlzcygpOiB2b2lkLFxyXG4gIGVsZW1lbnQ6IEVsZW1lbnQsXHJcbn0pID0+IFJlYWN0Lk5vZGU7XHJcblxyXG4vKiogV3JhcCBvcHRpb25zIGluIGFuIG9iamVjdCBzbyB3ZSBjYW4gYWRkIG5ldyBvbmVzIGxhdGVyIHdpdGhvdXQgYW4gZXhwbG9zaW9uIG9mIHBhcmFtcyAqL1xyXG50eXBlIE9wdGlvbnMgPSB7fFxyXG4gIC8qKiBDYWxsZWQgd2hlbiB0aGUgbW9kYWwgaXMgZGlzbWlzc2VkIChqdXN0IGJlZm9yZSBpdCBpcyBkZXN0cm95ZWQpLiAqL1xyXG4gIG9uRGlzbWlzcz86ICgpID0+IG1peGVkLFxyXG4gIG9uT3Blbj86ICgpID0+IG1peGVkLFxyXG4gIC8qKlxyXG4gICAqIENhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvdXRzaWRlIHRoZSBtb2RhbCwgcmV0dXJuIGZhbHNlIHRvIHByZXZlbnQgZGlzbWlzc2FsLlxyXG4gICAqIElmIHVuc3BlY2lmaWVkIHRoZSBtb2RhbCB3aWxsIGJlIGRpc21pc3NlZCBpZiB0aGUgdXNlciBjbGlja3Mgb3V0c2lkZSB0aGUgbW9kYWwuXHJcbiAgICovXHJcbiAgc2hvdWxkRGlzbWlzc09uQ2xpY2tPdXRzaWRlTW9kYWw/OiAoKSA9PiBib29sZWFuLFxyXG4gIC8qKlxyXG4gICAqIENhbGxlZCB3aGVuIHRoZSB1c2VyIHByZXNzZXMgdGhlIGVzY2FwZSBrZXksIHJldHVybiBmYWxzZSB0byBwcmV2ZW50IGRpc21pc3NhbC5cclxuICAgKiBJZiB1bnNwZWNpZmllZCB0aGUgbW9kYWwgd2lsbCBiZSBkaXNtaXNzZWQgaWYgdGhlIHVzZXIgcHJlc3NlcyBlc2NhcGUuXHJcbiAgICovXHJcbiAgc2hvdWxkRGlzbWlzc09uUHJlc3NFc2NhcGU/OiAoKSA9PiBib29sZWFuLFxyXG4gIC8qKiBQYXNzZWQgdG8gYXRvbSdzIHVuZGVybHlpbmcgYWRkTW9kYWxQYW5lbCBmdW5jdGlvbi4gKi9cclxuICBwcmlvcml0eT86IG51bWJlcixcclxuICAvKiogUGFzc2VkIHRvIGF0b20ncyB1bmRlcmx5aW5nIGFkZE1vZGFsUGFuZWwgZnVuY3Rpb24uICovXHJcbiAgY2xhc3NOYW1lPzogc3RyaW5nLFxyXG58fTtcclxuXHJcbi8qKlxyXG4gKiBTaG93cyBhIG1vZGFsIGRpYWxvZyB0aGF0IHJlbmRlcnMgYSBSZWFjdCBlbGVtZW50IGFzIGl0cyBjb250ZW50LlxyXG4gKiBUaGUgbW9kYWwgaXMgYXV0b21hdGljYWxseSBoaWRkZW4gd2hlbiB0aGUgdXNlciBjbGlja3Mgb3V0c2lkZSBvZiBpdCwgYW5kIG9uIGNvcmU6Y2FuY2VsIChlc2MpLlxyXG4gKiBUaGUgbW9kYWwgcGFuZWwgdW5tb3VudHMgaXRzIFJlYWN0IGNvbXBvbmVudCBhbmQgZGVzdHJveXMgdGhlIHBhbmVsIGFzIHNvb24gYXMgaXQgaXMgaGlkZGVuO1xyXG4gKiB5b3UgbWF5IG5vdCBoaWRlIHRoZSBwYW5lbCBhbmQgdGhlbiByZS1zaG93IGl0IGxhdGVyLlxyXG4gKiBSZXR1cm5zIGEgZGlzcG9zYWJsZSB0aGF0IHlvdSBtYXkgdXNlIHRvIGhpZGUgYW5kIGRlc3Ryb3kgdGhlIG1vZGFsLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2hvd01vZGFsKFxyXG4gIGNvbnRlbnRGYWN0b3J5OiBDb250ZW50RmFjdG9yeSxcclxuICBvcHRpb25zOiBPcHRpb25zID0gZGVmYXVsdHMsXHJcbik6IElEaXNwb3NhYmxlIHtcclxuICBjb25zdCBob3N0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gIGNvbnN0IGF0b21QYW5lbCA9IGF0b20ud29ya3NwYWNlLmFkZE1vZGFsUGFuZWwoe1xyXG4gICAgaXRlbTogaG9zdEVsZW1lbnQsXHJcbiAgICBwcmlvcml0eTogb3B0aW9ucy5wcmlvcml0eSxcclxuICAgIGNsYXNzTmFtZTogb3B0aW9ucy5jbGFzc05hbWUsXHJcbiAgfSk7XHJcbiAgY29uc3Qgc2hvdWxkRGlzbWlzc09uQ2xpY2tPdXRzaWRlTW9kYWwgPVxyXG4gICAgb3B0aW9ucy5zaG91bGREaXNtaXNzT25DbGlja091dHNpZGVNb2RhbCB8fCAoKCkgPT4gdHJ1ZSk7XHJcbiAgY29uc3Qgc2hvdWxkRGlzbWlzc09uUHJlc3NFc2NhcGUgPVxyXG4gICAgb3B0aW9ucy5zaG91bGREaXNtaXNzT25QcmVzc0VzY2FwZSB8fCAoKCkgPT4gdHJ1ZSk7XHJcblxyXG4gIGNvbnN0IGVsZW1lbnQgPSBhdG9tUGFuZWwuZ2V0RWxlbWVudCgpO1xyXG4gIGNvbnN0IHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XHJcbiAgY29uc3QgZGlzcG9zYWJsZSA9IG5ldyBVbml2ZXJzYWxEaXNwb3NhYmxlKFxyXG4gICAgT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdtb3VzZWRvd24nKS5zdWJzY3JpYmUoKHt0YXJnZXR9KSA9PiB7XHJcbiAgICAgIGlmICghc2hvdWxkRGlzbWlzc09uQ2xpY2tPdXRzaWRlTW9kYWwoKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpbnZhcmlhbnQodGFyZ2V0IGluc3RhbmNlb2YgTm9kZSk7XHJcbiAgICAgIGlmIChcclxuICAgICAgICAhYXRvbVBhbmVsLmdldEl0ZW0oKS5jb250YWlucyh0YXJnZXQpICYmXHJcbiAgICAgICAgLy8gZG9uJ3QgY291bnQgY2xpY2tzIG9uIG5vdGlmaWNhdGlvbnMgb3IgdG9vbHRpcHMgYXMgY2xpY2tzICdvdXRzaWRlJ1xyXG4gICAgICAgIHRhcmdldC5jbG9zZXN0KCdhdG9tLW5vdGlmaWNhdGlvbnMsIC50b29sdGlwJykgPT0gbnVsbFxyXG4gICAgICApIHtcclxuICAgICAgICBhdG9tUGFuZWwuaGlkZSgpO1xyXG4gICAgICB9XHJcbiAgICB9KSxcclxuICAgIGF0b21QYW5lbC5vbkRpZENoYW5nZVZpc2libGUodmlzaWJsZSA9PiB7XHJcbiAgICAgIGlmICghdmlzaWJsZSkge1xyXG4gICAgICAgIGRpc3Bvc2FibGUuZGlzcG9zZSgpO1xyXG4gICAgICB9XHJcbiAgICB9KSxcclxuICAgIGF0b20uY29tbWFuZHMuYWRkKCdib2R5JywgJ2NvcmU6Y2FuY2VsJywgKCkgPT4ge1xyXG4gICAgICBpZiAoc2hvdWxkRGlzbWlzc09uUHJlc3NFc2NhcGUoKSkge1xyXG4gICAgICAgIGRpc3Bvc2FibGUuZGlzcG9zZSgpO1xyXG4gICAgICB9XHJcbiAgICB9KSxcclxuICAgICgpID0+IHtcclxuICAgICAgLy8gQ2FsbCBvbkRpc21pc3MgYmVmb3JlIHVubW91bnRpbmcgdGhlIGNvbXBvbmVudCBhbmQgZGVzdHJveWluZyB0aGUgcGFuZWw6XHJcbiAgICAgIGlmIChvcHRpb25zLm9uRGlzbWlzcykge1xyXG4gICAgICAgIG9wdGlvbnMub25EaXNtaXNzKCk7XHJcbiAgICAgIH1cclxuICAgICAgUmVhY3RET00udW5tb3VudENvbXBvbmVudEF0Tm9kZShob3N0RWxlbWVudCk7XHJcbiAgICAgIGF0b21QYW5lbC5kZXN0cm95KCk7XHJcbiAgICAgIGlmIChwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQgIT0gbnVsbCkge1xyXG4gICAgICAgIHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudC5mb2N1cygpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICk7XHJcblxyXG4gIFJlYWN0RE9NLnJlbmRlcihcclxuICAgIDxNb2RhbENvbnRhaW5lcj5cclxuICAgICAge2NvbnRlbnRGYWN0b3J5KHtkaXNtaXNzOiBkaXNwb3NhYmxlLmRpc3Bvc2UuYmluZChkaXNwb3NhYmxlKSwgZWxlbWVudH0pfVxyXG4gICAgPC9Nb2RhbENvbnRhaW5lcj4sXHJcbiAgICBob3N0RWxlbWVudCxcclxuICAgICgpID0+IHtcclxuICAgICAgaWYgKG9wdGlvbnMub25PcGVuKSB7XHJcbiAgICAgICAgb3B0aW9ucy5vbk9wZW4oKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICApO1xyXG5cclxuICByZXR1cm4gZGlzcG9zYWJsZTtcclxufVxyXG5cclxuLyoqIEZsb3cgbWFrZXMge30gYW4gdW5zZWFsZWQgb2JqZWN0IChleWVyb2xsKSAqL1xyXG5jb25zdCBkZWZhdWx0czogT3B0aW9ucyA9IE9iamVjdC5mcmVlemUoe30pO1xyXG5cclxudHlwZSBQcm9wcyA9IHtcclxuICBjaGlsZHJlbj86IGFueSxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBKdXN0IGV4aXN0cyB0byBwcm92aWRlIGEgZGl2IHRoYXQgd2UgY2FuIGZvY3VzIG9uIG1vdW50LiBUaGlzIGVuc3VyZXMgd2Ugc3RlYWwgZm9jdXMgZnJvbSBhbnlcclxuICogZWRpdG9ycyBvciBvdGhlciBwYW5lcyB3aGlsZSB0aGUgbW9kYWwgaXMgcHJlc2VudC5cclxuICovXHJcbmNsYXNzIE1vZGFsQ29udGFpbmVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFByb3BzPiB7XHJcbiAgcmVuZGVyKCk6IFJlYWN0Lk5vZGUge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgPGRpdiB0YWJJbmRleD1cIi0xXCI+XHJcbiAgICAgICAgPFRhYmJhYmxlQ29udGFpbmVyIGNvbnRhaW5lZD17dHJ1ZX0+XHJcbiAgICAgICAgICB7dGhpcy5wcm9wcy5jaGlsZHJlbn1cclxuICAgICAgICA8L1RhYmJhYmxlQ29udGFpbmVyPlxyXG4gICAgICA8L2Rpdj5cclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBjb21wb25lbnREaWRNb3VudCgpOiB2b2lkIHtcclxuICAgIGNvbnN0IG5vZGUgPSBSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKTtcclxuICAgIGludmFyaWFudChub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpO1xyXG4gICAgLy8gU3RlYWwgdGhlIGZvY3VzIGF3YXkgZnJvbSBhbnkgYWN0aXZlIGVkaXRvciBvciBwYW5lLCBzZXR0aW5nIGl0IG9uIHRoZSBtb2RhbDtcclxuICAgIC8vIGJ1dCBkb24ndCBzdGVhbCBmb2N1cyBhd2F5IGZyb20gYSBkZXNjZW5kYW50LiBUaGlzIGNhbiBoYXBwZW4gaWYgYSBSZWFjdCBlbGVtZW50IGZvY3VzZXNcclxuICAgIC8vIGR1cmluZyBpdHMgY29tcG9uZW50RGlkTW91bnQuIEZvciBleGFtcGxlLCA8QXRvbUlucHV0PiBkb2VzIHRoaXMgc2luY2UgdGhlIHVuZGVybHlpbmdcclxuICAgIC8vIDxhdG9tLXRleHQtZWRpdG9yPiBkb2VzIG5vdCBzdXBwb3J0IHRoZSBhdXRvZm9jdXMgYXR0cmlidXRlLlxyXG4gICAgaWYgKCFub2RlLmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XHJcbiAgICAgIG5vZGUuZm9jdXMoKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuIl19