"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rxjsCompatUmdMin = require("rxjs-compat/bundles/rxjs-compat.umd.min.js");

var _UniversalDisposable = _interopRequireDefault(require("./UniversalDisposable"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */

/**
 * Exposes a simple API for a stateful model. This is similar to React's `state`/`setState()` API
 * except achieved via composition and easily convertible to observables so you can do awesome
 * stuff. It's really a super-thin wrapper around `BehaviorSubject`; wrapping `BehaviorSubject`
 * instead of extending it was done to minimize the API surface area. Ideally, this would implement
 * `Symbol.observable` instead of having a `toObservable()` method, but since Flow doesn't
 * understand that, it causes more trouble than it's worth.
 *
 * While you can extend this class, composition is recommended.
 *
 * Example:
 *
 *     class MyThing {
 *       _model = new Model({count: 0});
 *       increment(): void {
 *         const {count} = this._model.state;
 *         this._model.setState({count: count + 1});
 *       }
 *     }
 *
 * BEST PRACTICES
 *
 * Don't pass your model instance around! Instead, create a new object with the properties you want
 * and explicit setters:
 *
 *     const props = {
 *       count: model.state.count,
 *       increment: () => {
 *         const {count} = model.state;
 *         model.setState({count: count + 1})
 *       },
 *     };
 *
 * You'll notice that this is very similar to Flux/Redux, with the setters corresponding to bound
 * action creators. That's awesome! It means that, should the state grow and require new
 * capabilities, we can always switch to full-blown Redux without having to refactor a ton of stuff.
 */
class Model {
  constructor(initialState) {
    this._states = void 0;
    this._states = new _rxjsCompatUmdMin.BehaviorSubject(initialState);
  }

  setState(newState) {
    const nextState = { ...this.state,
      ...newState
    };

    this._states.next(nextState);
  }

  get state() {
    return this._states.getValue();
  }

  subscribe(cb) {
    return new _UniversalDisposable.default(this.toObservable().subscribe({
      next: cb
    }));
  }

  toObservable() {
    return this._states.distinctUntilChanged();
  }

}

exports.default = Model;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zL01vZGVsLmpzIl0sIm5hbWVzIjpbIk1vZGVsIiwiY29uc3RydWN0b3IiLCJpbml0aWFsU3RhdGUiLCJfc3RhdGVzIiwiQmVoYXZpb3JTdWJqZWN0Iiwic2V0U3RhdGUiLCJuZXdTdGF0ZSIsIm5leHRTdGF0ZSIsInN0YXRlIiwibmV4dCIsImdldFZhbHVlIiwic3Vic2NyaWJlIiwiY2IiLCJVbml2ZXJzYWxEaXNwb3NhYmxlIiwidG9PYnNlcnZhYmxlIiwiZGlzdGluY3RVbnRpbENoYW5nZWQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFjQTs7QUFDQTs7OztBQWZBOzs7Ozs7Ozs7Ozs7QUFpQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQ2UsTUFBTUEsS0FBTixDQUF1QjtBQUdwQ0MsRUFBQUEsV0FBVyxDQUFDQyxZQUFELEVBQXNCO0FBQUEsU0FGakNDLE9BRWlDO0FBQy9CLFNBQUtBLE9BQUwsR0FBZSxJQUFJQyxpQ0FBSixDQUFvQkYsWUFBcEIsQ0FBZjtBQUNEOztBQUVERyxFQUFBQSxRQUFRLENBQUNDLFFBQUQsRUFBZ0M7QUFDdEMsVUFBTUMsU0FBUyxHQUFHLEVBQUMsR0FBRyxLQUFLQyxLQUFUO0FBQWdCLFNBQUdGO0FBQW5CLEtBQWxCOztBQUNBLFNBQUtILE9BQUwsQ0FBYU0sSUFBYixDQUFrQkYsU0FBbEI7QUFDRDs7QUFFRCxNQUFJQyxLQUFKLEdBQW1CO0FBQ2pCLFdBQU8sS0FBS0wsT0FBTCxDQUFhTyxRQUFiLEVBQVA7QUFDRDs7QUFFREMsRUFBQUEsU0FBUyxDQUFDQyxFQUFELEVBQTJDO0FBQ2xELFdBQU8sSUFBSUMsNEJBQUosQ0FBd0IsS0FBS0MsWUFBTCxHQUFvQkgsU0FBcEIsQ0FBOEI7QUFBQ0YsTUFBQUEsSUFBSSxFQUFFRztBQUFQLEtBQTlCLENBQXhCLENBQVA7QUFDRDs7QUFFREUsRUFBQUEsWUFBWSxHQUFzQjtBQUNoQyxXQUFPLEtBQUtYLE9BQUwsQ0FBYVksb0JBQWIsRUFBUDtBQUNEOztBQXRCbUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIEBmbG93XHJcbiAqIEBmb3JtYXRcclxuICovXHJcblxyXG5pbXBvcnQgdHlwZSB7T2JzZXJ2YWJsZX0gZnJvbSAncnhqcy1jb21wYXQvYnVuZGxlcy9yeGpzLWNvbXBhdC51bWQubWluLmpzJztcclxuXHJcbmltcG9ydCB7QmVoYXZpb3JTdWJqZWN0fSBmcm9tICdyeGpzLWNvbXBhdC9idW5kbGVzL3J4anMtY29tcGF0LnVtZC5taW4uanMnO1xyXG5pbXBvcnQgVW5pdmVyc2FsRGlzcG9zYWJsZSBmcm9tICcuL1VuaXZlcnNhbERpc3Bvc2FibGUnO1xyXG5cclxuLyoqXHJcbiAqIEV4cG9zZXMgYSBzaW1wbGUgQVBJIGZvciBhIHN0YXRlZnVsIG1vZGVsLiBUaGlzIGlzIHNpbWlsYXIgdG8gUmVhY3QncyBgc3RhdGVgL2BzZXRTdGF0ZSgpYCBBUElcclxuICogZXhjZXB0IGFjaGlldmVkIHZpYSBjb21wb3NpdGlvbiBhbmQgZWFzaWx5IGNvbnZlcnRpYmxlIHRvIG9ic2VydmFibGVzIHNvIHlvdSBjYW4gZG8gYXdlc29tZVxyXG4gKiBzdHVmZi4gSXQncyByZWFsbHkgYSBzdXBlci10aGluIHdyYXBwZXIgYXJvdW5kIGBCZWhhdmlvclN1YmplY3RgOyB3cmFwcGluZyBgQmVoYXZpb3JTdWJqZWN0YFxyXG4gKiBpbnN0ZWFkIG9mIGV4dGVuZGluZyBpdCB3YXMgZG9uZSB0byBtaW5pbWl6ZSB0aGUgQVBJIHN1cmZhY2UgYXJlYS4gSWRlYWxseSwgdGhpcyB3b3VsZCBpbXBsZW1lbnRcclxuICogYFN5bWJvbC5vYnNlcnZhYmxlYCBpbnN0ZWFkIG9mIGhhdmluZyBhIGB0b09ic2VydmFibGUoKWAgbWV0aG9kLCBidXQgc2luY2UgRmxvdyBkb2Vzbid0XHJcbiAqIHVuZGVyc3RhbmQgdGhhdCwgaXQgY2F1c2VzIG1vcmUgdHJvdWJsZSB0aGFuIGl0J3Mgd29ydGguXHJcbiAqXHJcbiAqIFdoaWxlIHlvdSBjYW4gZXh0ZW5kIHRoaXMgY2xhc3MsIGNvbXBvc2l0aW9uIGlzIHJlY29tbWVuZGVkLlxyXG4gKlxyXG4gKiBFeGFtcGxlOlxyXG4gKlxyXG4gKiAgICAgY2xhc3MgTXlUaGluZyB7XHJcbiAqICAgICAgIF9tb2RlbCA9IG5ldyBNb2RlbCh7Y291bnQ6IDB9KTtcclxuICogICAgICAgaW5jcmVtZW50KCk6IHZvaWQge1xyXG4gKiAgICAgICAgIGNvbnN0IHtjb3VudH0gPSB0aGlzLl9tb2RlbC5zdGF0ZTtcclxuICogICAgICAgICB0aGlzLl9tb2RlbC5zZXRTdGF0ZSh7Y291bnQ6IGNvdW50ICsgMX0pO1xyXG4gKiAgICAgICB9XHJcbiAqICAgICB9XHJcbiAqXHJcbiAqIEJFU1QgUFJBQ1RJQ0VTXHJcbiAqXHJcbiAqIERvbid0IHBhc3MgeW91ciBtb2RlbCBpbnN0YW5jZSBhcm91bmQhIEluc3RlYWQsIGNyZWF0ZSBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgcHJvcGVydGllcyB5b3Ugd2FudFxyXG4gKiBhbmQgZXhwbGljaXQgc2V0dGVyczpcclxuICpcclxuICogICAgIGNvbnN0IHByb3BzID0ge1xyXG4gKiAgICAgICBjb3VudDogbW9kZWwuc3RhdGUuY291bnQsXHJcbiAqICAgICAgIGluY3JlbWVudDogKCkgPT4ge1xyXG4gKiAgICAgICAgIGNvbnN0IHtjb3VudH0gPSBtb2RlbC5zdGF0ZTtcclxuICogICAgICAgICBtb2RlbC5zZXRTdGF0ZSh7Y291bnQ6IGNvdW50ICsgMX0pXHJcbiAqICAgICAgIH0sXHJcbiAqICAgICB9O1xyXG4gKlxyXG4gKiBZb3UnbGwgbm90aWNlIHRoYXQgdGhpcyBpcyB2ZXJ5IHNpbWlsYXIgdG8gRmx1eC9SZWR1eCwgd2l0aCB0aGUgc2V0dGVycyBjb3JyZXNwb25kaW5nIHRvIGJvdW5kXHJcbiAqIGFjdGlvbiBjcmVhdG9ycy4gVGhhdCdzIGF3ZXNvbWUhIEl0IG1lYW5zIHRoYXQsIHNob3VsZCB0aGUgc3RhdGUgZ3JvdyBhbmQgcmVxdWlyZSBuZXdcclxuICogY2FwYWJpbGl0aWVzLCB3ZSBjYW4gYWx3YXlzIHN3aXRjaCB0byBmdWxsLWJsb3duIFJlZHV4IHdpdGhvdXQgaGF2aW5nIHRvIHJlZmFjdG9yIGEgdG9uIG9mIHN0dWZmLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9kZWw8U3RhdGU6IHt9PiB7XHJcbiAgX3N0YXRlczogQmVoYXZpb3JTdWJqZWN0PFN0YXRlPjtcclxuXHJcbiAgY29uc3RydWN0b3IoaW5pdGlhbFN0YXRlOiBTdGF0ZSkge1xyXG4gICAgdGhpcy5fc3RhdGVzID0gbmV3IEJlaGF2aW9yU3ViamVjdChpbml0aWFsU3RhdGUpO1xyXG4gIH1cclxuXHJcbiAgc2V0U3RhdGUobmV3U3RhdGU6ICRTaGFwZTxTdGF0ZT4pOiB2b2lkIHtcclxuICAgIGNvbnN0IG5leHRTdGF0ZSA9IHsuLi50aGlzLnN0YXRlLCAuLi5uZXdTdGF0ZX07XHJcbiAgICB0aGlzLl9zdGF0ZXMubmV4dChuZXh0U3RhdGUpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHN0YXRlKCk6IFN0YXRlIHtcclxuICAgIHJldHVybiB0aGlzLl9zdGF0ZXMuZ2V0VmFsdWUoKTtcclxuICB9XHJcblxyXG4gIHN1YnNjcmliZShjYjogKHN0YXRlOiBTdGF0ZSkgPT4gbWl4ZWQpOiBJRGlzcG9zYWJsZSB7XHJcbiAgICByZXR1cm4gbmV3IFVuaXZlcnNhbERpc3Bvc2FibGUodGhpcy50b09ic2VydmFibGUoKS5zdWJzY3JpYmUoe25leHQ6IGNifSkpO1xyXG4gIH1cclxuXHJcbiAgdG9PYnNlcnZhYmxlKCk6IE9ic2VydmFibGU8U3RhdGU+IHtcclxuICAgIHJldHVybiB0aGlzLl9zdGF0ZXMuZGlzdGluY3RVbnRpbENoYW5nZWQoKTtcclxuICB9XHJcbn1cclxuIl19