"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rxjsCompatUmdMin = require("rxjs-compat/bundles/rxjs-compat.umd.min.js");

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */

/**
 * ObservablePool allows you to execute Observables or functions that return
 * Observable inputs (i.e. Observables, Promises, or Iterables)
 * with a concurrency limit.
 *
 * Execution requests are queued and unsubscriptions are forwarded through
 * (if a request is still on the queue, its execution will be cancelled.)
 *
 * For requests that return a Promise, the ObservablePool is pessimistic
 * and assumes that the operation is uncancellable - it will not remove
 * the execution from the pool until it resolves or rejects. However
 * `schedule()` will still return an Observable to enable the use case
 * of cancelling requests while they're in the queue.
 *
 * Example:
 *
 *   const pool = new ObservablePool(2);
 *   pool
 *     .schedule(Observable.timer(1000).mapTo(1))
 *     .subscribe(console.log);
 *   Observable.timer(1000)
 *     .mapTo(2)
 *     .let(pool.schedule.bind(pool))
 *     .subscribe(console.log);
 *   pool
 *     .schedule(Observable.timer(100).mapTo(3))
 *     .subscribe(console.log);
 *
 * The output here is 1, 2, then 3. Despite the fact that the third observable
 * finishes more quickly, its execution is postponed until the first two finish.
 */
class ObservablePool {
  constructor(concurrency) {
    this._requests = void 0;
    this._responseListeners = void 0;
    this._subscription = void 0;
    this._requests = new _rxjsCompatUmdMin.Subject();
    this._responseListeners = new Map();
    this._subscription = this._handleEvents(concurrency);
  }

  schedule(executor) {
    return _rxjsCompatUmdMin.Observable.create(observer => {
      const unsubscribed = new _rxjsCompatUmdMin.Subject();
      const tag = {}; // Just a unique object.

      this._responseListeners.set(tag, {
        observer,
        unsubscribed
      });

      this._requests.next({
        tag,
        executor
      });

      return () => {
        this._responseListeners.delete(tag);

        unsubscribed.next();
      };
    });
  }
  /**
   * Warning: calling dispose() will error all executing requests.
   */


  dispose() {
    this._responseListeners.forEach(({
      observer
    }) => {
      observer.error(Error('ObservablePool was disposed'));
    });

    this._subscription.unsubscribe();
  }

  _handleEvents(concurrency) {
    return this._requests.mergeMap(event => {
      const {
        executor,
        tag
      } = event;

      const listener = this._responseListeners.get(tag); // unsubscribed before we could even get to it!


      if (listener == null) {
        return _rxjsCompatUmdMin.Observable.empty();
      }

      const {
        observer,
        unsubscribed
      } = listener;
      let result;

      if (executor instanceof _rxjsCompatUmdMin.Observable) {
        result = executor;
      } else {
        try {
          result = executor();
        } catch (err) {
          // Catch errors from executor().
          observer.error(err);
          return _rxjsCompatUmdMin.Observable.empty();
        }
      }

      if (result instanceof _rxjsCompatUmdMin.Observable) {
        // We can safely forward unsubscriptions!
        return result.takeUntil(unsubscribed) // $FlowFixMe: Flow doesn't like this.
        .do(observer).catch(() => _rxjsCompatUmdMin.Observable.empty());
      } else {
        // In the absence of cancellation, assume the worst.
        return _rxjsCompatUmdMin.Observable.from(result) // $FlowFixMe: Flow doesn't like this.
        .do(observer).catch(() => _rxjsCompatUmdMin.Observable.empty());
      }
    }, concurrency).subscribe();
  }

}

exports.default = ObservablePool;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zL09ic2VydmFibGVQb29sLmpzIl0sIm5hbWVzIjpbIk9ic2VydmFibGVQb29sIiwiY29uc3RydWN0b3IiLCJjb25jdXJyZW5jeSIsIl9yZXF1ZXN0cyIsIl9yZXNwb25zZUxpc3RlbmVycyIsIl9zdWJzY3JpcHRpb24iLCJTdWJqZWN0IiwiTWFwIiwiX2hhbmRsZUV2ZW50cyIsInNjaGVkdWxlIiwiZXhlY3V0b3IiLCJPYnNlcnZhYmxlIiwiY3JlYXRlIiwib2JzZXJ2ZXIiLCJ1bnN1YnNjcmliZWQiLCJ0YWciLCJzZXQiLCJuZXh0IiwiZGVsZXRlIiwiZGlzcG9zZSIsImZvckVhY2giLCJlcnJvciIsIkVycm9yIiwidW5zdWJzY3JpYmUiLCJtZXJnZU1hcCIsImV2ZW50IiwibGlzdGVuZXIiLCJnZXQiLCJlbXB0eSIsInJlc3VsdCIsImVyciIsInRha2VVbnRpbCIsImRvIiwiY2F0Y2giLCJmcm9tIiwic3Vic2NyaWJlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBWUE7O0FBWkE7Ozs7Ozs7Ozs7OztBQXVCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQStCZSxNQUFNQSxjQUFOLENBQXdCO0FBS3JDQyxFQUFBQSxXQUFXLENBQUNDLFdBQUQsRUFBc0I7QUFBQSxTQUpqQ0MsU0FJaUM7QUFBQSxTQUhqQ0Msa0JBR2lDO0FBQUEsU0FGakNDLGFBRWlDO0FBQy9CLFNBQUtGLFNBQUwsR0FBaUIsSUFBSUcseUJBQUosRUFBakI7QUFDQSxTQUFLRixrQkFBTCxHQUEwQixJQUFJRyxHQUFKLEVBQTFCO0FBQ0EsU0FBS0YsYUFBTCxHQUFxQixLQUFLRyxhQUFMLENBQW1CTixXQUFuQixDQUFyQjtBQUNEOztBQUVETyxFQUFBQSxRQUFRLENBQUNDLFFBQUQsRUFBdUM7QUFDN0MsV0FBT0MsNkJBQVdDLE1BQVgsQ0FBa0JDLFFBQVEsSUFBSTtBQUNuQyxZQUFNQyxZQUFZLEdBQUcsSUFBSVIseUJBQUosRUFBckI7QUFDQSxZQUFNUyxHQUFHLEdBQUcsRUFBWixDQUZtQyxDQUVuQjs7QUFDaEIsV0FBS1gsa0JBQUwsQ0FBd0JZLEdBQXhCLENBQTRCRCxHQUE1QixFQUFpQztBQUFDRixRQUFBQSxRQUFEO0FBQVdDLFFBQUFBO0FBQVgsT0FBakM7O0FBQ0EsV0FBS1gsU0FBTCxDQUFlYyxJQUFmLENBQW9CO0FBQUNGLFFBQUFBLEdBQUQ7QUFBTUwsUUFBQUE7QUFBTixPQUFwQjs7QUFDQSxhQUFPLE1BQU07QUFDWCxhQUFLTixrQkFBTCxDQUF3QmMsTUFBeEIsQ0FBK0JILEdBQS9COztBQUNBRCxRQUFBQSxZQUFZLENBQUNHLElBQWI7QUFDRCxPQUhEO0FBSUQsS0FUTSxDQUFQO0FBVUQ7QUFFRDs7Ozs7QUFHQUUsRUFBQUEsT0FBTyxHQUFHO0FBQ1IsU0FBS2Ysa0JBQUwsQ0FBd0JnQixPQUF4QixDQUFnQyxDQUFDO0FBQUNQLE1BQUFBO0FBQUQsS0FBRCxLQUFnQjtBQUM5Q0EsTUFBQUEsUUFBUSxDQUFDUSxLQUFULENBQWVDLEtBQUssQ0FBQyw2QkFBRCxDQUFwQjtBQUNELEtBRkQ7O0FBR0EsU0FBS2pCLGFBQUwsQ0FBbUJrQixXQUFuQjtBQUNEOztBQUVEZixFQUFBQSxhQUFhLENBQUNOLFdBQUQsRUFBMEM7QUFDckQsV0FBTyxLQUFLQyxTQUFMLENBQ0pxQixRQURJLENBQ0tDLEtBQUssSUFBSTtBQUNqQixZQUFNO0FBQUNmLFFBQUFBLFFBQUQ7QUFBV0ssUUFBQUE7QUFBWCxVQUFrQlUsS0FBeEI7O0FBQ0EsWUFBTUMsUUFBUSxHQUFHLEtBQUt0QixrQkFBTCxDQUF3QnVCLEdBQXhCLENBQTRCWixHQUE1QixDQUFqQixDQUZpQixDQUdqQjs7O0FBQ0EsVUFBSVcsUUFBUSxJQUFJLElBQWhCLEVBQXNCO0FBQ3BCLGVBQU9mLDZCQUFXaUIsS0FBWCxFQUFQO0FBQ0Q7O0FBQ0QsWUFBTTtBQUFDZixRQUFBQSxRQUFEO0FBQVdDLFFBQUFBO0FBQVgsVUFBMkJZLFFBQWpDO0FBQ0EsVUFBSUcsTUFBSjs7QUFDQSxVQUFJbkIsUUFBUSxZQUFZQyw0QkFBeEIsRUFBb0M7QUFDbENrQixRQUFBQSxNQUFNLEdBQUduQixRQUFUO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsWUFBSTtBQUNGbUIsVUFBQUEsTUFBTSxHQUFHbkIsUUFBUSxFQUFqQjtBQUNELFNBRkQsQ0FFRSxPQUFPb0IsR0FBUCxFQUFZO0FBQ1o7QUFDQWpCLFVBQUFBLFFBQVEsQ0FBQ1EsS0FBVCxDQUFlUyxHQUFmO0FBQ0EsaUJBQU9uQiw2QkFBV2lCLEtBQVgsRUFBUDtBQUNEO0FBQ0Y7O0FBQ0QsVUFBSUMsTUFBTSxZQUFZbEIsNEJBQXRCLEVBQWtDO0FBQ2hDO0FBQ0EsZUFDRWtCLE1BQU0sQ0FDSEUsU0FESCxDQUNhakIsWUFEYixFQUVFO0FBRkYsU0FHR2tCLEVBSEgsQ0FHTW5CLFFBSE4sRUFJR29CLEtBSkgsQ0FJUyxNQUFNdEIsNkJBQVdpQixLQUFYLEVBSmYsQ0FERjtBQU9ELE9BVEQsTUFTTztBQUNMO0FBQ0EsZUFDRWpCLDZCQUFXdUIsSUFBWCxDQUFnQkwsTUFBaEIsRUFDRTtBQURGLFNBRUdHLEVBRkgsQ0FFTW5CLFFBRk4sRUFHR29CLEtBSEgsQ0FHUyxNQUFNdEIsNkJBQVdpQixLQUFYLEVBSGYsQ0FERjtBQU1EO0FBQ0YsS0F2Q0ksRUF1Q0YxQixXQXZDRSxFQXdDSmlDLFNBeENJLEVBQVA7QUF5Q0Q7O0FBNUVvQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTctcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogQGZsb3cgc3RyaWN0XHJcbiAqIEBmb3JtYXRcclxuICovXHJcblxyXG5pbXBvcnQge09ic2VydmFibGUsIFN1YmplY3R9IGZyb20gJ3J4anMtY29tcGF0L2J1bmRsZXMvcnhqcy1jb21wYXQudW1kLm1pbi5qcyc7XHJcblxyXG50eXBlIEV4ZWN1dG9yPFQ+ID0gT2JzZXJ2YWJsZTxUPiB8ICgoKSA9PiByeGpzJE9ic2VydmFibGVJbnB1dDxUPik7XHJcblxyXG50eXBlIFJlcXVlc3Q8VD4gPSB7dGFnOiBtaXhlZCwgZXhlY3V0b3I6IEV4ZWN1dG9yPFQ+fTtcclxuXHJcbnR5cGUgUmVzcG9uc2U8VD4gPSB7XHJcbiAgb2JzZXJ2ZXI6IHJ4anMkT2JzZXJ2ZXI8VD4sXHJcbiAgdW5zdWJzY3JpYmVkOiBTdWJqZWN0PHZvaWQ+LFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIE9ic2VydmFibGVQb29sIGFsbG93cyB5b3UgdG8gZXhlY3V0ZSBPYnNlcnZhYmxlcyBvciBmdW5jdGlvbnMgdGhhdCByZXR1cm5cclxuICogT2JzZXJ2YWJsZSBpbnB1dHMgKGkuZS4gT2JzZXJ2YWJsZXMsIFByb21pc2VzLCBvciBJdGVyYWJsZXMpXHJcbiAqIHdpdGggYSBjb25jdXJyZW5jeSBsaW1pdC5cclxuICpcclxuICogRXhlY3V0aW9uIHJlcXVlc3RzIGFyZSBxdWV1ZWQgYW5kIHVuc3Vic2NyaXB0aW9ucyBhcmUgZm9yd2FyZGVkIHRocm91Z2hcclxuICogKGlmIGEgcmVxdWVzdCBpcyBzdGlsbCBvbiB0aGUgcXVldWUsIGl0cyBleGVjdXRpb24gd2lsbCBiZSBjYW5jZWxsZWQuKVxyXG4gKlxyXG4gKiBGb3IgcmVxdWVzdHMgdGhhdCByZXR1cm4gYSBQcm9taXNlLCB0aGUgT2JzZXJ2YWJsZVBvb2wgaXMgcGVzc2ltaXN0aWNcclxuICogYW5kIGFzc3VtZXMgdGhhdCB0aGUgb3BlcmF0aW9uIGlzIHVuY2FuY2VsbGFibGUgLSBpdCB3aWxsIG5vdCByZW1vdmVcclxuICogdGhlIGV4ZWN1dGlvbiBmcm9tIHRoZSBwb29sIHVudGlsIGl0IHJlc29sdmVzIG9yIHJlamVjdHMuIEhvd2V2ZXJcclxuICogYHNjaGVkdWxlKClgIHdpbGwgc3RpbGwgcmV0dXJuIGFuIE9ic2VydmFibGUgdG8gZW5hYmxlIHRoZSB1c2UgY2FzZVxyXG4gKiBvZiBjYW5jZWxsaW5nIHJlcXVlc3RzIHdoaWxlIHRoZXkncmUgaW4gdGhlIHF1ZXVlLlxyXG4gKlxyXG4gKiBFeGFtcGxlOlxyXG4gKlxyXG4gKiAgIGNvbnN0IHBvb2wgPSBuZXcgT2JzZXJ2YWJsZVBvb2woMik7XHJcbiAqICAgcG9vbFxyXG4gKiAgICAgLnNjaGVkdWxlKE9ic2VydmFibGUudGltZXIoMTAwMCkubWFwVG8oMSkpXHJcbiAqICAgICAuc3Vic2NyaWJlKGNvbnNvbGUubG9nKTtcclxuICogICBPYnNlcnZhYmxlLnRpbWVyKDEwMDApXHJcbiAqICAgICAubWFwVG8oMilcclxuICogICAgIC5sZXQocG9vbC5zY2hlZHVsZS5iaW5kKHBvb2wpKVxyXG4gKiAgICAgLnN1YnNjcmliZShjb25zb2xlLmxvZyk7XHJcbiAqICAgcG9vbFxyXG4gKiAgICAgLnNjaGVkdWxlKE9ic2VydmFibGUudGltZXIoMTAwKS5tYXBUbygzKSlcclxuICogICAgIC5zdWJzY3JpYmUoY29uc29sZS5sb2cpO1xyXG4gKlxyXG4gKiBUaGUgb3V0cHV0IGhlcmUgaXMgMSwgMiwgdGhlbiAzLiBEZXNwaXRlIHRoZSBmYWN0IHRoYXQgdGhlIHRoaXJkIG9ic2VydmFibGVcclxuICogZmluaXNoZXMgbW9yZSBxdWlja2x5LCBpdHMgZXhlY3V0aW9uIGlzIHBvc3Rwb25lZCB1bnRpbCB0aGUgZmlyc3QgdHdvIGZpbmlzaC5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9ic2VydmFibGVQb29sPFQ+IHtcclxuICBfcmVxdWVzdHM6IFN1YmplY3Q8UmVxdWVzdDxUPj47XHJcbiAgX3Jlc3BvbnNlTGlzdGVuZXJzOiBNYXA8bWl4ZWQsIFJlc3BvbnNlPFQ+PjtcclxuICBfc3Vic2NyaXB0aW9uOiByeGpzJElTdWJzY3JpcHRpb247XHJcblxyXG4gIGNvbnN0cnVjdG9yKGNvbmN1cnJlbmN5OiBudW1iZXIpIHtcclxuICAgIHRoaXMuX3JlcXVlc3RzID0gbmV3IFN1YmplY3QoKTtcclxuICAgIHRoaXMuX3Jlc3BvbnNlTGlzdGVuZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gdGhpcy5faGFuZGxlRXZlbnRzKGNvbmN1cnJlbmN5KTtcclxuICB9XHJcblxyXG4gIHNjaGVkdWxlKGV4ZWN1dG9yOiBFeGVjdXRvcjxUPik6IE9ic2VydmFibGU8VD4ge1xyXG4gICAgcmV0dXJuIE9ic2VydmFibGUuY3JlYXRlKG9ic2VydmVyID0+IHtcclxuICAgICAgY29uc3QgdW5zdWJzY3JpYmVkID0gbmV3IFN1YmplY3QoKTtcclxuICAgICAgY29uc3QgdGFnID0ge307IC8vIEp1c3QgYSB1bmlxdWUgb2JqZWN0LlxyXG4gICAgICB0aGlzLl9yZXNwb25zZUxpc3RlbmVycy5zZXQodGFnLCB7b2JzZXJ2ZXIsIHVuc3Vic2NyaWJlZH0pO1xyXG4gICAgICB0aGlzLl9yZXF1ZXN0cy5uZXh0KHt0YWcsIGV4ZWN1dG9yfSk7XHJcbiAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5fcmVzcG9uc2VMaXN0ZW5lcnMuZGVsZXRlKHRhZyk7XHJcbiAgICAgICAgdW5zdWJzY3JpYmVkLm5leHQoKTtcclxuICAgICAgfTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogV2FybmluZzogY2FsbGluZyBkaXNwb3NlKCkgd2lsbCBlcnJvciBhbGwgZXhlY3V0aW5nIHJlcXVlc3RzLlxyXG4gICAqL1xyXG4gIGRpc3Bvc2UoKSB7XHJcbiAgICB0aGlzLl9yZXNwb25zZUxpc3RlbmVycy5mb3JFYWNoKCh7b2JzZXJ2ZXJ9KSA9PiB7XHJcbiAgICAgIG9ic2VydmVyLmVycm9yKEVycm9yKCdPYnNlcnZhYmxlUG9vbCB3YXMgZGlzcG9zZWQnKSk7XHJcbiAgICB9KTtcclxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xyXG4gIH1cclxuXHJcbiAgX2hhbmRsZUV2ZW50cyhjb25jdXJyZW5jeTogbnVtYmVyKTogcnhqcyRJU3Vic2NyaXB0aW9uIHtcclxuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0c1xyXG4gICAgICAubWVyZ2VNYXAoZXZlbnQgPT4ge1xyXG4gICAgICAgIGNvbnN0IHtleGVjdXRvciwgdGFnfSA9IGV2ZW50O1xyXG4gICAgICAgIGNvbnN0IGxpc3RlbmVyID0gdGhpcy5fcmVzcG9uc2VMaXN0ZW5lcnMuZ2V0KHRhZyk7XHJcbiAgICAgICAgLy8gdW5zdWJzY3JpYmVkIGJlZm9yZSB3ZSBjb3VsZCBldmVuIGdldCB0byBpdCFcclxuICAgICAgICBpZiAobGlzdGVuZXIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgcmV0dXJuIE9ic2VydmFibGUuZW1wdHkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qge29ic2VydmVyLCB1bnN1YnNjcmliZWR9ID0gbGlzdGVuZXI7XHJcbiAgICAgICAgbGV0IHJlc3VsdDtcclxuICAgICAgICBpZiAoZXhlY3V0b3IgaW5zdGFuY2VvZiBPYnNlcnZhYmxlKSB7XHJcbiAgICAgICAgICByZXN1bHQgPSBleGVjdXRvcjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gZXhlY3V0b3IoKTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAvLyBDYXRjaCBlcnJvcnMgZnJvbSBleGVjdXRvcigpLlxyXG4gICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlcnIpO1xyXG4gICAgICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZS5lbXB0eSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgT2JzZXJ2YWJsZSkge1xyXG4gICAgICAgICAgLy8gV2UgY2FuIHNhZmVseSBmb3J3YXJkIHVuc3Vic2NyaXB0aW9ucyFcclxuICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIHJlc3VsdFxyXG4gICAgICAgICAgICAgIC50YWtlVW50aWwodW5zdWJzY3JpYmVkKVxyXG4gICAgICAgICAgICAgIC8vICRGbG93Rml4TWU6IEZsb3cgZG9lc24ndCBsaWtlIHRoaXMuXHJcbiAgICAgICAgICAgICAgLmRvKG9ic2VydmVyKVxyXG4gICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiBPYnNlcnZhYmxlLmVtcHR5KCkpXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBJbiB0aGUgYWJzZW5jZSBvZiBjYW5jZWxsYXRpb24sIGFzc3VtZSB0aGUgd29yc3QuXHJcbiAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICBPYnNlcnZhYmxlLmZyb20ocmVzdWx0KVxyXG4gICAgICAgICAgICAgIC8vICRGbG93Rml4TWU6IEZsb3cgZG9lc24ndCBsaWtlIHRoaXMuXHJcbiAgICAgICAgICAgICAgLmRvKG9ic2VydmVyKVxyXG4gICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiBPYnNlcnZhYmxlLmVtcHR5KCkpXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfSwgY29uY3VycmVuY3kpXHJcbiAgICAgIC5zdWJzY3JpYmUoKTtcclxuICB9XHJcbn1cclxuIl19