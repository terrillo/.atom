"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.splitStream = splitStream;
exports.bufferUntil = bufferUntil;
exports.cacheWhileSubscribed = cacheWhileSubscribed;
exports.diffSets = diffSets;
exports.reconcileSetDiffs = reconcileSetDiffs;
exports.reconcileSets = reconcileSets;
exports.toggle = toggle;
exports.compact = compact;
exports.takeWhileInclusive = takeWhileInclusive;
exports.concatLatest = concatLatest;
exports.throttle = throttle;
exports.completingSwitchMap = completingSwitchMap;
exports.mergeUntilAnyComplete = mergeUntilAnyComplete;
exports.fastDebounce = fastDebounce;
exports.fromAbortablePromise = fromAbortablePromise;
exports.toAbortablePromise = toAbortablePromise;
exports.takeUntilAbort = takeUntilAbort;
exports.poll = poll;
exports.SingletonExecutor = exports.nextAnimationFrame = exports.macrotask = exports.microtask = void 0;

var _UniversalDisposable = _interopRequireDefault(require("./UniversalDisposable"));

var _assert = _interopRequireDefault(require("assert"));

var _domexception = _interopRequireDefault(require("domexception"));

var _rxjsCompatUmdMin = require("rxjs-compat/bundles/rxjs-compat.umd.min.js");

var _AbortController = _interopRequireDefault(require("./AbortController"));

var _collection = require("./collection");

var _debounce = _interopRequireDefault(require("./debounce"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */

/* global requestAnimationFrame, cancelAnimationFrame */
// NOTE: Custom operators that require arguments should be written as higher-order functions. That
// is, they should accept the arguments and return a function that accepts only an observable. This
// allows a nice ergonomic way of using them with '.let()' (or a potential future pipe operator):
//
//     const makeExciting = (excitementLevel: number = 1) =>
//       (source: Observable<string>) =>
//         source.map(x => x + '!'.repeat(excitementLevel));
//
//     Observable.of('hey', 'everybody')
//       .let(makeExciting())
//       .subscribe(x => console.log(x));
// Note: DOMException is usable in Chrome but not in Node.

/**
 * Splits a stream of strings on newlines.
 * Includes the newlines in the resulting stream (if includeNewlines is true).
 * Sends any non-newline terminated data before closing.
 * Does not ensure a trailing newline.
 */
function splitStream(input, includeNewlines = true) {
  return _rxjsCompatUmdMin.Observable.create(observer => {
    let current = '';

    function onEnd() {
      if (current !== '') {
        observer.next(current);
        current = '';
      }
    }

    return input.subscribe(value => {
      const lines = value.split('\n');
      lines[0] = current + lines[0];
      current = lines.pop();

      if (includeNewlines) {
        lines.forEach(line => observer.next(line + '\n'));
      } else {
        lines.forEach(line => observer.next(line));
      }
    }, error => {
      onEnd();
      observer.error(error);
    }, () => {
      onEnd();
      observer.complete();
    });
  });
}
/**
 * Buffers until the predicate matches an element, then opens a new buffer.
 *
 * @param stream - The observable to buffer
 * @param predicate - A function that will be called every time an element is emitted from the
 *     source. The predicate is passed the current element as well as the buffer at that point
 *     (which includes the element). IMPORTANT: DO NOT MUTATE THE BUFFER. It returns a boolean
 *     specifying whether to complete the buffer (and begin a new one).
 */


function bufferUntil(condition) {
  return stream => _rxjsCompatUmdMin.Observable.create(observer => {
    let buffer = null;

    const flush = () => {
      if (buffer != null) {
        observer.next(buffer);
        buffer = null;
      }
    };

    return stream.subscribe(x => {
      if (buffer == null) {
        buffer = [];
      }

      buffer.push(x);

      if (condition(x, buffer)) {
        flush();
      }
    }, err => {
      flush();
      observer.error(err);
    }, () => {
      flush();
      observer.complete();
    });
  });
}
/**
 * Caches the latest element as long as there are subscribers. This is useful so that if consumers
 * unsubscribe and then subscribe much later, they do not get an ancient cached value.
 *
 * This is intended to be used with cold Observables. If you have a hot Observable, `cache(1)` will
 * be just fine because the hot Observable will continue producing values even when there are no
 * subscribers, so you can be assured that the cached values are up-to-date.
 */


function cacheWhileSubscribed(input) {
  return input.multicast(() => new _rxjsCompatUmdMin.ReplaySubject(1)).refCount();
}

/**
 * Given a stream of sets, return a stream of diffs.
 * **IMPORTANT:** These sets are assumed to be immutable by convention. Don't mutate them!
 */
function diffSets(hash) {
  return sets => _rxjsCompatUmdMin.Observable.concat(_rxjsCompatUmdMin.Observable.of(new Set()), // Always start with no items with an empty set
  sets).pairwise().map(([previous, next]) => ({
    added: (0, _collection.setDifference)(next, previous, hash),
    removed: (0, _collection.setDifference)(previous, next, hash)
  })).filter(diff => diff.added.size > 0 || diff.removed.size > 0);
}
/**
 * Give a stream of diffs, perform an action for each added item and dispose of the returned
 * disposable when the item is removed.
 */


function reconcileSetDiffs(diffs, addAction, hash_) {
  const hash = hash_ || (x => x);

  const itemsToDisposables = new Map();

  const disposeItem = item => {
    const disposable = itemsToDisposables.get(hash(item));
    (0, _assert.default)(disposable != null);
    disposable.dispose();
    itemsToDisposables.delete(item);
  };

  const disposeAll = () => {
    itemsToDisposables.forEach(disposable => {
      disposable.dispose();
    });
    itemsToDisposables.clear();
  };

  return new _UniversalDisposable.default(diffs.subscribe(diff => {
    // For every item that got added, perform the add action.
    diff.added.forEach(item => {
      itemsToDisposables.set(hash(item), addAction(item));
    }); // "Undo" the add action for each item that got removed.

    diff.removed.forEach(disposeItem);
  }), disposeAll);
}
/**
 * Given a stream of sets, perform a side-effect whenever an item is added (i.e. is present in a
 * set but wasn't in the previous set in the stream), and a corresponding cleanup when it's removed.
 * **IMPORTANT:** These sets are assumed to be immutable by convention. Don't mutate them!
 *
 * Example:
 *
 *    const dogs = Observable.of(
 *      new Set([{name: 'Winston', id: 1}, {name: 'Penelope', id: 2}]),
 *      new Set([{name: 'Winston', id: 1}]),
 *    );
 *    const disposable = reconcileSets(
 *      dogs,
 *      dog => {
 *        const notification = atom.notifications.addSuccess(
 *          `${dog.name} was added!`,
 *          {dismissable: true},
 *        );
 *        return new Disposable(() => { notification.dismiss(); });
 *      },
 *      dog => dog.id,
 *    );
 *
 * The above code will first add notifications saying "Winston was added!" and "Penelope was
 * added!", then dismiss the "Penelope" notification. Since the Winston object is in the final set
 * of the dogs observable, his notification will remain until `disposable.dispose()` is called, at
 * which point the cleanup for all remaining items will be performed.
 */


function reconcileSets(sets, addAction, hash) {
  const diffs = sets.let(diffSets(hash));
  return reconcileSetDiffs(diffs, addAction, hash);
}

function toggle(toggler) {
  return source => toggler.distinctUntilChanged().switchMap(enabled => enabled ? source : _rxjsCompatUmdMin.Observable.empty());
}

function compact(source) {
  // Flow does not understand the semantics of `filter`
  return source.filter(x => x != null);
}
/**
 * Like `takeWhile`, but includes the first item that doesn't match the predicate.
 */


function takeWhileInclusive(predicate) {
  return source => _rxjsCompatUmdMin.Observable.create(observer => source.subscribe(x => {
    observer.next(x);

    if (!predicate(x)) {
      observer.complete();
    }
  }, err => {
    observer.error(err);
  }, () => {
    observer.complete();
  }));
} // Concatenate the latest values from each input observable into one big list.
// Observables who have not emitted a value yet are treated as empty.


function concatLatest(...observables) {
  // First, tag all input observables with their index.
  // Flow errors with ambiguity without the explicit annotation.
  const tagged = observables.map((observable, index) => observable.map(list => [list, index]));
  return _rxjsCompatUmdMin.Observable.merge(...tagged).scan((accumulator, [list, index]) => {
    accumulator[index] = list;
    return accumulator;
  }, observables.map(x => [])).map(accumulator => [].concat(...accumulator));
} // Use a sentinel so we can distinguish between when `null` is emitted and when
// nothing is.


const NONE = {};

function throttle(delay, options = {
  leading: true
}) {
  let getDelay;

  switch (typeof delay) {
    case 'number':
      getDelay = () => _rxjsCompatUmdMin.Observable.timer(delay);

      break;

    case 'function':
      getDelay = delay;
      break;

    case 'object':
      getDelay = () => delay;

      break;

    default:
      throw new Error(`Invalid delay: ${delay}`);
  }

  return function doThrottle(source) {
    return _rxjsCompatUmdMin.Observable.create(observer => {
      const {
        leading = true
      } = options;
      const timerStarts = new _rxjsCompatUmdMin.Subject();
      let latestValue = NONE;
      let latestValueIsLeading = false;
      let shouldIgnore = false;

      const checkShouldNext = () => {
        if (!shouldIgnore && latestValue !== NONE) {
          // At this point, latestValue must be of type T
          latestValue = latestValue;
          const valueToDispatch = latestValue;
          shouldIgnore = true;

          if (leading || !latestValueIsLeading) {
            latestValue = NONE;
            observer.next(valueToDispatch);
          }

          timerStarts.next(valueToDispatch);
        }
      };

      const sub = new _rxjsCompatUmdMin.Subscription();
      sub.add(timerStarts.switchMap(x => {
        const timer = getDelay(x);

        if (timer instanceof _rxjsCompatUmdMin.Observable) {
          return timer.take(1);
        } else {
          return timer;
        }
      }).subscribe(() => {
        shouldIgnore = false;
        latestValueIsLeading = false;
        checkShouldNext();
      }));
      sub.add(source.subscribe({
        next: x => {
          latestValue = x;
          latestValueIsLeading = true;
          checkShouldNext();
        },
        error: err => {
          observer.error(err);
        },
        complete: () => {
          // Ensure we don't hold a reference to the last value.
          latestValue = NONE;
          observer.complete();
        }
      }));
      return sub;
    });
  };
}
/**
 * Returns a new function which takes an `observable` and returns
 * `observable.switchMap(project)`, except that it completes
 * when the outer observable completes.
 *
 * Example:
 *
 *   Observable.of(1)
 *     .let(completingSwitchMap(x => Observable.never()))
 *
 * ends up returning an Observable that completes immediately.
 * With a regular switchMap, this would never terminate.
 */


function completingSwitchMap(project) {
  // An alternative implementation is to materialize the input observable,
  // but this avoids the creation of extra notifier objects.
  const completedSymbol = Symbol('completed');
  return observable => _rxjsCompatUmdMin.Observable.concat(observable, _rxjsCompatUmdMin.Observable.of(completedSymbol)).switchMap((input, index) => {
    if (input === completedSymbol) {
      return _rxjsCompatUmdMin.Observable.empty();
    }

    return project(input, index);
  });
}
/**
 * Returns a new observable consisting of the merged values from the passed
 * observables and completes when the first inner observable completes.
 */


function mergeUntilAnyComplete(...observables) {
  const notifications = _rxjsCompatUmdMin.Observable.merge(...observables.map(o => o.materialize())); // $FlowFixMe add dematerialize to rxjs Flow types


  return notifications.dematerialize();
}
/**
 * RxJS's debounceTime is actually fairly inefficient:
 * on each event, it always clears its interval and [creates a new one][1].
 * Until this is fixed, this uses our debounce implementation which
 * reuses a timeout and just sets a timestamp when possible.
 *
 * This may seem like a micro-optimization but we often use debounces
 * for very hot events, like keypresses. Exceeding the frame budget can easily lead
 * to increased key latency!
 *
 * [1]: https://github.com/ReactiveX/rxjs/blob/master/src/operators/debounceTime.ts#L106
 */


function fastDebounce(delay) {
  return observable => _rxjsCompatUmdMin.Observable.create(observer => {
    const debouncedNext = (0, _debounce.default)(x => observer.next(x), delay);
    const subscription = observable.subscribe(debouncedNext, observer.error.bind(observer), observer.complete.bind(observer));
    return new _UniversalDisposable.default(subscription, debouncedNext);
  });
}

const microtask = _rxjsCompatUmdMin.Observable.create(observer => {
  process.nextTick(() => {
    observer.next();
    observer.complete();
  });
});

exports.microtask = microtask;

const macrotask = _rxjsCompatUmdMin.Observable.create(observer => {
  const timerId = setImmediate(() => {
    observer.next();
    observer.complete();
  });
  return () => {
    clearImmediate(timerId);
  };
});

exports.macrotask = macrotask;

const nextAnimationFrame = _rxjsCompatUmdMin.Observable.create(observer => {
  if (typeof requestAnimationFrame === 'undefined') {
    throw new Error('This util can only be used in Atom');
  }

  const id = requestAnimationFrame(() => {
    observer.next();
    observer.complete();
  });
  return () => {
    cancelAnimationFrame(id);
  };
});
/**
 * Creates an Observable around an abortable promise.
 * Unsubscriptions are forwarded to the AbortController as an `abort()`.
 * Example usage (with an abortable fetch):
 *
 *   fromPromise(signal => fetch(url, {...options, signal}))
 *     .switchMap(....)
 *
 * Note that this can take a normal `() => Promise<T>` too
 * (in which case this acts as just a plain `Observable.defer`).
 */


exports.nextAnimationFrame = nextAnimationFrame;

function fromAbortablePromise(func) {
  return _rxjsCompatUmdMin.Observable.create(observer => {
    let completed = false;
    const abortController = new _AbortController.default();
    func(abortController.signal).then(value => {
      completed = true;
      observer.next(value);
      observer.complete();
    }, error => {
      completed = true;
      observer.error(error);
    });
    return () => {
      if (!completed) {
        abortController.abort(); // If the promise adheres to the spec, it should throw.
        // The error will be captured above but go into the void.
      }
    };
  });
}
/**
 * Converts an observable + AbortSignal into a cancellable Promise,
 * which rejects with an AbortError DOMException on abort.
 * Useful when writing the internals of a cancellable promise.
 *
 * Usage:
 *
 *   function abortableFunction(arg1: blah, options?: {signal?: AbortSignal}): Promise {
 *     return toPromise(
 *       observableFunction(arg1, options),
 *       options && options.signal,
 *     );
 *   }
 *
 * Could eventually be replaced by Observable.first if
 * https://github.com/whatwg/dom/issues/544 goes through.
 *
 * It's currently unclear if this should be usable with let/pipe:
 * https://github.com/ReactiveX/rxjs/issues/3445
 */


function toAbortablePromise(observable, signal) {
  if (signal == null) {
    return observable.toPromise();
  }

  if (signal.aborted) {
    return Promise.reject((0, _domexception.default)('Aborted', 'AbortError'));
  }

  return observable.race(_rxjsCompatUmdMin.Observable.fromEvent(signal, 'abort').map(() => {
    throw new _domexception.default('Aborted', 'AbortError');
  })).toPromise();
}
/**
 * When using Observables with AbortSignals, be sure to use this -
 * it's really easy to miss the case when the signal is already aborted!
 * Recommended to use this with let/pipe:
 *
 *   myObservable
 *     .let(takeUntilAbort(signal))
 */


function takeUntilAbort(signal) {
  return observable => _rxjsCompatUmdMin.Observable.defer(() => {
    if (signal.aborted) {
      return _rxjsCompatUmdMin.Observable.empty();
    }

    return observable.takeUntil(_rxjsCompatUmdMin.Observable.fromEvent(signal, 'abort'));
  });
} // Executes tasks. Ensures that at most one task is running at a time.
// This class is handy for expensive tasks like processes, provided
// you never want the result of a previous task after a new task has started.


class SingletonExecutor {
  constructor() {
    this._abortController = null;
  }

  // Executes(subscribes to) the task.
  // Will terminate(unsubscribe) to any previously executing task.
  // Subsequent executes() will terminate this task if called before
  // this task completes.
  async execute(createTask) {
    // Kill any previously running processes
    this.cancel(); // Start a new process

    const controller = new _AbortController.default();
    this._abortController = controller; // Wait for the process to complete or be canceled ...

    try {
      return await toAbortablePromise(createTask, controller.signal);
    } finally {
      // ... and always clean up if we haven't been canceled already.
      if (controller === this._abortController) {
        this._abortController = null;
      }
    }
  }

  isExecuting() {
    return this._abortController != null;
  } // Cancels any currently executing tasks.


  cancel() {
    if (this._abortController != null) {
      this._abortController.abort();

      this._abortController = null;
    }
  }

}
/**
 * Repeatedly subscribe to an observable every `delay` milliseconds, waiting for the observable to
 * complete each time. This is preferable to, say, `Observable.interval(d).switchMap(() => source)`
 * because, in the case that `source` takes longer than `d` milliseconds to produce a value, that
 * formulation will never produce a value (while continuing to incur the overhead of subscribing to
 * source).
 *
 * Example:
 *
 *    // Ask what time it is every second until it's Friday.
 *    runCommand('date')
 *      .let(poll(1000))
 *      .filter(output => output.startsWith('Fri'))
 *      .take(1)
 *      .subscribe(() => {
 *        console.log("IT'S FRIDAY!!")
 *      });
 *
 */


exports.SingletonExecutor = SingletonExecutor;

function poll(delay) {
  return source => _rxjsCompatUmdMin.Observable.defer(() => {
    const delays = new _rxjsCompatUmdMin.Subject();
    return delays.switchMap(n => _rxjsCompatUmdMin.Observable.timer(n)).merge(_rxjsCompatUmdMin.Observable.of(null)).switchMap(() => {
      const subscribedAt = Date.now();
      return source.do({
        complete: () => {
          const timeElapsed = Date.now() - subscribedAt;
          delays.next(Math.max(0, delay - timeElapsed));
        }
      });
    });
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zL29ic2VydmFibGUuanMiXSwibmFtZXMiOlsic3BsaXRTdHJlYW0iLCJpbnB1dCIsImluY2x1ZGVOZXdsaW5lcyIsIk9ic2VydmFibGUiLCJjcmVhdGUiLCJvYnNlcnZlciIsImN1cnJlbnQiLCJvbkVuZCIsIm5leHQiLCJzdWJzY3JpYmUiLCJ2YWx1ZSIsImxpbmVzIiwic3BsaXQiLCJwb3AiLCJmb3JFYWNoIiwibGluZSIsImVycm9yIiwiY29tcGxldGUiLCJidWZmZXJVbnRpbCIsImNvbmRpdGlvbiIsInN0cmVhbSIsImJ1ZmZlciIsImZsdXNoIiwieCIsInB1c2giLCJlcnIiLCJjYWNoZVdoaWxlU3Vic2NyaWJlZCIsIm11bHRpY2FzdCIsIlJlcGxheVN1YmplY3QiLCJyZWZDb3VudCIsImRpZmZTZXRzIiwiaGFzaCIsInNldHMiLCJjb25jYXQiLCJvZiIsIlNldCIsInBhaXJ3aXNlIiwibWFwIiwicHJldmlvdXMiLCJhZGRlZCIsInJlbW92ZWQiLCJmaWx0ZXIiLCJkaWZmIiwic2l6ZSIsInJlY29uY2lsZVNldERpZmZzIiwiZGlmZnMiLCJhZGRBY3Rpb24iLCJoYXNoXyIsIml0ZW1zVG9EaXNwb3NhYmxlcyIsIk1hcCIsImRpc3Bvc2VJdGVtIiwiaXRlbSIsImRpc3Bvc2FibGUiLCJnZXQiLCJkaXNwb3NlIiwiZGVsZXRlIiwiZGlzcG9zZUFsbCIsImNsZWFyIiwiVW5pdmVyc2FsRGlzcG9zYWJsZSIsInNldCIsInJlY29uY2lsZVNldHMiLCJsZXQiLCJ0b2dnbGUiLCJ0b2dnbGVyIiwic291cmNlIiwiZGlzdGluY3RVbnRpbENoYW5nZWQiLCJzd2l0Y2hNYXAiLCJlbmFibGVkIiwiZW1wdHkiLCJjb21wYWN0IiwidGFrZVdoaWxlSW5jbHVzaXZlIiwicHJlZGljYXRlIiwiY29uY2F0TGF0ZXN0Iiwib2JzZXJ2YWJsZXMiLCJ0YWdnZWQiLCJvYnNlcnZhYmxlIiwiaW5kZXgiLCJsaXN0IiwibWVyZ2UiLCJzY2FuIiwiYWNjdW11bGF0b3IiLCJOT05FIiwidGhyb3R0bGUiLCJkZWxheSIsIm9wdGlvbnMiLCJsZWFkaW5nIiwiZ2V0RGVsYXkiLCJ0aW1lciIsIkVycm9yIiwiZG9UaHJvdHRsZSIsInRpbWVyU3RhcnRzIiwiU3ViamVjdCIsImxhdGVzdFZhbHVlIiwibGF0ZXN0VmFsdWVJc0xlYWRpbmciLCJzaG91bGRJZ25vcmUiLCJjaGVja1Nob3VsZE5leHQiLCJ2YWx1ZVRvRGlzcGF0Y2giLCJzdWIiLCJTdWJzY3JpcHRpb24iLCJhZGQiLCJ0YWtlIiwiY29tcGxldGluZ1N3aXRjaE1hcCIsInByb2plY3QiLCJjb21wbGV0ZWRTeW1ib2wiLCJTeW1ib2wiLCJtZXJnZVVudGlsQW55Q29tcGxldGUiLCJub3RpZmljYXRpb25zIiwibyIsIm1hdGVyaWFsaXplIiwiZGVtYXRlcmlhbGl6ZSIsImZhc3REZWJvdW5jZSIsImRlYm91bmNlZE5leHQiLCJzdWJzY3JpcHRpb24iLCJiaW5kIiwibWljcm90YXNrIiwicHJvY2VzcyIsIm5leHRUaWNrIiwibWFjcm90YXNrIiwidGltZXJJZCIsInNldEltbWVkaWF0ZSIsImNsZWFySW1tZWRpYXRlIiwibmV4dEFuaW1hdGlvbkZyYW1lIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiaWQiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImZyb21BYm9ydGFibGVQcm9taXNlIiwiZnVuYyIsImNvbXBsZXRlZCIsImFib3J0Q29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsInNpZ25hbCIsInRoZW4iLCJhYm9ydCIsInRvQWJvcnRhYmxlUHJvbWlzZSIsInRvUHJvbWlzZSIsImFib3J0ZWQiLCJQcm9taXNlIiwicmVqZWN0IiwicmFjZSIsImZyb21FdmVudCIsIkRPTUV4Y2VwdGlvbiIsInRha2VVbnRpbEFib3J0IiwiZGVmZXIiLCJ0YWtlVW50aWwiLCJTaW5nbGV0b25FeGVjdXRvciIsIl9hYm9ydENvbnRyb2xsZXIiLCJleGVjdXRlIiwiY3JlYXRlVGFzayIsImNhbmNlbCIsImNvbnRyb2xsZXIiLCJpc0V4ZWN1dGluZyIsInBvbGwiLCJkZWxheXMiLCJuIiwic3Vic2NyaWJlZEF0IiwiRGF0ZSIsIm5vdyIsImRvIiwidGltZUVsYXBzZWQiLCJNYXRoIiwibWF4Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNEJBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7O0FBbkNBOzs7Ozs7Ozs7Ozs7QUFZQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTs7QUFPQTs7Ozs7O0FBTU8sU0FBU0EsV0FBVCxDQUNMQyxLQURLLEVBRUxDLGVBQXlCLEdBQUcsSUFGdkIsRUFHZTtBQUNwQixTQUFPQyw2QkFBV0MsTUFBWCxDQUFrQkMsUUFBUSxJQUFJO0FBQ25DLFFBQUlDLE9BQWUsR0FBRyxFQUF0Qjs7QUFFQSxhQUFTQyxLQUFULEdBQWlCO0FBQ2YsVUFBSUQsT0FBTyxLQUFLLEVBQWhCLEVBQW9CO0FBQ2xCRCxRQUFBQSxRQUFRLENBQUNHLElBQVQsQ0FBY0YsT0FBZDtBQUNBQSxRQUFBQSxPQUFPLEdBQUcsRUFBVjtBQUNEO0FBQ0Y7O0FBRUQsV0FBT0wsS0FBSyxDQUFDUSxTQUFOLENBQ0xDLEtBQUssSUFBSTtBQUNQLFlBQU1DLEtBQUssR0FBR0QsS0FBSyxDQUFDRSxLQUFOLENBQVksSUFBWixDQUFkO0FBQ0FELE1BQUFBLEtBQUssQ0FBQyxDQUFELENBQUwsR0FBV0wsT0FBTyxHQUFHSyxLQUFLLENBQUMsQ0FBRCxDQUExQjtBQUNBTCxNQUFBQSxPQUFPLEdBQUdLLEtBQUssQ0FBQ0UsR0FBTixFQUFWOztBQUNBLFVBQUlYLGVBQUosRUFBcUI7QUFDbkJTLFFBQUFBLEtBQUssQ0FBQ0csT0FBTixDQUFjQyxJQUFJLElBQUlWLFFBQVEsQ0FBQ0csSUFBVCxDQUFjTyxJQUFJLEdBQUcsSUFBckIsQ0FBdEI7QUFDRCxPQUZELE1BRU87QUFDTEosUUFBQUEs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Q0FGLFVBQUFBLE1BQU0sQ0FBQ2hKLElBQVAsQ0FBWXVKLElBQUksQ0FBQ0MsR0FBTCxDQUFTLENBQVQsRUFBWTdFLEtBQUssR0FBRzJFLFdBQXBCLENBQVo7QUFDRDtBQUpjLE9BQVYsQ0FBUDtBQU1ELEtBWEksQ0FBUDtBQVlELEdBZEQsQ0FERjtBQWdCRCIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTctcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogQGZsb3dcclxuICogQGZvcm1hdFxyXG4gKi9cclxuXHJcbi8qIGdsb2JhbCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIGNhbmNlbEFuaW1hdGlvbkZyYW1lICovXHJcblxyXG4vLyBOT1RFOiBDdXN0b20gb3BlcmF0b3JzIHRoYXQgcmVxdWlyZSBhcmd1bWVudHMgc2hvdWxkIGJlIHdyaXR0ZW4gYXMgaGlnaGVyLW9yZGVyIGZ1bmN0aW9ucy4gVGhhdFxyXG4vLyBpcywgdGhleSBzaG91bGQgYWNjZXB0IHRoZSBhcmd1bWVudHMgYW5kIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBvbmx5IGFuIG9ic2VydmFibGUuIFRoaXNcclxuLy8gYWxsb3dzIGEgbmljZSBlcmdvbm9taWMgd2F5IG9mIHVzaW5nIHRoZW0gd2l0aCAnLmxldCgpJyAob3IgYSBwb3RlbnRpYWwgZnV0dXJlIHBpcGUgb3BlcmF0b3IpOlxyXG4vL1xyXG4vLyAgICAgY29uc3QgbWFrZUV4Y2l0aW5nID0gKGV4Y2l0ZW1lbnRMZXZlbDogbnVtYmVyID0gMSkgPT5cclxuLy8gICAgICAgKHNvdXJjZTogT2JzZXJ2YWJsZTxzdHJpbmc+KSA9PlxyXG4vLyAgICAgICAgIHNvdXJjZS5tYXAoeCA9PiB4ICsgJyEnLnJlcGVhdChleGNpdGVtZW50TGV2ZWwpKTtcclxuLy9cclxuLy8gICAgIE9ic2VydmFibGUub2YoJ2hleScsICdldmVyeWJvZHknKVxyXG4vLyAgICAgICAubGV0KG1ha2VFeGNpdGluZygpKVxyXG4vLyAgICAgICAuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xyXG5cclxuaW1wb3J0IHR5cGUge0Fib3J0U2lnbmFsfSBmcm9tICcuL0Fib3J0Q29udHJvbGxlcic7XHJcblxyXG5pbXBvcnQgVW5pdmVyc2FsRGlzcG9zYWJsZSBmcm9tICcuL1VuaXZlcnNhbERpc3Bvc2FibGUnO1xyXG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2Fzc2VydCc7XHJcbi8vIE5vdGU6IERPTUV4Y2VwdGlvbiBpcyB1c2FibGUgaW4gQ2hyb21lIGJ1dCBub3QgaW4gTm9kZS5cclxuaW1wb3J0IERPTUV4Y2VwdGlvbiBmcm9tICdkb21leGNlcHRpb24nO1xyXG5pbXBvcnQge09ic2VydmFibGUsIFJlcGxheVN1YmplY3QsIFN1YmplY3QsIFN1YnNjcmlwdGlvbn0gZnJvbSAncnhqcy1jb21wYXQvYnVuZGxlcy9yeGpzLWNvbXBhdC51bWQubWluLmpzJztcclxuaW1wb3J0IEFib3J0Q29udHJvbGxlciBmcm9tICcuL0Fib3J0Q29udHJvbGxlcic7XHJcbmltcG9ydCB7c2V0RGlmZmVyZW5jZX0gZnJvbSAnLi9jb2xsZWN0aW9uJztcclxuaW1wb3J0IGRlYm91bmNlIGZyb20gJy4vZGVib3VuY2UnO1xyXG5cclxuLyoqXHJcbiAqIFNwbGl0cyBhIHN0cmVhbSBvZiBzdHJpbmdzIG9uIG5ld2xpbmVzLlxyXG4gKiBJbmNsdWRlcyB0aGUgbmV3bGluZXMgaW4gdGhlIHJlc3VsdGluZyBzdHJlYW0gKGlmIGluY2x1ZGVOZXdsaW5lcyBpcyB0cnVlKS5cclxuICogU2VuZHMgYW55IG5vbi1uZXdsaW5lIHRlcm1pbmF0ZWQgZGF0YSBiZWZvcmUgY2xvc2luZy5cclxuICogRG9lcyBub3QgZW5zdXJlIGEgdHJhaWxpbmcgbmV3bGluZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzcGxpdFN0cmVhbShcclxuICBpbnB1dDogT2JzZXJ2YWJsZTxzdHJpbmc+LFxyXG4gIGluY2x1ZGVOZXdsaW5lcz86IGJvb2xlYW4gPSB0cnVlLFxyXG4pOiBPYnNlcnZhYmxlPHN0cmluZz4ge1xyXG4gIHJldHVybiBPYnNlcnZhYmxlLmNyZWF0ZShvYnNlcnZlciA9PiB7XHJcbiAgICBsZXQgY3VycmVudDogc3RyaW5nID0gJyc7XHJcblxyXG4gICAgZnVuY3Rpb24gb25FbmQoKSB7XHJcbiAgICAgIGlmIChjdXJyZW50ICE9PSAnJykge1xyXG4gICAgICAgIG9ic2VydmVyLm5leHQoY3VycmVudCk7XHJcbiAgICAgICAgY3VycmVudCA9ICcnO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGlucHV0LnN1YnNjcmliZShcclxuICAgICAgdmFsdWUgPT4ge1xyXG4gICAgICAgIGNvbnN0IGxpbmVzID0gdmFsdWUuc3BsaXQoJ1xcbicpO1xyXG4gICAgICAgIGxpbmVzWzBdID0gY3VycmVudCArIGxpbmVzWzBdO1xyXG4gICAgICAgIGN1cnJlbnQgPSBsaW5lcy5wb3AoKTtcclxuICAgICAgICBpZiAoaW5jbHVkZU5ld2xpbmVzKSB7XHJcbiAgICAgICAgICBsaW5lcy5mb3JFYWNoKGxpbmUgPT4gb2JzZXJ2ZXIubmV4dChsaW5lICsgJ1xcbicpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbGluZXMuZm9yRWFjaChsaW5lID0+IG9ic2VydmVyLm5leHQobGluZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgZXJyb3IgPT4ge1xyXG4gICAgICAgIG9uRW5kKCk7XHJcbiAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZXJyb3IpO1xyXG4gICAgICB9LFxyXG4gICAgICAoKSA9PiB7XHJcbiAgICAgICAgb25FbmQoKTtcclxuICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xyXG4gICAgICB9LFxyXG4gICAgKTtcclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEJ1ZmZlcnMgdW50aWwgdGhlIHByZWRpY2F0ZSBtYXRjaGVzIGFuIGVsZW1lbnQsIHRoZW4gb3BlbnMgYSBuZXcgYnVmZmVyLlxyXG4gKlxyXG4gKiBAcGFyYW0gc3RyZWFtIC0gVGhlIG9ic2VydmFibGUgdG8gYnVmZmVyXHJcbiAqIEBwYXJhbSBwcmVkaWNhdGUgLSBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgZXZlcnkgdGltZSBhbiBlbGVtZW50IGlzIGVtaXR0ZWQgZnJvbSB0aGVcclxuICogICAgIHNvdXJjZS4gVGhlIHByZWRpY2F0ZSBpcyBwYXNzZWQgdGhlIGN1cnJlbnQgZWxlbWVudCBhcyB3ZWxsIGFzIHRoZSBidWZmZXIgYXQgdGhhdCBwb2ludFxyXG4gKiAgICAgKHdoaWNoIGluY2x1ZGVzIHRoZSBlbGVtZW50KS4gSU1QT1JUQU5UOiBETyBOT1QgTVVUQVRFIFRIRSBCVUZGRVIuIEl0IHJldHVybnMgYSBib29sZWFuXHJcbiAqICAgICBzcGVjaWZ5aW5nIHdoZXRoZXIgdG8gY29tcGxldGUgdGhlIGJ1ZmZlciAoYW5kIGJlZ2luIGEgbmV3IG9uZSkuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYnVmZmVyVW50aWw8VD4oXHJcbiAgY29uZGl0aW9uOiAoaXRlbTogVCwgYnVmZmVyOiBBcnJheTxUPikgPT4gYm9vbGVhbixcclxuKTogKE9ic2VydmFibGU8VD4pID0+IE9ic2VydmFibGU8QXJyYXk8VD4+IHtcclxuICByZXR1cm4gKHN0cmVhbTogT2JzZXJ2YWJsZTxUPikgPT5cclxuICAgIE9ic2VydmFibGUuY3JlYXRlKG9ic2VydmVyID0+IHtcclxuICAgICAgbGV0IGJ1ZmZlciA9IG51bGw7XHJcbiAgICAgIGNvbnN0IGZsdXNoID0gKCkgPT4ge1xyXG4gICAgICAgIGlmIChidWZmZXIgIT0gbnVsbCkge1xyXG4gICAgICAgICAgb2JzZXJ2ZXIubmV4dChidWZmZXIpO1xyXG4gICAgICAgICAgYnVmZmVyID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBzdHJlYW0uc3Vic2NyaWJlKFxyXG4gICAgICAgIHggPT4ge1xyXG4gICAgICAgICAgaWYgKGJ1ZmZlciA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGJ1ZmZlciA9IFtdO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnVmZmVyLnB1c2goeCk7XHJcbiAgICAgICAgICBpZiAoY29uZGl0aW9uKHgsIGJ1ZmZlcikpIHtcclxuICAgICAgICAgICAgZmx1c2goKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGVyciA9PiB7XHJcbiAgICAgICAgICBmbHVzaCgpO1xyXG4gICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZXJyKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgICgpID0+IHtcclxuICAgICAgICAgIGZsdXNoKCk7XHJcbiAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENhY2hlcyB0aGUgbGF0ZXN0IGVsZW1lbnQgYXMgbG9uZyBhcyB0aGVyZSBhcmUgc3Vic2NyaWJlcnMuIFRoaXMgaXMgdXNlZnVsIHNvIHRoYXQgaWYgY29uc3VtZXJzXHJcbiAqIHVuc3Vic2NyaWJlIGFuZCB0aGVuIHN1YnNjcmliZSBtdWNoIGxhdGVyLCB0aGV5IGRvIG5vdCBnZXQgYW4gYW5jaWVudCBjYWNoZWQgdmFsdWUuXHJcbiAqXHJcbiAqIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZCB3aXRoIGNvbGQgT2JzZXJ2YWJsZXMuIElmIHlvdSBoYXZlIGEgaG90IE9ic2VydmFibGUsIGBjYWNoZSgxKWAgd2lsbFxyXG4gKiBiZSBqdXN0IGZpbmUgYmVjYXVzZSB0aGUgaG90IE9ic2VydmFibGUgd2lsbCBjb250aW51ZSBwcm9kdWNpbmcgdmFsdWVzIGV2ZW4gd2hlbiB0aGVyZSBhcmUgbm9cclxuICogc3Vic2NyaWJlcnMsIHNvIHlvdSBjYW4gYmUgYXNzdXJlZCB0aGF0IHRoZSBjYWNoZWQgdmFsdWVzIGFyZSB1cC10by1kYXRlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNhY2hlV2hpbGVTdWJzY3JpYmVkPFQ+KGlucHV0OiBPYnNlcnZhYmxlPFQ+KTogT2JzZXJ2YWJsZTxUPiB7XHJcbiAgcmV0dXJuIGlucHV0Lm11bHRpY2FzdCgoKSA9PiBuZXcgUmVwbGF5U3ViamVjdCgxKSkucmVmQ291bnQoKTtcclxufVxyXG5cclxudHlwZSBEaWZmPFQ+ID0ge1xyXG4gIGFkZGVkOiBTZXQ8VD4sXHJcbiAgcmVtb3ZlZDogU2V0PFQ+LFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdpdmVuIGEgc3RyZWFtIG9mIHNldHMsIHJldHVybiBhIHN0cmVhbSBvZiBkaWZmcy5cclxuICogKipJTVBPUlRBTlQ6KiogVGhlc2Ugc2V0cyBhcmUgYXNzdW1lZCB0byBiZSBpbW11dGFibGUgYnkgY29udmVudGlvbi4gRG9uJ3QgbXV0YXRlIHRoZW0hXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZGlmZlNldHM8VD4oXHJcbiAgaGFzaD86ICh2OiBUKSA9PiBhbnksXHJcbik6IChPYnNlcnZhYmxlPFNldDxUPj4pID0+IE9ic2VydmFibGU8RGlmZjxUPj4ge1xyXG4gIHJldHVybiAoc2V0czogT2JzZXJ2YWJsZTxTZXQ8VD4+KSA9PlxyXG4gICAgT2JzZXJ2YWJsZS5jb25jYXQoXHJcbiAgICAgIE9ic2VydmFibGUub2YobmV3IFNldCgpKSwgLy8gQWx3YXlzIHN0YXJ0IHdpdGggbm8gaXRlbXMgd2l0aCBhbiBlbXB0eSBzZXRcclxuICAgICAgc2V0cyxcclxuICAgIClcclxuICAgICAgLnBhaXJ3aXNlKClcclxuICAgICAgLm1hcCgoW3ByZXZpb3VzLCBuZXh0XSkgPT4gKHtcclxuICAgICAgICBhZGRlZDogc2V0RGlmZmVyZW5jZShuZXh0LCBwcmV2aW91cywgaGFzaCksXHJcbiAgICAgICAgcmVtb3ZlZDogc2V0RGlmZmVyZW5jZShwcmV2aW91cywgbmV4dCwgaGFzaCksXHJcbiAgICAgIH0pKVxyXG4gICAgICAuZmlsdGVyKGRpZmYgPT4gZGlmZi5hZGRlZC5zaXplID4gMCB8fCBkaWZmLnJlbW92ZWQuc2l6ZSA+IDApO1xyXG59XHJcblxyXG4vKipcclxuICogR2l2ZSBhIHN0cmVhbSBvZiBkaWZmcywgcGVyZm9ybSBhbiBhY3Rpb24gZm9yIGVhY2ggYWRkZWQgaXRlbSBhbmQgZGlzcG9zZSBvZiB0aGUgcmV0dXJuZWRcclxuICogZGlzcG9zYWJsZSB3aGVuIHRoZSBpdGVtIGlzIHJlbW92ZWQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcmVjb25jaWxlU2V0RGlmZnM8VD4oXHJcbiAgZGlmZnM6IE9ic2VydmFibGU8RGlmZjxUPj4sXHJcbiAgYWRkQWN0aW9uOiAoYWRkZWRJdGVtOiBUKSA9PiBJRGlzcG9zYWJsZSxcclxuICBoYXNoXz86ICh2OiBUKSA9PiBhbnksXHJcbik6IElEaXNwb3NhYmxlIHtcclxuICBjb25zdCBoYXNoID0gaGFzaF8gfHwgKHggPT4geCk7XHJcbiAgY29uc3QgaXRlbXNUb0Rpc3Bvc2FibGVzID0gbmV3IE1hcCgpO1xyXG4gIGNvbnN0IGRpc3Bvc2VJdGVtID0gaXRlbSA9PiB7XHJcbiAgICBjb25zdCBkaXNwb3NhYmxlID0gaXRlbXNUb0Rpc3Bvc2FibGVzLmdldChoYXNoKGl0ZW0pKTtcclxuICAgIGludmFyaWFudChkaXNwb3NhYmxlICE9IG51bGwpO1xyXG4gICAgZGlzcG9zYWJsZS5kaXNwb3NlKCk7XHJcbiAgICBpdGVtc1RvRGlzcG9zYWJsZXMuZGVsZXRlKGl0ZW0pO1xyXG4gIH07XHJcbiAgY29uc3QgZGlzcG9zZUFsbCA9ICgpID0+IHtcclxuICAgIGl0ZW1zVG9EaXNwb3NhYmxlcy5mb3JFYWNoKGRpc3Bvc2FibGUgPT4ge1xyXG4gICAgICBkaXNwb3NhYmxlLmRpc3Bvc2UoKTtcclxuICAgIH0pO1xyXG4gICAgaXRlbXNUb0Rpc3Bvc2FibGVzLmNsZWFyKCk7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIG5ldyBVbml2ZXJzYWxEaXNwb3NhYmxlKFxyXG4gICAgZGlmZnMuc3Vic2NyaWJlKGRpZmYgPT4ge1xyXG4gICAgICAvLyBGb3IgZXZlcnkgaXRlbSB0aGF0IGdvdCBhZGRlZCwgcGVyZm9ybSB0aGUgYWRkIGFjdGlvbi5cclxuICAgICAgZGlmZi5hZGRlZC5mb3JFYWNoKGl0ZW0gPT4ge1xyXG4gICAgICAgIGl0ZW1zVG9EaXNwb3NhYmxlcy5zZXQoaGFzaChpdGVtKSwgYWRkQWN0aW9uKGl0ZW0pKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBcIlVuZG9cIiB0aGUgYWRkIGFjdGlvbiBmb3IgZWFjaCBpdGVtIHRoYXQgZ290IHJlbW92ZWQuXHJcbiAgICAgIGRpZmYucmVtb3ZlZC5mb3JFYWNoKGRpc3Bvc2VJdGVtKTtcclxuICAgIH0pLFxyXG4gICAgZGlzcG9zZUFsbCxcclxuICApO1xyXG59XHJcblxyXG4vKipcclxuICogR2l2ZW4gYSBzdHJlYW0gb2Ygc2V0cywgcGVyZm9ybSBhIHNpZGUtZWZmZWN0IHdoZW5ldmVyIGFuIGl0ZW0gaXMgYWRkZWQgKGkuZS4gaXMgcHJlc2VudCBpbiBhXHJcbiAqIHNldCBidXQgd2Fzbid0IGluIHRoZSBwcmV2aW91cyBzZXQgaW4gdGhlIHN0cmVhbSksIGFuZCBhIGNvcnJlc3BvbmRpbmcgY2xlYW51cCB3aGVuIGl0J3MgcmVtb3ZlZC5cclxuICogKipJTVBPUlRBTlQ6KiogVGhlc2Ugc2V0cyBhcmUgYXNzdW1lZCB0byBiZSBpbW11dGFibGUgYnkgY29udmVudGlvbi4gRG9uJ3QgbXV0YXRlIHRoZW0hXHJcbiAqXHJcbiAqIEV4YW1wbGU6XHJcbiAqXHJcbiAqICAgIGNvbnN0IGRvZ3MgPSBPYnNlcnZhYmxlLm9mKFxyXG4gKiAgICAgIG5ldyBTZXQoW3tuYW1lOiAnV2luc3RvbicsIGlkOiAxfSwge25hbWU6ICdQZW5lbG9wZScsIGlkOiAyfV0pLFxyXG4gKiAgICAgIG5ldyBTZXQoW3tuYW1lOiAnV2luc3RvbicsIGlkOiAxfV0pLFxyXG4gKiAgICApO1xyXG4gKiAgICBjb25zdCBkaXNwb3NhYmxlID0gcmVjb25jaWxlU2V0cyhcclxuICogICAgICBkb2dzLFxyXG4gKiAgICAgIGRvZyA9PiB7XHJcbiAqICAgICAgICBjb25zdCBub3RpZmljYXRpb24gPSBhdG9tLm5vdGlmaWNhdGlvbnMuYWRkU3VjY2VzcyhcclxuICogICAgICAgICAgYCR7ZG9nLm5hbWV9IHdhcyBhZGRlZCFgLFxyXG4gKiAgICAgICAgICB7ZGlzbWlzc2FibGU6IHRydWV9LFxyXG4gKiAgICAgICAgKTtcclxuICogICAgICAgIHJldHVybiBuZXcgRGlzcG9zYWJsZSgoKSA9PiB7IG5vdGlmaWNhdGlvbi5kaXNtaXNzKCk7IH0pO1xyXG4gKiAgICAgIH0sXHJcbiAqICAgICAgZG9nID0+IGRvZy5pZCxcclxuICogICAgKTtcclxuICpcclxuICogVGhlIGFib3ZlIGNvZGUgd2lsbCBmaXJzdCBhZGQgbm90aWZpY2F0aW9ucyBzYXlpbmcgXCJXaW5zdG9uIHdhcyBhZGRlZCFcIiBhbmQgXCJQZW5lbG9wZSB3YXNcclxuICogYWRkZWQhXCIsIHRoZW4gZGlzbWlzcyB0aGUgXCJQZW5lbG9wZVwiIG5vdGlmaWNhdGlvbi4gU2luY2UgdGhlIFdpbnN0b24gb2JqZWN0IGlzIGluIHRoZSBmaW5hbCBzZXRcclxuICogb2YgdGhlIGRvZ3Mgb2JzZXJ2YWJsZSwgaGlzIG5vdGlmaWNhdGlvbiB3aWxsIHJlbWFpbiB1bnRpbCBgZGlzcG9zYWJsZS5kaXNwb3NlKClgIGlzIGNhbGxlZCwgYXRcclxuICogd2hpY2ggcG9pbnQgdGhlIGNsZWFudXAgZm9yIGFsbCByZW1haW5pbmcgaXRlbXMgd2lsbCBiZSBwZXJmb3JtZWQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcmVjb25jaWxlU2V0czxUPihcclxuICBzZXRzOiBPYnNlcnZhYmxlPFNldDxUPj4sXHJcbiAgYWRkQWN0aW9uOiAoYWRkZWRJdGVtOiBUKSA9PiBJRGlzcG9zYWJsZSxcclxuICBoYXNoPzogKHY6IFQpID0+IGFueSxcclxuKTogSURpc3Bvc2FibGUge1xyXG4gIGNvbnN0IGRpZmZzID0gc2V0cy5sZXQoZGlmZlNldHMoaGFzaCkpO1xyXG4gIHJldHVybiByZWNvbmNpbGVTZXREaWZmcyhkaWZmcywgYWRkQWN0aW9uLCBoYXNoKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvZ2dsZTxUPihcclxuICB0b2dnbGVyOiBPYnNlcnZhYmxlPGJvb2xlYW4+LFxyXG4pOiAoT2JzZXJ2YWJsZTxUPikgPT4gT2JzZXJ2YWJsZTxUPiB7XHJcbiAgcmV0dXJuIChzb3VyY2U6IE9ic2VydmFibGU8VD4pID0+XHJcbiAgICB0b2dnbGVyXHJcbiAgICAgIC5kaXN0aW5jdFVudGlsQ2hhbmdlZCgpXHJcbiAgICAgIC5zd2l0Y2hNYXAoZW5hYmxlZCA9PiAoZW5hYmxlZCA/IHNvdXJjZSA6IE9ic2VydmFibGUuZW1wdHkoKSkpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY29tcGFjdDxUPihzb3VyY2U6IE9ic2VydmFibGU8P1Q+KTogT2JzZXJ2YWJsZTxUPiB7XHJcbiAgLy8gRmxvdyBkb2VzIG5vdCB1bmRlcnN0YW5kIHRoZSBzZW1hbnRpY3Mgb2YgYGZpbHRlcmBcclxuICByZXR1cm4gKHNvdXJjZS5maWx0ZXIoeCA9PiB4ICE9IG51bGwpOiBhbnkpO1xyXG59XHJcblxyXG4vKipcclxuICogTGlrZSBgdGFrZVdoaWxlYCwgYnV0IGluY2x1ZGVzIHRoZSBmaXJzdCBpdGVtIHRoYXQgZG9lc24ndCBtYXRjaCB0aGUgcHJlZGljYXRlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRha2VXaGlsZUluY2x1c2l2ZTxUPihcclxuICBwcmVkaWNhdGU6ICh2YWx1ZTogVCkgPT4gYm9vbGVhbixcclxuKTogKE9ic2VydmFibGU8VD4pID0+IE9ic2VydmFibGU8VD4ge1xyXG4gIHJldHVybiAoc291cmNlOiBPYnNlcnZhYmxlPFQ+KSA9PlxyXG4gICAgT2JzZXJ2YWJsZS5jcmVhdGUob2JzZXJ2ZXIgPT5cclxuICAgICAgc291cmNlLnN1YnNjcmliZShcclxuICAgICAgICB4ID0+IHtcclxuICAgICAgICAgIG9ic2VydmVyLm5leHQoeCk7XHJcbiAgICAgICAgICBpZiAoIXByZWRpY2F0ZSh4KSkge1xyXG4gICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXJyID0+IHtcclxuICAgICAgICAgIG9ic2VydmVyLmVycm9yKGVycik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAoKSA9PiB7XHJcbiAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICksXHJcbiAgICApO1xyXG59XHJcblxyXG4vLyBDb25jYXRlbmF0ZSB0aGUgbGF0ZXN0IHZhbHVlcyBmcm9tIGVhY2ggaW5wdXQgb2JzZXJ2YWJsZSBpbnRvIG9uZSBiaWcgbGlzdC5cclxuLy8gT2JzZXJ2YWJsZXMgd2hvIGhhdmUgbm90IGVtaXR0ZWQgYSB2YWx1ZSB5ZXQgYXJlIHRyZWF0ZWQgYXMgZW1wdHkuXHJcbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRMYXRlc3Q8VD4oXHJcbiAgLi4ub2JzZXJ2YWJsZXM6IEFycmF5PE9ic2VydmFibGU8QXJyYXk8VD4+PlxyXG4pOiBPYnNlcnZhYmxlPEFycmF5PFQ+PiB7XHJcbiAgLy8gRmlyc3QsIHRhZyBhbGwgaW5wdXQgb2JzZXJ2YWJsZXMgd2l0aCB0aGVpciBpbmRleC5cclxuICAvLyBGbG93IGVycm9ycyB3aXRoIGFtYmlndWl0eSB3aXRob3V0IHRoZSBleHBsaWNpdCBhbm5vdGF0aW9uLlxyXG4gIGNvbnN0IHRhZ2dlZDogQXJyYXk8T2JzZXJ2YWJsZTxbQXJyYXk8VD4sIG51bWJlcl0+PiA9IG9ic2VydmFibGVzLm1hcChcclxuICAgIChvYnNlcnZhYmxlLCBpbmRleCkgPT4gb2JzZXJ2YWJsZS5tYXAobGlzdCA9PiBbbGlzdCwgaW5kZXhdKSxcclxuICApO1xyXG4gIHJldHVybiBPYnNlcnZhYmxlLm1lcmdlKC4uLnRhZ2dlZClcclxuICAgIC5zY2FuKChhY2N1bXVsYXRvciwgW2xpc3QsIGluZGV4XSkgPT4ge1xyXG4gICAgICBhY2N1bXVsYXRvcltpbmRleF0gPSBsaXN0O1xyXG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XHJcbiAgICB9LCBvYnNlcnZhYmxlcy5tYXAoeCA9PiBbXSkpXHJcbiAgICAubWFwKGFjY3VtdWxhdG9yID0+IFtdLmNvbmNhdCguLi5hY2N1bXVsYXRvcikpO1xyXG59XHJcblxyXG4vLyBVc2UgYSBzZW50aW5lbCBzbyB3ZSBjYW4gZGlzdGluZ3Vpc2ggYmV0d2VlbiB3aGVuIGBudWxsYCBpcyBlbWl0dGVkIGFuZCB3aGVuXHJcbi8vIG5vdGhpbmcgaXMuXHJcbmNvbnN0IE5PTkUgPSB7fTtcclxuXHJcbnR5cGUgVGhyb3R0bGVPcHRpb25zID0ge3xcclxuICBsZWFkaW5nPzogYm9vbGVhbixcclxufH07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdGhyb3R0bGU8VD4oXHJcbiAgZGVsYXk6XHJcbiAgICB8IG51bWJlclxyXG4gICAgfCAoKHZhbHVlOiBUKSA9PiBPYnNlcnZhYmxlPGFueT4gfCBQcm9taXNlPGFueT4pXHJcbiAgICB8IE9ic2VydmFibGU8YW55PlxyXG4gICAgfCBQcm9taXNlPGFueT4sXHJcbiAgb3B0aW9ucz86IFRocm90dGxlT3B0aW9ucyA9IHtsZWFkaW5nOiB0cnVlfSxcclxuKTogKG9ic2VydmFibGU6IE9ic2VydmFibGU8VD4pID0+IE9ic2VydmFibGU8VD4ge1xyXG4gIGxldCBnZXREZWxheTogKHZhbHVlOiBUKSA9PiBPYnNlcnZhYmxlPGFueT4gfCBQcm9taXNlPGFueT47XHJcbiAgc3dpdGNoICh0eXBlb2YgZGVsYXkpIHtcclxuICAgIGNhc2UgJ251bWJlcic6XHJcbiAgICAgIGdldERlbGF5ID0gKCkgPT4gT2JzZXJ2YWJsZS50aW1lcihkZWxheSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAnZnVuY3Rpb24nOlxyXG4gICAgICBnZXREZWxheSA9IGRlbGF5O1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgJ29iamVjdCc6XHJcbiAgICAgIGdldERlbGF5ID0gKCkgPT4gZGVsYXk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRlbGF5OiAke2RlbGF5fWApO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGZ1bmN0aW9uIGRvVGhyb3R0bGUoc291cmNlOiBPYnNlcnZhYmxlPFQ+KTogT2JzZXJ2YWJsZTxUPiB7XHJcbiAgICByZXR1cm4gT2JzZXJ2YWJsZS5jcmVhdGUob2JzZXJ2ZXIgPT4ge1xyXG4gICAgICBjb25zdCB7bGVhZGluZyA9IHRydWV9ID0gb3B0aW9ucztcclxuICAgICAgY29uc3QgdGltZXJTdGFydHMgPSBuZXcgU3ViamVjdCgpO1xyXG4gICAgICBsZXQgbGF0ZXN0VmFsdWUgPSBOT05FO1xyXG4gICAgICBsZXQgbGF0ZXN0VmFsdWVJc0xlYWRpbmcgPSBmYWxzZTtcclxuICAgICAgbGV0IHNob3VsZElnbm9yZSA9IGZhbHNlO1xyXG5cclxuICAgICAgY29uc3QgY2hlY2tTaG91bGROZXh0ID0gKCkgPT4ge1xyXG4gICAgICAgIGlmICghc2hvdWxkSWdub3JlICYmIGxhdGVzdFZhbHVlICE9PSBOT05FKSB7XHJcbiAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCBsYXRlc3RWYWx1ZSBtdXN0IGJlIG9mIHR5cGUgVFxyXG4gICAgICAgICAgbGF0ZXN0VmFsdWUgPSAoKGxhdGVzdFZhbHVlOiBhbnkpOiBUKTtcclxuXHJcbiAgICAgICAgICBjb25zdCB2YWx1ZVRvRGlzcGF0Y2ggPSBsYXRlc3RWYWx1ZTtcclxuICAgICAgICAgIHNob3VsZElnbm9yZSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgaWYgKGxlYWRpbmcgfHwgIWxhdGVzdFZhbHVlSXNMZWFkaW5nKSB7XHJcbiAgICAgICAgICAgIGxhdGVzdFZhbHVlID0gTk9ORTtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh2YWx1ZVRvRGlzcGF0Y2gpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdGltZXJTdGFydHMubmV4dCh2YWx1ZVRvRGlzcGF0Y2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgIGNvbnN0IHN1YiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcclxuICAgICAgc3ViLmFkZChcclxuICAgICAgICB0aW1lclN0YXJ0c1xyXG4gICAgICAgICAgLnN3aXRjaE1hcCh4ID0+IHtcclxuICAgICAgICAgICAgY29uc3QgdGltZXIgPSBnZXREZWxheSh4KTtcclxuICAgICAgICAgICAgaWYgKHRpbWVyIGluc3RhbmNlb2YgT2JzZXJ2YWJsZSkge1xyXG4gICAgICAgICAgICAgIHJldHVybiB0aW1lci50YWtlKDEpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHJldHVybiB0aW1lcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSlcclxuICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xyXG4gICAgICAgICAgICBzaG91bGRJZ25vcmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgbGF0ZXN0VmFsdWVJc0xlYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgY2hlY2tTaG91bGROZXh0KCk7XHJcbiAgICAgICAgICB9KSxcclxuICAgICAgKTtcclxuICAgICAgc3ViLmFkZChcclxuICAgICAgICBzb3VyY2Uuc3Vic2NyaWJlKHtcclxuICAgICAgICAgIG5leHQ6IHggPT4ge1xyXG4gICAgICAgICAgICBsYXRlc3RWYWx1ZSA9IHg7XHJcbiAgICAgICAgICAgIGxhdGVzdFZhbHVlSXNMZWFkaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgY2hlY2tTaG91bGROZXh0KCk7XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZXJyb3I6IGVyciA9PiB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGVycik7XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgY29tcGxldGU6ICgpID0+IHtcclxuICAgICAgICAgICAgLy8gRW5zdXJlIHdlIGRvbid0IGhvbGQgYSByZWZlcmVuY2UgdG8gdGhlIGxhc3QgdmFsdWUuXHJcbiAgICAgICAgICAgIGxhdGVzdFZhbHVlID0gTk9ORTtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfSksXHJcbiAgICAgICk7XHJcblxyXG4gICAgICByZXR1cm4gc3ViO1xyXG4gICAgfSk7XHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBuZXcgZnVuY3Rpb24gd2hpY2ggdGFrZXMgYW4gYG9ic2VydmFibGVgIGFuZCByZXR1cm5zXHJcbiAqIGBvYnNlcnZhYmxlLnN3aXRjaE1hcChwcm9qZWN0KWAsIGV4Y2VwdCB0aGF0IGl0IGNvbXBsZXRlc1xyXG4gKiB3aGVuIHRoZSBvdXRlciBvYnNlcnZhYmxlIGNvbXBsZXRlcy5cclxuICpcclxuICogRXhhbXBsZTpcclxuICpcclxuICogICBPYnNlcnZhYmxlLm9mKDEpXHJcbiAqICAgICAubGV0KGNvbXBsZXRpbmdTd2l0Y2hNYXAoeCA9PiBPYnNlcnZhYmxlLm5ldmVyKCkpKVxyXG4gKlxyXG4gKiBlbmRzIHVwIHJldHVybmluZyBhbiBPYnNlcnZhYmxlIHRoYXQgY29tcGxldGVzIGltbWVkaWF0ZWx5LlxyXG4gKiBXaXRoIGEgcmVndWxhciBzd2l0Y2hNYXAsIHRoaXMgd291bGQgbmV2ZXIgdGVybWluYXRlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBsZXRpbmdTd2l0Y2hNYXA8VCwgVT4oXHJcbiAgcHJvamVjdDogKGlucHV0OiBULCBpbmRleDogbnVtYmVyKSA9PiByeGpzJE9ic2VydmFibGVJbnB1dDxVPixcclxuKTogKE9ic2VydmFibGU8VD4pID0+IE9ic2VydmFibGU8VT4ge1xyXG4gIC8vIEFuIGFsdGVybmF0aXZlIGltcGxlbWVudGF0aW9uIGlzIHRvIG1hdGVyaWFsaXplIHRoZSBpbnB1dCBvYnNlcnZhYmxlLFxyXG4gIC8vIGJ1dCB0aGlzIGF2b2lkcyB0aGUgY3JlYXRpb24gb2YgZXh0cmEgbm90aWZpZXIgb2JqZWN0cy5cclxuICBjb25zdCBjb21wbGV0ZWRTeW1ib2wgPSBTeW1ib2woJ2NvbXBsZXRlZCcpO1xyXG4gIHJldHVybiAob2JzZXJ2YWJsZTogT2JzZXJ2YWJsZTxUPikgPT5cclxuICAgIE9ic2VydmFibGUuY29uY2F0KFxyXG4gICAgICBvYnNlcnZhYmxlLFxyXG4gICAgICBPYnNlcnZhYmxlLm9mKChjb21wbGV0ZWRTeW1ib2w6IGFueSkpLFxyXG4gICAgKS5zd2l0Y2hNYXAoKGlucHV0LCBpbmRleCkgPT4ge1xyXG4gICAgICBpZiAoaW5wdXQgPT09IGNvbXBsZXRlZFN5bWJvbCkge1xyXG4gICAgICAgIHJldHVybiBPYnNlcnZhYmxlLmVtcHR5KCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHByb2plY3QoaW5wdXQsIGluZGV4KTtcclxuICAgIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIG5ldyBvYnNlcnZhYmxlIGNvbnNpc3Rpbmcgb2YgdGhlIG1lcmdlZCB2YWx1ZXMgZnJvbSB0aGUgcGFzc2VkXHJcbiAqIG9ic2VydmFibGVzIGFuZCBjb21wbGV0ZXMgd2hlbiB0aGUgZmlyc3QgaW5uZXIgb2JzZXJ2YWJsZSBjb21wbGV0ZXMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VVbnRpbEFueUNvbXBsZXRlPFQ+KFxyXG4gIC4uLm9ic2VydmFibGVzOiBBcnJheTxPYnNlcnZhYmxlPFQ+PlxyXG4pOiBPYnNlcnZhYmxlPFQ+IHtcclxuICBjb25zdCBub3RpZmljYXRpb25zID0gT2JzZXJ2YWJsZS5tZXJnZShcclxuICAgIC4uLm9ic2VydmFibGVzLm1hcChvID0+IG8ubWF0ZXJpYWxpemUoKSksXHJcbiAgKTtcclxuICAvLyAkRmxvd0ZpeE1lIGFkZCBkZW1hdGVyaWFsaXplIHRvIHJ4anMgRmxvdyB0eXBlc1xyXG4gIHJldHVybiBub3RpZmljYXRpb25zLmRlbWF0ZXJpYWxpemUoKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJ4SlMncyBkZWJvdW5jZVRpbWUgaXMgYWN0dWFsbHkgZmFpcmx5IGluZWZmaWNpZW50OlxyXG4gKiBvbiBlYWNoIGV2ZW50LCBpdCBhbHdheXMgY2xlYXJzIGl0cyBpbnRlcnZhbCBhbmQgW2NyZWF0ZXMgYSBuZXcgb25lXVsxXS5cclxuICogVW50aWwgdGhpcyBpcyBmaXhlZCwgdGhpcyB1c2VzIG91ciBkZWJvdW5jZSBpbXBsZW1lbnRhdGlvbiB3aGljaFxyXG4gKiByZXVzZXMgYSB0aW1lb3V0IGFuZCBqdXN0IHNldHMgYSB0aW1lc3RhbXAgd2hlbiBwb3NzaWJsZS5cclxuICpcclxuICogVGhpcyBtYXkgc2VlbSBsaWtlIGEgbWljcm8tb3B0aW1pemF0aW9uIGJ1dCB3ZSBvZnRlbiB1c2UgZGVib3VuY2VzXHJcbiAqIGZvciB2ZXJ5IGhvdCBldmVudHMsIGxpa2Uga2V5cHJlc3Nlcy4gRXhjZWVkaW5nIHRoZSBmcmFtZSBidWRnZXQgY2FuIGVhc2lseSBsZWFkXHJcbiAqIHRvIGluY3JlYXNlZCBrZXkgbGF0ZW5jeSFcclxuICpcclxuICogWzFdOiBodHRwczovL2dpdGh1Yi5jb20vUmVhY3RpdmVYL3J4anMvYmxvYi9tYXN0ZXIvc3JjL29wZXJhdG9ycy9kZWJvdW5jZVRpbWUudHMjTDEwNlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZhc3REZWJvdW5jZTxUPihcclxuICBkZWxheTogbnVtYmVyLFxyXG4pOiAoT2JzZXJ2YWJsZTxUPikgPT4gT2JzZXJ2YWJsZTxUPiB7XHJcbiAgcmV0dXJuIChvYnNlcnZhYmxlOiBPYnNlcnZhYmxlPFQ+KSA9PlxyXG4gICAgT2JzZXJ2YWJsZS5jcmVhdGUob2JzZXJ2ZXIgPT4ge1xyXG4gICAgICBjb25zdCBkZWJvdW5jZWROZXh0ID0gZGVib3VuY2UoKHg6IFQpID0+IG9ic2VydmVyLm5leHQoeCksIGRlbGF5KTtcclxuICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gb2JzZXJ2YWJsZS5zdWJzY3JpYmUoXHJcbiAgICAgICAgZGVib3VuY2VkTmV4dCxcclxuICAgICAgICBvYnNlcnZlci5lcnJvci5iaW5kKG9ic2VydmVyKSxcclxuICAgICAgICBvYnNlcnZlci5jb21wbGV0ZS5iaW5kKG9ic2VydmVyKSxcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIG5ldyBVbml2ZXJzYWxEaXNwb3NhYmxlKHN1YnNjcmlwdGlvbiwgZGVib3VuY2VkTmV4dCk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IG1pY3JvdGFzayA9IE9ic2VydmFibGUuY3JlYXRlKG9ic2VydmVyID0+IHtcclxuICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcclxuICAgIG9ic2VydmVyLm5leHQoKTtcclxuICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxuZXhwb3J0IGNvbnN0IG1hY3JvdGFzayA9IE9ic2VydmFibGUuY3JlYXRlKG9ic2VydmVyID0+IHtcclxuICBjb25zdCB0aW1lcklkID0gc2V0SW1tZWRpYXRlKCgpID0+IHtcclxuICAgIG9ic2VydmVyLm5leHQoKTtcclxuICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XHJcbiAgfSk7XHJcbiAgcmV0dXJuICgpID0+IHtcclxuICAgIGNsZWFySW1tZWRpYXRlKHRpbWVySWQpO1xyXG4gIH07XHJcbn0pO1xyXG5cclxuZXhwb3J0IGNvbnN0IG5leHRBbmltYXRpb25GcmFtZSA9IE9ic2VydmFibGUuY3JlYXRlKG9ic2VydmVyID0+IHtcclxuICBpZiAodHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignVGhpcyB1dGlsIGNhbiBvbmx5IGJlIHVzZWQgaW4gQXRvbScpO1xyXG4gIH1cclxuICBjb25zdCBpZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICBvYnNlcnZlci5uZXh0KCk7XHJcbiAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xyXG4gIH0pO1xyXG4gIHJldHVybiAoKSA9PiB7XHJcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZShpZCk7XHJcbiAgfTtcclxufSk7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIGFyb3VuZCBhbiBhYm9ydGFibGUgcHJvbWlzZS5cclxuICogVW5zdWJzY3JpcHRpb25zIGFyZSBmb3J3YXJkZWQgdG8gdGhlIEFib3J0Q29udHJvbGxlciBhcyBhbiBgYWJvcnQoKWAuXHJcbiAqIEV4YW1wbGUgdXNhZ2UgKHdpdGggYW4gYWJvcnRhYmxlIGZldGNoKTpcclxuICpcclxuICogICBmcm9tUHJvbWlzZShzaWduYWwgPT4gZmV0Y2godXJsLCB7Li4ub3B0aW9ucywgc2lnbmFsfSkpXHJcbiAqICAgICAuc3dpdGNoTWFwKC4uLi4pXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCB0aGlzIGNhbiB0YWtlIGEgbm9ybWFsIGAoKSA9PiBQcm9taXNlPFQ+YCB0b29cclxuICogKGluIHdoaWNoIGNhc2UgdGhpcyBhY3RzIGFzIGp1c3QgYSBwbGFpbiBgT2JzZXJ2YWJsZS5kZWZlcmApLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZyb21BYm9ydGFibGVQcm9taXNlPFQ+KFxyXG4gIGZ1bmM6IChzaWduYWw6IEFib3J0U2lnbmFsKSA9PiBQcm9taXNlPFQ+LFxyXG4pOiBPYnNlcnZhYmxlPFQ+IHtcclxuICByZXR1cm4gT2JzZXJ2YWJsZS5jcmVhdGUob2JzZXJ2ZXIgPT4ge1xyXG4gICAgbGV0IGNvbXBsZXRlZCA9IGZhbHNlO1xyXG4gICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xyXG4gICAgZnVuYyhhYm9ydENvbnRyb2xsZXIuc2lnbmFsKS50aGVuKFxyXG4gICAgICB2YWx1ZSA9PiB7XHJcbiAgICAgICAgY29tcGxldGVkID0gdHJ1ZTtcclxuICAgICAgICBvYnNlcnZlci5uZXh0KHZhbHVlKTtcclxuICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xyXG4gICAgICB9LFxyXG4gICAgICBlcnJvciA9PiB7XHJcbiAgICAgICAgY29tcGxldGVkID0gdHJ1ZTtcclxuICAgICAgICBvYnNlcnZlci5lcnJvcihlcnJvcik7XHJcbiAgICAgIH0sXHJcbiAgICApO1xyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgaWYgKCFjb21wbGV0ZWQpIHtcclxuICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcclxuICAgICAgICAvLyBJZiB0aGUgcHJvbWlzZSBhZGhlcmVzIHRvIHRoZSBzcGVjLCBpdCBzaG91bGQgdGhyb3cuXHJcbiAgICAgICAgLy8gVGhlIGVycm9yIHdpbGwgYmUgY2FwdHVyZWQgYWJvdmUgYnV0IGdvIGludG8gdGhlIHZvaWQuXHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBhbiBvYnNlcnZhYmxlICsgQWJvcnRTaWduYWwgaW50byBhIGNhbmNlbGxhYmxlIFByb21pc2UsXHJcbiAqIHdoaWNoIHJlamVjdHMgd2l0aCBhbiBBYm9ydEVycm9yIERPTUV4Y2VwdGlvbiBvbiBhYm9ydC5cclxuICogVXNlZnVsIHdoZW4gd3JpdGluZyB0aGUgaW50ZXJuYWxzIG9mIGEgY2FuY2VsbGFibGUgcHJvbWlzZS5cclxuICpcclxuICogVXNhZ2U6XHJcbiAqXHJcbiAqICAgZnVuY3Rpb24gYWJvcnRhYmxlRnVuY3Rpb24oYXJnMTogYmxhaCwgb3B0aW9ucz86IHtzaWduYWw/OiBBYm9ydFNpZ25hbH0pOiBQcm9taXNlIHtcclxuICogICAgIHJldHVybiB0b1Byb21pc2UoXHJcbiAqICAgICAgIG9ic2VydmFibGVGdW5jdGlvbihhcmcxLCBvcHRpb25zKSxcclxuICogICAgICAgb3B0aW9ucyAmJiBvcHRpb25zLnNpZ25hbCxcclxuICogICAgICk7XHJcbiAqICAgfVxyXG4gKlxyXG4gKiBDb3VsZCBldmVudHVhbGx5IGJlIHJlcGxhY2VkIGJ5IE9ic2VydmFibGUuZmlyc3QgaWZcclxuICogaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy9kb20vaXNzdWVzLzU0NCBnb2VzIHRocm91Z2guXHJcbiAqXHJcbiAqIEl0J3MgY3VycmVudGx5IHVuY2xlYXIgaWYgdGhpcyBzaG91bGQgYmUgdXNhYmxlIHdpdGggbGV0L3BpcGU6XHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9SZWFjdGl2ZVgvcnhqcy9pc3N1ZXMvMzQ0NVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRvQWJvcnRhYmxlUHJvbWlzZTxUPihcclxuICBvYnNlcnZhYmxlOiBPYnNlcnZhYmxlPFQ+LFxyXG4gIHNpZ25hbD86ID9BYm9ydFNpZ25hbCxcclxuKTogUHJvbWlzZTxUPiB7XHJcbiAgaWYgKHNpZ25hbCA9PSBudWxsKSB7XHJcbiAgICByZXR1cm4gb2JzZXJ2YWJsZS50b1Byb21pc2UoKTtcclxuICB9XHJcbiAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoRE9NRXhjZXB0aW9uKCdBYm9ydGVkJywgJ0Fib3J0RXJyb3InKSk7XHJcbiAgfVxyXG4gIHJldHVybiBvYnNlcnZhYmxlXHJcbiAgICAucmFjZShcclxuICAgICAgT2JzZXJ2YWJsZS5mcm9tRXZlbnQoc2lnbmFsLCAnYWJvcnQnKS5tYXAoKCkgPT4ge1xyXG4gICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpO1xyXG4gICAgICB9KSxcclxuICAgIClcclxuICAgIC50b1Byb21pc2UoKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFdoZW4gdXNpbmcgT2JzZXJ2YWJsZXMgd2l0aCBBYm9ydFNpZ25hbHMsIGJlIHN1cmUgdG8gdXNlIHRoaXMgLVxyXG4gKiBpdCdzIHJlYWxseSBlYXN5IHRvIG1pc3MgdGhlIGNhc2Ugd2hlbiB0aGUgc2lnbmFsIGlzIGFscmVhZHkgYWJvcnRlZCFcclxuICogUmVjb21tZW5kZWQgdG8gdXNlIHRoaXMgd2l0aCBsZXQvcGlwZTpcclxuICpcclxuICogICBteU9ic2VydmFibGVcclxuICogICAgIC5sZXQodGFrZVVudGlsQWJvcnQoc2lnbmFsKSlcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB0YWtlVW50aWxBYm9ydDxUPihcclxuICBzaWduYWw6IEFib3J0U2lnbmFsLFxyXG4pOiAoT2JzZXJ2YWJsZTxUPikgPT4gT2JzZXJ2YWJsZTxUPiB7XHJcbiAgcmV0dXJuIG9ic2VydmFibGUgPT5cclxuICAgIE9ic2VydmFibGUuZGVmZXIoKCkgPT4ge1xyXG4gICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcclxuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZS5lbXB0eSgpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBvYnNlcnZhYmxlLnRha2VVbnRpbChPYnNlcnZhYmxlLmZyb21FdmVudChzaWduYWwsICdhYm9ydCcpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG4vLyBFeGVjdXRlcyB0YXNrcy4gRW5zdXJlcyB0aGF0IGF0IG1vc3Qgb25lIHRhc2sgaXMgcnVubmluZyBhdCBhIHRpbWUuXHJcbi8vIFRoaXMgY2xhc3MgaXMgaGFuZHkgZm9yIGV4cGVuc2l2ZSB0YXNrcyBsaWtlIHByb2Nlc3NlcywgcHJvdmlkZWRcclxuLy8geW91IG5ldmVyIHdhbnQgdGhlIHJlc3VsdCBvZiBhIHByZXZpb3VzIHRhc2sgYWZ0ZXIgYSBuZXcgdGFzayBoYXMgc3RhcnRlZC5cclxuZXhwb3J0IGNsYXNzIFNpbmdsZXRvbkV4ZWN1dG9yPFQ+IHtcclxuICBfYWJvcnRDb250cm9sbGVyOiA/QWJvcnRDb250cm9sbGVyID0gbnVsbDtcclxuXHJcbiAgLy8gRXhlY3V0ZXMoc3Vic2NyaWJlcyB0bykgdGhlIHRhc2suXHJcbiAgLy8gV2lsbCB0ZXJtaW5hdGUodW5zdWJzY3JpYmUpIHRvIGFueSBwcmV2aW91c2x5IGV4ZWN1dGluZyB0YXNrLlxyXG4gIC8vIFN1YnNlcXVlbnQgZXhlY3V0ZXMoKSB3aWxsIHRlcm1pbmF0ZSB0aGlzIHRhc2sgaWYgY2FsbGVkIGJlZm9yZVxyXG4gIC8vIHRoaXMgdGFzayBjb21wbGV0ZXMuXHJcbiAgYXN5bmMgZXhlY3V0ZShjcmVhdGVUYXNrOiBPYnNlcnZhYmxlPFQ+KTogUHJvbWlzZTxUPiB7XHJcbiAgICAvLyBLaWxsIGFueSBwcmV2aW91c2x5IHJ1bm5pbmcgcHJvY2Vzc2VzXHJcbiAgICB0aGlzLmNhbmNlbCgpO1xyXG5cclxuICAgIC8vIFN0YXJ0IGEgbmV3IHByb2Nlc3NcclxuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XHJcbiAgICB0aGlzLl9hYm9ydENvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xyXG5cclxuICAgIC8vIFdhaXQgZm9yIHRoZSBwcm9jZXNzIHRvIGNvbXBsZXRlIG9yIGJlIGNhbmNlbGVkIC4uLlxyXG4gICAgdHJ5IHtcclxuICAgICAgcmV0dXJuIGF3YWl0IHRvQWJvcnRhYmxlUHJvbWlzZShjcmVhdGVUYXNrLCBjb250cm9sbGVyLnNpZ25hbCk7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICAvLyAuLi4gYW5kIGFsd2F5cyBjbGVhbiB1cCBpZiB3ZSBoYXZlbid0IGJlZW4gY2FuY2VsZWQgYWxyZWFkeS5cclxuICAgICAgaWYgKGNvbnRyb2xsZXIgPT09IHRoaXMuX2Fib3J0Q29udHJvbGxlcikge1xyXG4gICAgICAgIHRoaXMuX2Fib3J0Q29udHJvbGxlciA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlzRXhlY3V0aW5nKCk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHRoaXMuX2Fib3J0Q29udHJvbGxlciAhPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLy8gQ2FuY2VscyBhbnkgY3VycmVudGx5IGV4ZWN1dGluZyB0YXNrcy5cclxuICBjYW5jZWwoKTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5fYWJvcnRDb250cm9sbGVyICE9IG51bGwpIHtcclxuICAgICAgdGhpcy5fYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XHJcbiAgICAgIHRoaXMuX2Fib3J0Q29udHJvbGxlciA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogUmVwZWF0ZWRseSBzdWJzY3JpYmUgdG8gYW4gb2JzZXJ2YWJsZSBldmVyeSBgZGVsYXlgIG1pbGxpc2Vjb25kcywgd2FpdGluZyBmb3IgdGhlIG9ic2VydmFibGUgdG9cclxuICogY29tcGxldGUgZWFjaCB0aW1lLiBUaGlzIGlzIHByZWZlcmFibGUgdG8sIHNheSwgYE9ic2VydmFibGUuaW50ZXJ2YWwoZCkuc3dpdGNoTWFwKCgpID0+IHNvdXJjZSlgXHJcbiAqIGJlY2F1c2UsIGluIHRoZSBjYXNlIHRoYXQgYHNvdXJjZWAgdGFrZXMgbG9uZ2VyIHRoYW4gYGRgIG1pbGxpc2Vjb25kcyB0byBwcm9kdWNlIGEgdmFsdWUsIHRoYXRcclxuICogZm9ybXVsYXRpb24gd2lsbCBuZXZlciBwcm9kdWNlIGEgdmFsdWUgKHdoaWxlIGNvbnRpbnVpbmcgdG8gaW5jdXIgdGhlIG92ZXJoZWFkIG9mIHN1YnNjcmliaW5nIHRvXHJcbiAqIHNvdXJjZSkuXHJcbiAqXHJcbiAqIEV4YW1wbGU6XHJcbiAqXHJcbiAqICAgIC8vIEFzayB3aGF0IHRpbWUgaXQgaXMgZXZlcnkgc2Vjb25kIHVudGlsIGl0J3MgRnJpZGF5LlxyXG4gKiAgICBydW5Db21tYW5kKCdkYXRlJylcclxuICogICAgICAubGV0KHBvbGwoMTAwMCkpXHJcbiAqICAgICAgLmZpbHRlcihvdXRwdXQgPT4gb3V0cHV0LnN0YXJ0c1dpdGgoJ0ZyaScpKVxyXG4gKiAgICAgIC50YWtlKDEpXHJcbiAqICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XHJcbiAqICAgICAgICBjb25zb2xlLmxvZyhcIklUJ1MgRlJJREFZISFcIilcclxuICogICAgICB9KTtcclxuICpcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwb2xsPFQ+KGRlbGF5OiBudW1iZXIpOiAoT2JzZXJ2YWJsZTxUPikgPT4gT2JzZXJ2YWJsZTxUPiB7XHJcbiAgcmV0dXJuIChzb3VyY2U6IE9ic2VydmFibGU8VD4pID0+XHJcbiAgICBPYnNlcnZhYmxlLmRlZmVyKCgpID0+IHtcclxuICAgICAgY29uc3QgZGVsYXlzID0gbmV3IFN1YmplY3QoKTtcclxuICAgICAgcmV0dXJuIGRlbGF5c1xyXG4gICAgICAgIC5zd2l0Y2hNYXAobiA9PiBPYnNlcnZhYmxlLnRpbWVyKG4pKVxyXG4gICAgICAgIC5tZXJnZShPYnNlcnZhYmxlLm9mKG51bGwpKVxyXG4gICAgICAgIC5zd2l0Y2hNYXAoKCkgPT4ge1xyXG4gICAgICAgICAgY29uc3Qgc3Vic2NyaWJlZEF0ID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgIHJldHVybiBzb3VyY2UuZG8oe1xyXG4gICAgICAgICAgICBjb21wbGV0ZTogKCkgPT4ge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHRpbWVFbGFwc2VkID0gRGF0ZS5ub3coKSAtIHN1YnNjcmliZWRBdDtcclxuICAgICAgICAgICAgICBkZWxheXMubmV4dChNYXRoLm1heCgwLCBkZWxheSAtIHRpbWVFbGFwc2VkKSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbiJdfQ==