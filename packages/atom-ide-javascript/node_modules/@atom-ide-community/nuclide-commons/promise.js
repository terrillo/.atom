"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sleep = sleep;
exports.nextTick = nextTick;
exports.triggerAfterWait = triggerAfterWait;
exports.timeoutPromise = timeoutPromise;
exports.createDeadline = createDeadline;
exports.timeoutAfterDeadline = timeoutAfterDeadline;
exports.retryLimit = retryLimit;
exports.serializeAsyncCall = serializeAsyncCall;
exports.asyncFind = asyncFind;
exports.denodeify = denodeify;
exports.asyncLimit = asyncLimit;
exports.asyncFilter = asyncFilter;
exports.asyncObjFilter = asyncObjFilter;
exports.asyncSome = asyncSome;
exports.isPromise = isPromise;
exports.lastly = lastly;
exports.delayTime = delayTime;
exports.PromiseWithState = exports.Deferred = exports.TimedOutError = exports.RequestSerializer = void 0;

var _assert = _interopRequireDefault(require("assert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */

/**
 * Allows a caller to ensure that the results it receives from consecutive
 * promise resolutions are never outdated. Usage:
 *
 * var requestSerializer = new RequestSerializer();
 *
 * // in some later loop:
 *
 * // note that you do not await the async function here -- you must pass the
 * // promise it returns to `run`
 * var result = await requestSerializer.run(someAsyncFunction())
 *
 * if (result.status === 'success') {
 *   ....
 *   result.result
 * } else if (result.status === 'outdated') {
 *   ....
 * }
 *
 * The contract is that the status is 'success' if and only if this was the most
 * recently dispatched call of 'run'. For example, if you call run(promise1) and
 * then run(promise2), and promise2 resolves first, the second callsite would
 * receive a 'success' status. If promise1 later resolved, the first callsite
 * would receive an 'outdated' status.
 */
class RequestSerializer {
  constructor() {
    this._lastDispatchedOp = void 0;
    this._lastFinishedOp = void 0;
    this._latestPromise = void 0;
    this._waitResolve = void 0;
    this._lastDispatchedOp = 0;
    this._lastFinishedOp = 0;
    this._latestPromise = new Promise((resolve, reject) => {
      this._waitResolve = resolve;
    });
  }

  async run(promise) {
    const thisOp = this._lastDispatchedOp + 1;
    this._lastDispatchedOp = thisOp;
    this._latestPromise = promise;

    this._waitResolve();

    const result = await promise;

    if (this._lastFinishedOp < thisOp) {
      this._lastFinishedOp = thisOp;
      return {
        status: 'success',
        result
      };
    } else {
      return {
        status: 'outdated'
      };
    }
  }
  /**
   * Returns a Promise that resolves to the last result of `run`,
   * as soon as there are no more outstanding `run` calls.
   */


  async waitForLatestResult() {
    let lastPromise = null;
    let result = null;

    while (lastPromise !== this._latestPromise) {
      lastPromise = this._latestPromise; // Wait for the current last know promise to resolve, or a next run have started.
      // eslint-disable-next-line no-await-in-loop

      result = await new Promise((resolve, reject) => {
        this._waitResolve = resolve;

        this._latestPromise.then(resolve);
      });
    }

    return result;
  }

  isRunInProgress() {
    return this._lastDispatchedOp > this._lastFinishedOp;
  }

}
/*
 * Returns a promise that will resolve after `milliSeconds` milli seconds.
 * this can be used to pause execution asynchronously.
 * e.g. await sleep(1000), pauses the async flow execution for 1 second.
 */


exports.RequestSerializer = RequestSerializer;

function sleep(milliSeconds) {
  return new Promise(resolve => {
    setTimeout(resolve, milliSeconds);
  });
}

function nextTick() {
  return new Promise(resolve => {
    process.nextTick(resolve);
  });
}
/**
 * Executes a provided callback only if a promise takes longer than
 * `milliSeconds` milliseconds to resolve.
 *
 * @param `promise` the promise to wait on.
 * @param `milliSeconds` max amount of time that `promise` can take to resolve
 * before timeoutFn is fired.
 * @param `timeoutFn` the function to execute when a promise takes longer than
 * `milliSeconds` ms to resolve.
 * @param `cleanupFn` the cleanup function to execute after the promise resolves.
 */


async function triggerAfterWait(promise, milliSeconds, timeoutFn, cleanupFn) {
  const timeout = setTimeout(timeoutFn, milliSeconds);

  try {
    return await promise;
  } finally {
    clearTimeout(timeout);

    if (cleanupFn) {
      cleanupFn();
    }
  }
}
/**
 * Thrown by `timeoutPromise` if the timer fires before the promise resolves/rejects.
 */


class TimedOutError extends Error {
  constructor(milliseconds) {
    super(`Timed out after ${String(milliseconds)} ms`);
    this.timeout = void 0;
    this.timeout = milliseconds;
  }

}
/**
 * Returns a Promise that resolves to the same value as the given promise, or rejects with
 * `TimedOutError` if it takes longer than `milliseconds` milliseconds.
 */


exports.TimedOutError = TimedOutError;

function timeoutPromise(promise, milliseconds) {
  return new Promise((resolve, reject) => {
    let timeout = setTimeout(() => {
      timeout = null;
      reject(new TimedOutError(milliseconds)); // This gives useless error.stack results.
      // We could capture the stack pre-emptively at the start
      // of this method if we wanted useful ones.
    }, milliseconds);
    promise.then(value => {
      if (timeout != null) {
        clearTimeout(timeout);
      }

      resolve(value);
    }).catch(value => {
      if (timeout != null) {
        clearTimeout(timeout);
      }

      reject(value);
    });
  });
} // An DeadlineRequest parameter to an async method is a way of *requesting* that
// method to throw a TimedOutError if it doesn't complete in a certain time.
// It's just a request -- the async method will typically honor the request
// by passing the parameter on to ALL subsidiary async methods that it awaits,
// or by calling expirePromise to enforce a timeout, or similar.
//
// In cases where a method supports DeadlineRequest but you don't trust it, do
// `await timeoutAfterDeadline(deadline, untrusted.foo(deadline-1000))` so you
// ask it nicely but if it doesn't give its own more-specific deadline message
// within a 1000ms grace period then you force matters.
//
// Under the hood an DeadlineRequest is just a timestamp of the time by which
// the operation should complete. This makes it compositional (better than
// "delay" parameters) and safely remotable (better than "CancellationToken"
// parameters) so long as clocks are in sync. In all other respects it's less
// versatile than CancellationTokens.


function createDeadline(delay) {
  return Date.now() + delay;
}

function timeoutAfterDeadline(deadline, promise) {
  const delay = deadline - Date.now();
  return timeoutPromise(promise, delay < 0 ? 0 : delay);
}
/**
 * Call an async function repeatedly with a maximum number of trials limit,
 * until a valid result that's defined by a validation function.
 * A failed call can result from an async thrown exception, or invalid result.
 *
 * @param `retryFunction` the async logic that's wanted to be retried.
 * @param `validationFunction` the validation function that decides whether a response is valid.
 * @param `maximumTries` the number of times the `retryFunction` can fail to get a valid
 * response before the `retryLimit` is terminated reporting an error.
 * @param `retryIntervalMs` optional, the number of milliseconds to wait between trials, if wanted.
 *
 * If an exception is encountered on the last trial, the exception is thrown.
 * If no valid response is found, an exception is thrown.
 */


async function retryLimit(retryFunction, validationFunction, maximumTries, retryIntervalMs = 0) {
  let result = null;
  let tries = 0;
  let lastError = null;

  while (tries === 0 || tries < maximumTries) {
    try {
      // eslint-disable-next-line no-await-in-loop
      result = await retryFunction();
      lastError = null;

      if (validationFunction(result)) {
        return result;
      }
    } catch (error) {
      lastError = error;
      result = null;
    }

    if (++tries < maximumTries && retryIntervalMs !== 0) {
      // eslint-disable-next-line no-await-in-loop
      await sleep(retryIntervalMs);
    }
  }

  if (lastError != null) {
    throw lastError;
  } else if (tries === maximumTries) {
    throw new Error('No valid response found!');
  } else {
    return result;
  }
}
/**
 * Limits async function execution parallelism to only one at a time.
 * Hence, if a call is already running, it will wait for it to finish,
 * then start the next async execution, but if called again while not finished,
 * it will return the scheduled execution promise.
 *
 * Sample Usage:
 * ```
 * let i = 1;
 * const oneExecAtATime = oneParallelAsyncCall(() => {
 *   return next Promise((resolve, reject) => {
 *     setTimeout(200, () => resolve(i++));
 *   });
 * });
 *
 * const result1Promise = oneExecAtATime(); // Start an async, and resolve to 1 in 200 ms.
 * const result2Promise = oneExecAtATime(); // Schedule the next async, and resolve to 2 in 400 ms.
 * const result3Promise = oneExecAtATime(); // Reuse scheduled promise and resolve to 2 in 400 ms.
 * ```
 */


function serializeAsyncCall(asyncFun) {
  let scheduledCall = null;
  let pendingCall = null;

  const startAsyncCall = () => {
    const resultPromise = asyncFun();
    pendingCall = resultPromise.then(() => pendingCall = null, () => pendingCall = null);
    return resultPromise;
  };

  const callNext = () => {
    scheduledCall = null;
    return startAsyncCall();
  };

  const scheduleNextCall = () => {
    if (scheduledCall == null) {
      (0, _assert.default)(pendingCall, 'pendingCall must not be null!');
      scheduledCall = pendingCall.then(callNext, callNext);
    }

    return scheduledCall;
  };

  return () => {
    if (pendingCall == null) {
      return startAsyncCall();
    } else {
      return scheduleNextCall();
    }
  };
}
/**
 * Provides a promise along with methods to change its state. Our version of the non-standard
 * `Promise.defer()`.
 *
 * IMPORTANT: This should almost never be used!! Instead, use the Promise constructor. See
 *  <https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns#the-deferred-anti-pattern>
 */


class Deferred {
  constructor() {
    this.promise = void 0;
    this.resolve = void 0;
    this.reject = void 0;
    this.promise = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
  }

}
/**
 * Returns a value derived asynchronously from an element in the items array.
 * The test function is applied sequentially to each element in items until
 * one returns a Promise that resolves to a non-null value. When this happens,
 * the Promise returned by this method will resolve to that non-null value. If
 * no such Promise is produced, then the Promise returned by this function
 * will resolve to null.
 *
 * @param items Array of elements that will be passed to test, one at a time.
 * @param test Will be called with each item and must return either:
 *     (1) A "thenable" (i.e, a Promise or promise-like object) that resolves
 *         to a derived value (that will be returned) or null.
 *     (2) null.
 *     In both cases where null is returned, test will be applied to the next
 *     item in the array.
 * @param thisArg Receiver that will be used when test is called.
 * @return Promise that resolves to an asynchronously derived value or null.
 */


exports.Deferred = Deferred;

function asyncFind(items_, test, thisArg) {
  let items = items_;
  return new Promise((resolve, reject) => {
    // Create a local copy of items to defend against the caller modifying the
    // array before this Promise is resolved.
    items = items.slice();
    const numItems = items.length;

    const next = async function (index) {
      if (index === numItems) {
        resolve(null);
        return;
      }

      const item = items[index];
      const result = await test.call(thisArg, item);

      if (result != null) {
        resolve(result);
      } else {
        next(index + 1);
      }
    };

    next(0);
  });
}

function denodeify(f) {
  return function (...args) {
    return new Promise((resolve, reject) => {
      function callback(error, result) {
        if (error) {
          reject(error);
        } else {
          resolve(result);
        }
      }

      f.apply(this, args.concat([callback]));
    });
  };
}
/**
 * A Promise utility that runs a maximum of limit async operations at a time
 * iterating over an array and returning the result of executions.
 * e.g. to limit the number of file reads to 5,
 * replace the code:
 *    var fileContents = await Promise.all(filePaths.map(fsPromise.readFile))
 * with:
 *    var fileContents = await asyncLimit(filePaths, 5, fsPromise.readFile)
 *
 * This is particulrily useful to limit IO operations to a configurable maximum (to avoid
 * blocking), while enjoying the configured level of parallelism.
 *
 * @param array the array of items for iteration.
 * @param limit the configurable number of parallel async operations.
 * @param mappingFunction the async Promise function that could return a useful result.
 */


function asyncLimit(array, limit, mappingFunction) {
  const result = new Array(array.length);
  let parallelPromises = 0;
  let index = 0;
  let parallelLimit = Math.min(limit, array.length) || 1;
  return new Promise((resolve, reject) => {
    const runPromise = async () => {
      if (index === array.length) {
        if (parallelPromises === 0) {
          resolve(result);
        }

        return;
      }

      ++parallelPromises;
      const i = index++;

      try {
        result[i] = await mappingFunction(array[i]);
      } catch (e) {
        reject(e);
      }

      --parallelPromises;
      runPromise();
    };

    while (parallelLimit--) {
      runPromise();
    }
  });
}
/**
 * `filter` Promise utility that allows filtering an array with an async Promise function.
 * It's an alternative to `Array.prototype.filter` that accepts an async function.
 * You can optionally configure a limit to set the maximum number of async operations at a time.
 *
 * Previously, with the `Promise.all` primitive, we can't set the parallelism limit and we have to
 * `filter`, so, we replace the old `filter` code:
 *     var existingFilePaths = [];
 *     await Promise.all(filePaths.map(async (filePath) => {
 *       if (await fsPromise.exists(filePath)) {
 *         existingFilePaths.push(filePath);
 *       }
 *     }));
 * with limit 5 parallel filesystem operations at a time:
 *    var existingFilePaths = await asyncFilter(filePaths, fsPromise.exists, 5);
 *
 * @param array the array of items for `filter`ing.
 * @param filterFunction the async `filter` function that returns a Promise that resolves to a
 *   boolean.
 * @param limit the configurable number of parallel async operations.
 */


async function asyncFilter(array, filterFunction, limit) {
  const filteredList = []; // flowlint-next-line sketchy-null-number:off

  await asyncLimit(array, limit || array.length, async item => {
    if (await filterFunction(item)) {
      filteredList.push(item);
    }
  });
  return filteredList;
}

async function asyncObjFilter(obj, filterFunction, limit) {
  const keys = Object.keys(obj);
  const filteredObj = {}; // flowlint-next-line sketchy-null-number:off

  await asyncLimit(keys, limit || keys.length, async key => {
    const item = obj[key];

    if (await filterFunction(item, key)) {
      filteredObj[key] = item;
    }
  });
  return filteredObj;
}
/**
 * `some` Promise utility that allows `some` an array with an async Promise some function.
 * It's an alternative to `Array.prototype.some` that accepts an async some function.
 * You can optionally configure a limit to set the maximum number of async operations at a time.
 *
 * Previously, with the Promise.all primitive, we can't set the parallelism limit and we have to
 * `some`, so, we replace the old `some` code:
 *     var someFileExist = false;
 *     await Promise.all(filePaths.map(async (filePath) => {
 *       if (await fsPromise.exists(filePath)) {
 *         someFileExist = true;
 *       }
 *     }));
 * with limit 5 parallel filesystem operations at a time:
 *    var someFileExist = await asyncSome(filePaths, fsPromise.exists, 5);
 *
 * @param array the array of items for `some`ing.
 * @param someFunction the async `some` function that returns a Promise that resolves to a
 *   boolean.
 * @param limit the configurable number of parallel async operations.
 */


async function asyncSome(array, someFunction, limit) {
  let resolved = false; // flowlint-next-line sketchy-null-number:off

  await asyncLimit(array, limit || array.length, async item => {
    if (resolved) {
      // We don't need to call the someFunction anymore or wait any longer.
      return;
    }

    if (await someFunction(item)) {
      resolved = true;
    }
  });
  return resolved;
}
/**
 * Check if an object is Promise by testing if it has a `then` function property.
 */


function isPromise(object) {
  return Boolean(object) && typeof object === 'object' && typeof object.then === 'function';
}
/**
 * We can't name a function 'finally', so use lastly instead.
 * fn() will be executed (and completed) after the provided promise resolves/rejects.
 */


function lastly(promise, fn) {
  return promise.then(ret => {
    return Promise.resolve(fn()).then(() => ret);
  }, err => {
    return Promise.resolve(fn()).then(() => Promise.reject(err));
  });
}
/**
 * With a pure promise object, there's no way to tell synchronously
 * whether or not it has 'settled' (i.e. been fulfilled or rejected).
 * Here we provide a wrapper that provides that information.
 */


class PromiseWithState {
  constructor(promise) {
    this._promise = void 0;
    this._state = void 0;
    this._state = {
      kind: 'pending'
    };
    this._promise = promise.then(value => {
      this._state = {
        kind: 'fulfilled',
        value
      };
      return value;
    }, error => {
      this._state = {
        kind: 'rejected',
        error
      };
      throw error;
    });
  }

  getPromise() {
    return this._promise;
  }

  getState() {
    return this._state;
  }

}

exports.PromiseWithState = PromiseWithState;

function delayTime(ms) {
  return new Promise((resolve, reject) => {
    setTimeout(resolve, ms);
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zL3Byb21pc2UuanMiXSwibmFtZXMiOlsiUmVxdWVzdFNlcmlhbGl6ZXIiLCJjb25zdHJ1Y3RvciIsIl9sYXN0RGlzcGF0Y2hlZE9wIiwiX2xhc3RGaW5pc2hlZE9wIiwiX2xhdGVzdFByb21pc2UiLCJfd2FpdFJlc29sdmUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInJ1biIsInByb21pc2UiLCJ0aGlzT3AiLCJyZXN1bHQiLCJzdGF0dXMiLCJ3YWl0Rm9yTGF0ZXN0UmVzdWx0IiwibGFzdFByb21pc2UiLCJ0aGVuIiwiaXNSdW5JblByb2dyZXNzIiwic2xlZXAiLCJtaWxsaVNlY29uZHMiLCJzZXRUaW1lb3V0IiwibmV4dFRpY2siLCJwcm9jZXNzIiwidHJpZ2dlckFmdGVyV2FpdCIsInRpbWVvdXRGbiIsImNsZWFudXBGbiIsInRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJUaW1lZE91dEVycm9yIiwiRXJyb3IiLCJtaWxsaXNlY29uZHMiLCJTdHJpbmciLCJ0aW1lb3V0UHJvbWlzZSIsInZhbHVlIiwiY2F0Y2giLCJjcmVhdGVEZWFkbGluZSIsImRlbGF5IiwiRGF0ZSIsIm5vdyIsInRpbWVvdXRBZnRlckRlYWRsaW5lIiwiZGVhZGxpbmUiLCJyZXRyeUxpbWl0IiwicmV0cnlGdW5jdGlvbiIsInZhbGlkYXRpb25GdW5jdGlvbiIsIm1heGltdW1UcmllcyIsInJldHJ5SW50ZXJ2YWxNcyIsInRyaWVzIiwibGFzdEVycm9yIiwiZXJyb3IiLCJzZXJpYWxpemVBc3luY0NhbGwiLCJhc3luY0Z1biIsInNjaGVkdWxlZENhbGwiLCJwZW5kaW5nQ2FsbCIsInN0YXJ0QXN5bmNDYWxsIiwicmVzdWx0UHJvbWlzZSIsImNhbGxOZXh0Iiwic2NoZWR1bGVOZXh0Q2FsbCIsIkRlZmVycmVkIiwiYXN5bmNGaW5kIiwiaXRlbXNfIiwidGVzdCIsInRoaXNBcmciLCJpdGVtcyIsInNsaWNlIiwibnVtSXRlbXMiLCJsZW5ndGgiLCJuZXh0IiwiaW5kZXgiLCJpdGVtIiwiY2FsbCIsImRlbm9kZWlmeSIsImYiLCJhcmdzIiwiY2FsbGJhY2siLCJhcHBseSIsImNvbmNhdCIsImFzeW5jTGltaXQiLCJhcnJheSIsImxpbWl0IiwibWFwcGluZ0Z1bmN0aW9uIiwiQXJyYXkiLCJwYXJhbGxlbFByb21pc2VzIiwicGFyYWxsZWxMaW1pdCIsIk1hdGgiLCJtaW4iLCJydW5Qcm9taXNlIiwiaSIsImUiLCJhc3luY0ZpbHRlciIsImZpbHRlckZ1bmN0aW9uIiwiZmlsdGVyZWRMaXN0IiwicHVzaCIsImFzeW5jT2JqRmlsdGVyIiwib2JqIiwia2V5cyIsIk9iamVjdCIsImZpbHRlcmVkT2JqIiwia2V5IiwiYXN5bmNTb21lIiwic29tZUZ1bmN0aW9uIiwicmVzb2x2ZWQiLCJpc1Byb21pc2UiLCJvYmplY3QiLCJCb29sZWFuIiwibGFzdGx5IiwiZm4iLCJyZXQiLCJlcnIiLCJQcm9taXNlV2l0aFN0YXRlIiwiX3Byb21pc2UiLCJfc3RhdGUiLCJraW5kIiwiZ2V0UHJvbWlzZSIsImdldFN0YXRlIiwiZGVsYXlUaW1lIiwibXMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVlBOzs7O0FBWkE7Ozs7Ozs7Ozs7OztBQXVCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCTyxNQUFNQSxpQkFBTixDQUEyQjtBQU1oQ0MsRUFBQUEsV0FBVyxHQUFHO0FBQUEsU0FMZEMsaUJBS2M7QUFBQSxTQUpkQyxlQUljO0FBQUEsU0FIZEMsY0FHYztBQUFBLFNBRmRDLFlBRWM7QUFDWixTQUFLSCxpQkFBTCxHQUF5QixDQUF6QjtBQUNBLFNBQUtDLGVBQUwsR0FBdUIsQ0FBdkI7QUFDQSxTQUFLQyxjQUFMLEdBQXNCLElBQUlFLE9BQUosQ0FBWSxDQUFDQyxPQUFELEVBQVVDLE1BQVYsS0FBcUI7QUFDckQsV0FBS0gsWUFBTCxHQUFvQkUsT0FBcEI7QUFDRCxLQUZxQixDQUF0QjtBQUdEOztBQUVELFFBQU1F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SSxFQUFFLFdBQVA7QUFBb0I5RSxRQUFBQTtBQUFwQixPQUFkO0FBQ0EsYUFBT0EsS0FBUDtBQUNELEtBSmEsRUFLZGUsS0FBSyxJQUFJO0FBQ1AsV0FBSzhELE1BQUwsR0FBYztBQUFDQyxRQUFBQSxJQUFJLEVBQUUsVUFBUDtBQUFtQi9ELFFBQUFBO0FBQW5CLE9BQWQ7QUFDQSxZQUFNQSxLQUFOO0FBQ0QsS0FSYSxDQUFoQjtBQVVEOztBQUVEZ0UsRUFBQUEsVUFBVSxHQUFlO0FBQ3ZCLFdBQU8sS0FBS0gsUUFBWjtBQUNEOztBQUVESSxFQUFBQSxRQUFRLEdBQW9CO0FBQzFCLFdBQU8sS0FBS0gsTUFBWjtBQUNEOztBQXhCOEI7Ozs7QUEyQjFCLFNBQVNJLFNBQVQsQ0FBbUJDLEVBQW5CLEVBQThDO0FBQ25ELFNBQU8sSUFBSTdHLE9BQUosQ0FBWSxDQUFDQyxPQUFELEVBQVVDLE1BQVYsS0FBcUI7QUFDdENZLElBQUFBLFVBQVUsQ0FBQ2IsT0FBRCxFQUFVNEcsRUFBVixDQUFWO0FBQ0QsR0FGTSxDQUFQO0FBR0QiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIEBmbG93XHJcbiAqIEBmb3JtYXRcclxuICovXHJcblxyXG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2Fzc2VydCc7XHJcblxyXG50eXBlIFJ1blJldHVybjxUPiA9XHJcbiAgfCB7XHJcbiAgICAgIHN0YXR1czogJ3N1Y2Nlc3MnLFxyXG4gICAgICByZXN1bHQ6IFQsXHJcbiAgICB9XHJcbiAgfCB7XHJcbiAgICAgIHN0YXR1czogJ291dGRhdGVkJyxcclxuICAgIH07XHJcblxyXG4vKipcclxuICogQWxsb3dzIGEgY2FsbGVyIHRvIGVuc3VyZSB0aGF0IHRoZSByZXN1bHRzIGl0IHJlY2VpdmVzIGZyb20gY29uc2VjdXRpdmVcclxuICogcHJvbWlzZSByZXNvbHV0aW9ucyBhcmUgbmV2ZXIgb3V0ZGF0ZWQuIFVzYWdlOlxyXG4gKlxyXG4gKiB2YXIgcmVxdWVzdFNlcmlhbGl6ZXIgPSBuZXcgUmVxdWVzdFNlcmlhbGl6ZXIoKTtcclxuICpcclxuICogLy8gaW4gc29tZSBsYXRlciBsb29wOlxyXG4gKlxyXG4gKiAvLyBub3RlIHRoYXQgeW91IGRvIG5vdCBhd2FpdCB0aGUgYXN5bmMgZnVuY3Rpb24gaGVyZSAtLSB5b3UgbXVzdCBwYXNzIHRoZVxyXG4gKiAvLyBwcm9taXNlIGl0IHJldHVybnMgdG8gYHJ1bmBcclxuICogdmFyIHJlc3VsdCA9IGF3YWl0IHJlcXVlc3RTZXJpYWxpemVyLnJ1bihzb21lQXN5bmNGdW5jdGlvbigpKVxyXG4gKlxyXG4gKiBpZiAocmVzdWx0LnN0YXR1cyA9PT0gJ3N1Y2Nlc3MnKSB7XHJcbiAqICAgLi4uLlxyXG4gKiAgIHJlc3VsdC5yZXN1bHRcclxuICogfSBlbHNlIGlmIChyZXN1bHQuc3RhdHVzID09PSAnb3V0ZGF0ZWQnKSB7XHJcbiAqICAgLi4uLlxyXG4gKiB9XHJcbiAqXHJcbiAqIFRoZSBjb250cmFjdCBpcyB0aGF0IHRoZSBzdGF0dXMgaXMgJ3N1Y2Nlc3MnIGlmIGFuZCBvbmx5IGlmIHRoaXMgd2FzIHRoZSBtb3N0XHJcbiAqIHJlY2VudGx5IGRpc3BhdGNoZWQgY2FsbCBvZiAncnVuJy4gRm9yIGV4YW1wbGUsIGlmIHlvdSBjYWxsIHJ1bihwcm9taXNlMSkgYW5kXHJcbiAqIHRoZW4gcnVuKHByb21pc2UyKSwgYW5kIHByb21pc2UyIHJlc29sdmVzIGZpcnN0LCB0aGUgc2Vjb25kIGNhbGxzaXRlIHdvdWxkXHJcbiAqIHJlY2VpdmUgYSAnc3VjY2Vzcycgc3RhdHVzLiBJZiBwcm9taXNlMSBsYXRlciByZXNvbHZlZCwgdGhlIGZpcnN0IGNhbGxzaXRlXHJcbiAqIHdvdWxkIHJlY2VpdmUgYW4gJ291dGRhdGVkJyBzdGF0dXMuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUmVxdWVzdFNlcmlhbGl6ZXI8VD4ge1xyXG4gIF9sYXN0RGlzcGF0Y2hlZE9wOiBudW1iZXI7XHJcbiAgX2xhc3RGaW5pc2hlZE9wOiBudW1iZXI7XHJcbiAgX2xhdGVzdFByb21pc2U6IFByb21pc2U8VD47XHJcbiAgX3dhaXRSZXNvbHZlOiBGdW5jdGlvbjtcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLl9sYXN0RGlzcGF0Y2hlZE9wID0gMDtcclxuICAgIHRoaXMuX2xhc3RGaW5pc2hlZE9wID0gMDtcclxuICAgIHRoaXMuX2xhdGVzdFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIHRoaXMuX3dhaXRSZXNvbHZlID0gcmVzb2x2ZTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgcnVuKHByb21pc2U6IFByb21pc2U8VD4pOiBQcm9taXNlPFJ1blJldHVybjxUPj4ge1xyXG4gICAgY29uc3QgdGhpc09wID0gdGhpcy5fbGFzdERpc3BhdGNoZWRPcCArIDE7XHJcbiAgICB0aGlzLl9sYXN0RGlzcGF0Y2hlZE9wID0gdGhpc09wO1xyXG4gICAgdGhpcy5fbGF0ZXN0UHJvbWlzZSA9IHByb21pc2U7XHJcbiAgICB0aGlzLl93YWl0UmVzb2x2ZSgpO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvbWlzZTtcclxuICAgIGlmICh0aGlzLl9sYXN0RmluaXNoZWRPcCA8IHRoaXNPcCkge1xyXG4gICAgICB0aGlzLl9sYXN0RmluaXNoZWRPcCA9IHRoaXNPcDtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzdGF0dXM6ICdzdWNjZXNzJyxcclxuICAgICAgICByZXN1bHQsXHJcbiAgICAgIH07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHN0YXR1czogJ291dGRhdGVkJyxcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGxhc3QgcmVzdWx0IG9mIGBydW5gLFxyXG4gICAqIGFzIHNvb24gYXMgdGhlcmUgYXJlIG5vIG1vcmUgb3V0c3RhbmRpbmcgYHJ1bmAgY2FsbHMuXHJcbiAgICovXHJcbiAgYXN5bmMgd2FpdEZvckxhdGVzdFJlc3VsdCgpOiBQcm9taXNlPFQ+IHtcclxuICAgIGxldCBsYXN0UHJvbWlzZSA9IG51bGw7XHJcbiAgICBsZXQgcmVzdWx0OiBhbnkgPSBudWxsO1xyXG4gICAgd2hpbGUgKGxhc3RQcm9taXNlICE9PSB0aGlzLl9sYXRlc3RQcm9taXNlKSB7XHJcbiAgICAgIGxhc3RQcm9taXNlID0gdGhpcy5fbGF0ZXN0UHJvbWlzZTtcclxuICAgICAgLy8gV2FpdCBmb3IgdGhlIGN1cnJlbnQgbGFzdCBrbm93IHByb21pc2UgdG8gcmVzb2x2ZSwgb3IgYSBuZXh0IHJ1biBoYXZlIHN0YXJ0ZWQuXHJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hd2FpdC1pbi1sb29wXHJcbiAgICAgIHJlc3VsdCA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICB0aGlzLl93YWl0UmVzb2x2ZSA9IHJlc29sdmU7XHJcbiAgICAgICAgdGhpcy5fbGF0ZXN0UHJvbWlzZS50aGVuKHJlc29sdmUpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiAocmVzdWx0OiBUKTtcclxuICB9XHJcblxyXG4gIGlzUnVuSW5Qcm9ncmVzcygpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLl9sYXN0RGlzcGF0Y2hlZE9wID4gdGhpcy5fbGFzdEZpbmlzaGVkT3A7XHJcbiAgfVxyXG59XHJcblxyXG4vKlxyXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSBhZnRlciBgbWlsbGlTZWNvbmRzYCBtaWxsaSBzZWNvbmRzLlxyXG4gKiB0aGlzIGNhbiBiZSB1c2VkIHRvIHBhdXNlIGV4ZWN1dGlvbiBhc3luY2hyb25vdXNseS5cclxuICogZS5nLiBhd2FpdCBzbGVlcCgxMDAwKSwgcGF1c2VzIHRoZSBhc3luYyBmbG93IGV4ZWN1dGlvbiBmb3IgMSBzZWNvbmQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2xlZXAobWlsbGlTZWNvbmRzOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcclxuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICBzZXRUaW1lb3V0KHJlc29sdmUsIG1pbGxpU2Vjb25kcyk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBuZXh0VGljaygpOiBQcm9taXNlPHZvaWQ+IHtcclxuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICBwcm9jZXNzLm5leHRUaWNrKHJlc29sdmUpO1xyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogRXhlY3V0ZXMgYSBwcm92aWRlZCBjYWxsYmFjayBvbmx5IGlmIGEgcHJvbWlzZSB0YWtlcyBsb25nZXIgdGhhblxyXG4gKiBgbWlsbGlTZWNvbmRzYCBtaWxsaXNlY29uZHMgdG8gcmVzb2x2ZS5cclxuICpcclxuICogQHBhcmFtIGBwcm9taXNlYCB0aGUgcHJvbWlzZSB0byB3YWl0IG9uLlxyXG4gKiBAcGFyYW0gYG1pbGxpU2Vjb25kc2AgbWF4IGFtb3VudCBvZiB0aW1lIHRoYXQgYHByb21pc2VgIGNhbiB0YWtlIHRvIHJlc29sdmVcclxuICogYmVmb3JlIHRpbWVvdXRGbiBpcyBmaXJlZC5cclxuICogQHBhcmFtIGB0aW1lb3V0Rm5gIHRoZSBmdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gYSBwcm9taXNlIHRha2VzIGxvbmdlciB0aGFuXHJcbiAqIGBtaWxsaVNlY29uZHNgIG1zIHRvIHJlc29sdmUuXHJcbiAqIEBwYXJhbSBgY2xlYW51cEZuYCB0aGUgY2xlYW51cCBmdW5jdGlvbiB0byBleGVjdXRlIGFmdGVyIHRoZSBwcm9taXNlIHJlc29sdmVzLlxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRyaWdnZXJBZnRlcldhaXQ8VD4oXHJcbiAgcHJvbWlzZTogUHJvbWlzZTxUPixcclxuICBtaWxsaVNlY29uZHM6IG51bWJlcixcclxuICB0aW1lb3V0Rm46ICgpID0+IHZvaWQsXHJcbiAgY2xlYW51cEZuPzogKCkgPT4gdm9pZCxcclxuKTogUHJvbWlzZTxUPiB7XHJcbiAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQodGltZW91dEZuLCBtaWxsaVNlY29uZHMpO1xyXG4gIHRyeSB7XHJcbiAgICByZXR1cm4gYXdhaXQgcHJvbWlzZTtcclxuICB9IGZpbmFsbHkge1xyXG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xyXG4gICAgaWYgKGNsZWFudXBGbikge1xyXG4gICAgICBjbGVhbnVwRm4oKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaHJvd24gYnkgYHRpbWVvdXRQcm9taXNlYCBpZiB0aGUgdGltZXIgZmlyZXMgYmVmb3JlIHRoZSBwcm9taXNlIHJlc29sdmVzL3JlamVjdHMuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgVGltZWRPdXRFcnJvciBleHRlbmRzIEVycm9yIHtcclxuICB0aW1lb3V0OiBudW1iZXI7XHJcbiAgY29uc3RydWN0b3IobWlsbGlzZWNvbmRzOiBudW1iZXIpIHtcclxuICAgIHN1cGVyKGBUaW1lZCBvdXQgYWZ0ZXIgJHtTdHJpbmcobWlsbGlzZWNvbmRzKX0gbXNgKTtcclxuICAgIHRoaXMudGltZW91dCA9IG1pbGxpc2Vjb25kcztcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBzYW1lIHZhbHVlIGFzIHRoZSBnaXZlbiBwcm9taXNlLCBvciByZWplY3RzIHdpdGhcclxuICogYFRpbWVkT3V0RXJyb3JgIGlmIGl0IHRha2VzIGxvbmdlciB0aGFuIGBtaWxsaXNlY29uZHNgIG1pbGxpc2Vjb25kcy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB0aW1lb3V0UHJvbWlzZTxUPihcclxuICBwcm9taXNlOiBQcm9taXNlPFQ+LFxyXG4gIG1pbGxpc2Vjb25kczogbnVtYmVyLFxyXG4pOiBQcm9taXNlPFQ+IHtcclxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgbGV0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgdGltZW91dCA9IG51bGw7XHJcbiAgICAgIHJlamVjdChuZXcgVGltZWRPdXRFcnJvcihtaWxsaXNlY29uZHMpKTtcclxuICAgICAgLy8gVGhpcyBnaXZlcyB1c2VsZXNzIGVycm9yLnN0YWNrIHJlc3VsdHMuXHJcbiAgICAgIC8vIFdlIGNvdWxkIGNhcHR1cmUgdGhlIHN0YWNrIHByZS1lbXB0aXZlbHkgYXQgdGhlIHN0YXJ0XHJcbiAgICAgIC8vIG9mIHRoaXMgbWV0aG9kIGlmIHdlIHdhbnRlZCB1c2VmdWwgb25lcy5cclxuICAgIH0sIG1pbGxpc2Vjb25kcyk7XHJcbiAgICBwcm9taXNlXHJcbiAgICAgIC50aGVuKHZhbHVlID0+IHtcclxuICAgICAgICBpZiAodGltZW91dCAhPSBudWxsKSB7XHJcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc29sdmUodmFsdWUpO1xyXG4gICAgICB9KVxyXG4gICAgICAuY2F0Y2godmFsdWUgPT4ge1xyXG4gICAgICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcclxuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVqZWN0KHZhbHVlKTtcclxuICAgICAgfSk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8vIEFuIERlYWRsaW5lUmVxdWVzdCBwYXJhbWV0ZXIgdG8gYW4gYXN5bmMgbWV0aG9kIGlzIGEgd2F5IG9mICpyZXF1ZXN0aW5nKiB0aGF0XHJcbi8vIG1ldGhvZCB0byB0aHJvdyBhIFRpbWVkT3V0RXJyb3IgaWYgaXQgZG9lc24ndCBjb21wbGV0ZSBpbiBhIGNlcnRhaW4gdGltZS5cclxuLy8gSXQncyBqdXN0IGEgcmVxdWVzdCAtLSB0aGUgYXN5bmMgbWV0aG9kIHdpbGwgdHlwaWNhbGx5IGhvbm9yIHRoZSByZXF1ZXN0XHJcbi8vIGJ5IHBhc3NpbmcgdGhlIHBhcmFtZXRlciBvbiB0byBBTEwgc3Vic2lkaWFyeSBhc3luYyBtZXRob2RzIHRoYXQgaXQgYXdhaXRzLFxyXG4vLyBvciBieSBjYWxsaW5nIGV4cGlyZVByb21pc2UgdG8gZW5mb3JjZSBhIHRpbWVvdXQsIG9yIHNpbWlsYXIuXHJcbi8vXHJcbi8vIEluIGNhc2VzIHdoZXJlIGEgbWV0aG9kIHN1cHBvcnRzIERlYWRsaW5lUmVxdWVzdCBidXQgeW91IGRvbid0IHRydXN0IGl0LCBkb1xyXG4vLyBgYXdhaXQgdGltZW91dEFmdGVyRGVhZGxpbmUoZGVhZGxpbmUsIHVudHJ1c3RlZC5mb28oZGVhZGxpbmUtMTAwMCkpYCBzbyB5b3VcclxuLy8gYXNrIGl0IG5pY2VseSBidXQgaWYgaXQgZG9lc24ndCBnaXZlIGl0cyBvd24gbW9yZS1zcGVjaWZpYyBkZWFkbGluZSBtZXNzYWdlXHJcbi8vIHdpdGhpbiBhIDEwMDBtcyBncmFjZSBwZXJpb2QgdGhlbiB5b3UgZm9yY2UgbWF0dGVycy5cclxuLy9cclxuLy8gVW5kZXIgdGhlIGhvb2QgYW4gRGVhZGxpbmVSZXF1ZXN0IGlzIGp1c3QgYSB0aW1lc3RhbXAgb2YgdGhlIHRpbWUgYnkgd2hpY2hcclxuLy8gdGhlIG9wZXJhdGlvbiBzaG91bGQgY29tcGxldGUuIFRoaXMgbWFrZXMgaXQgY29tcG9zaXRpb25hbCAoYmV0dGVyIHRoYW5cclxuLy8gXCJkZWxheVwiIHBhcmFtZXRlcnMpIGFuZCBzYWZlbHkgcmVtb3RhYmxlIChiZXR0ZXIgdGhhbiBcIkNhbmNlbGxhdGlvblRva2VuXCJcclxuLy8gcGFyYW1ldGVycykgc28gbG9uZyBhcyBjbG9ja3MgYXJlIGluIHN5bmMuIEluIGFsbCBvdGhlciByZXNwZWN0cyBpdCdzIGxlc3NcclxuLy8gdmVyc2F0aWxlIHRoYW4gQ2FuY2VsbGF0aW9uVG9rZW5zLlxyXG5leHBvcnQgdHlwZSBEZWFkbGluZVJlcXVlc3QgPSBudW1iZXI7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRGVhZGxpbmUoZGVsYXk6IG51bWJlcik6IERlYWRsaW5lUmVxdWVzdCB7XHJcbiAgcmV0dXJuIERhdGUubm93KCkgKyBkZWxheTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRpbWVvdXRBZnRlckRlYWRsaW5lPFQ+KFxyXG4gIGRlYWRsaW5lOiBEZWFkbGluZVJlcXVlc3QsXHJcbiAgcHJvbWlzZTogUHJvbWlzZTxUPixcclxuKTogUHJvbWlzZTxUPiB7XHJcbiAgY29uc3QgZGVsYXkgPSBkZWFkbGluZSAtIERhdGUubm93KCk7XHJcbiAgcmV0dXJuIHRpbWVvdXRQcm9taXNlKHByb21pc2UsIGRlbGF5IDwgMCA/IDAgOiBkZWxheSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDYWxsIGFuIGFzeW5jIGZ1bmN0aW9uIHJlcGVhdGVkbHkgd2l0aCBhIG1heGltdW0gbnVtYmVyIG9mIHRyaWFscyBsaW1pdCxcclxuICogdW50aWwgYSB2YWxpZCByZXN1bHQgdGhhdCdzIGRlZmluZWQgYnkgYSB2YWxpZGF0aW9uIGZ1bmN0aW9uLlxyXG4gKiBBIGZhaWxlZCBjYWxsIGNhbiByZXN1bHQgZnJvbSBhbiBhc3luYyB0aHJvd24gZXhjZXB0aW9uLCBvciBpbnZhbGlkIHJlc3VsdC5cclxuICpcclxuICogQHBhcmFtIGByZXRyeUZ1bmN0aW9uYCB0aGUgYXN5bmMgbG9naWMgdGhhdCdzIHdhbnRlZCB0byBiZSByZXRyaWVkLlxyXG4gKiBAcGFyYW0gYHZhbGlkYXRpb25GdW5jdGlvbmAgdGhlIHZhbGlkYXRpb24gZnVuY3Rpb24gdGhhdCBkZWNpZGVzIHdoZXRoZXIgYSByZXNwb25zZSBpcyB2YWxpZC5cclxuICogQHBhcmFtIGBtYXhpbXVtVHJpZXNgIHRoZSBudW1iZXIgb2YgdGltZXMgdGhlIGByZXRyeUZ1bmN0aW9uYCBjYW4gZmFpbCB0byBnZXQgYSB2YWxpZFxyXG4gKiByZXNwb25zZSBiZWZvcmUgdGhlIGByZXRyeUxpbWl0YCBpcyB0ZXJtaW5hdGVkIHJlcG9ydGluZyBhbiBlcnJvci5cclxuICogQHBhcmFtIGByZXRyeUludGVydmFsTXNgIG9wdGlvbmFsLCB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJldHdlZW4gdHJpYWxzLCBpZiB3YW50ZWQuXHJcbiAqXHJcbiAqIElmIGFuIGV4Y2VwdGlvbiBpcyBlbmNvdW50ZXJlZCBvbiB0aGUgbGFzdCB0cmlhbCwgdGhlIGV4Y2VwdGlvbiBpcyB0aHJvd24uXHJcbiAqIElmIG5vIHZhbGlkIHJlc3BvbnNlIGlzIGZvdW5kLCBhbiBleGNlcHRpb24gaXMgdGhyb3duLlxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJldHJ5TGltaXQ8VD4oXHJcbiAgcmV0cnlGdW5jdGlvbjogKCkgPT4gUHJvbWlzZTxUPixcclxuICB2YWxpZGF0aW9uRnVuY3Rpb246IChyZXN1bHQ6IFQpID0+IGJvb2xlYW4sXHJcbiAgbWF4aW11bVRyaWVzOiBudW1iZXIsXHJcbiAgcmV0cnlJbnRlcnZhbE1zPzogbnVtYmVyID0gMCxcclxuKTogUHJvbWlzZTxUPiB7XHJcbiAgbGV0IHJlc3VsdCA9IG51bGw7XHJcbiAgbGV0IHRyaWVzID0gMDtcclxuICBsZXQgbGFzdEVycm9yID0gbnVsbDtcclxuICB3aGlsZSAodHJpZXMgPT09IDAgfHwgdHJpZXMgPCBtYXhpbXVtVHJpZXMpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hd2FpdC1pbi1sb29wXHJcbiAgICAgIHJlc3VsdCA9IGF3YWl0IHJldHJ5RnVuY3Rpb24oKTtcclxuICAgICAgbGFzdEVycm9yID0gbnVsbDtcclxuICAgICAgaWYgKHZhbGlkYXRpb25GdW5jdGlvbihyZXN1bHQpKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgbGFzdEVycm9yID0gZXJyb3I7XHJcbiAgICAgIHJlc3VsdCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCsrdHJpZXMgPCBtYXhpbXVtVHJpZXMgJiYgcmV0cnlJbnRlcnZhbE1zICE9PSAwKSB7XHJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hd2FpdC1pbi1sb29wXHJcbiAgICAgIGF3YWl0IHNsZWVwKHJldHJ5SW50ZXJ2YWxNcyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChsYXN0RXJyb3IgIT0gbnVsbCkge1xyXG4gICAgdGhyb3cgbGFzdEVycm9yO1xyXG4gIH0gZWxzZSBpZiAodHJpZXMgPT09IG1heGltdW1Ucmllcykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyB2YWxpZCByZXNwb25zZSBmb3VuZCEnKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuICgocmVzdWx0OiBhbnkpOiBUKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMaW1pdHMgYXN5bmMgZnVuY3Rpb24gZXhlY3V0aW9uIHBhcmFsbGVsaXNtIHRvIG9ubHkgb25lIGF0IGEgdGltZS5cclxuICogSGVuY2UsIGlmIGEgY2FsbCBpcyBhbHJlYWR5IHJ1bm5pbmcsIGl0IHdpbGwgd2FpdCBmb3IgaXQgdG8gZmluaXNoLFxyXG4gKiB0aGVuIHN0YXJ0IHRoZSBuZXh0IGFzeW5jIGV4ZWN1dGlvbiwgYnV0IGlmIGNhbGxlZCBhZ2FpbiB3aGlsZSBub3QgZmluaXNoZWQsXHJcbiAqIGl0IHdpbGwgcmV0dXJuIHRoZSBzY2hlZHVsZWQgZXhlY3V0aW9uIHByb21pc2UuXHJcbiAqXHJcbiAqIFNhbXBsZSBVc2FnZTpcclxuICogYGBgXHJcbiAqIGxldCBpID0gMTtcclxuICogY29uc3Qgb25lRXhlY0F0QVRpbWUgPSBvbmVQYXJhbGxlbEFzeW5jQ2FsbCgoKSA9PiB7XHJcbiAqICAgcmV0dXJuIG5leHQgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAqICAgICBzZXRUaW1lb3V0KDIwMCwgKCkgPT4gcmVzb2x2ZShpKyspKTtcclxuICogICB9KTtcclxuICogfSk7XHJcbiAqXHJcbiAqIGNvbnN0IHJlc3VsdDFQcm9taXNlID0gb25lRXhlY0F0QVRpbWUoKTsgLy8gU3RhcnQgYW4gYXN5bmMsIGFuZCByZXNvbHZlIHRvIDEgaW4gMjAwIG1zLlxyXG4gKiBjb25zdCByZXN1bHQyUHJvbWlzZSA9IG9uZUV4ZWNBdEFUaW1lKCk7IC8vIFNjaGVkdWxlIHRoZSBuZXh0IGFzeW5jLCBhbmQgcmVzb2x2ZSB0byAyIGluIDQwMCBtcy5cclxuICogY29uc3QgcmVzdWx0M1Byb21pc2UgPSBvbmVFeGVjQXRBVGltZSgpOyAvLyBSZXVzZSBzY2hlZHVsZWQgcHJvbWlzZSBhbmQgcmVzb2x2ZSB0byAyIGluIDQwMCBtcy5cclxuICogYGBgXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplQXN5bmNDYWxsPFQ+KFxyXG4gIGFzeW5jRnVuOiAoKSA9PiBQcm9taXNlPFQ+LFxyXG4pOiAoKSA9PiBQcm9taXNlPFQ+IHtcclxuICBsZXQgc2NoZWR1bGVkQ2FsbCA9IG51bGw7XHJcbiAgbGV0IHBlbmRpbmdDYWxsID0gbnVsbDtcclxuICBjb25zdCBzdGFydEFzeW5jQ2FsbCA9ICgpID0+IHtcclxuICAgIGNvbnN0IHJlc3VsdFByb21pc2UgPSBhc3luY0Z1bigpO1xyXG4gICAgcGVuZGluZ0NhbGwgPSByZXN1bHRQcm9taXNlLnRoZW4oXHJcbiAgICAgICgpID0+IChwZW5kaW5nQ2FsbCA9IG51bGwpLFxyXG4gICAgICAoKSA9PiAocGVuZGluZ0NhbGwgPSBudWxsKSxcclxuICAgICk7XHJcbiAgICByZXR1cm4gcmVzdWx0UHJvbWlzZTtcclxuICB9O1xyXG4gIGNvbnN0IGNhbGxOZXh0ID0gKCkgPT4ge1xyXG4gICAgc2NoZWR1bGVkQ2FsbCA9IG51bGw7XHJcbiAgICByZXR1cm4gc3RhcnRBc3luY0NhbGwoKTtcclxuICB9O1xyXG4gIGNvbnN0IHNjaGVkdWxlTmV4dENhbGwgPSAoKSA9PiB7XHJcbiAgICBpZiAoc2NoZWR1bGVkQ2FsbCA9PSBudWxsKSB7XHJcbiAgICAgIGludmFyaWFudChwZW5kaW5nQ2FsbCwgJ3BlbmRpbmdDYWxsIG11c3Qgbm90IGJlIG51bGwhJyk7XHJcbiAgICAgIHNjaGVkdWxlZENhbGwgPSBwZW5kaW5nQ2FsbC50aGVuKGNhbGxOZXh0LCBjYWxsTmV4dCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2NoZWR1bGVkQ2FsbDtcclxuICB9O1xyXG4gIHJldHVybiAoKSA9PiB7XHJcbiAgICBpZiAocGVuZGluZ0NhbGwgPT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gc3RhcnRBc3luY0NhbGwoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBzY2hlZHVsZU5leHRDYWxsKCk7XHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGVzIGEgcHJvbWlzZSBhbG9uZyB3aXRoIG1ldGhvZHMgdG8gY2hhbmdlIGl0cyBzdGF0ZS4gT3VyIHZlcnNpb24gb2YgdGhlIG5vbi1zdGFuZGFyZFxyXG4gKiBgUHJvbWlzZS5kZWZlcigpYC5cclxuICpcclxuICogSU1QT1JUQU5UOiBUaGlzIHNob3VsZCBhbG1vc3QgbmV2ZXIgYmUgdXNlZCEhIEluc3RlYWQsIHVzZSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3Rvci4gU2VlXHJcbiAqICA8aHR0cHM6Ly9naXRodWIuY29tL3BldGthYW50b25vdi9ibHVlYmlyZC93aWtpL1Byb21pc2UtYW50aS1wYXR0ZXJucyN0aGUtZGVmZXJyZWQtYW50aS1wYXR0ZXJuPlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIERlZmVycmVkPFQ+IHtcclxuICBwcm9taXNlOiBQcm9taXNlPFQ+O1xyXG4gIHJlc29sdmU6ICh2YWx1ZTogVCkgPT4gdm9pZDtcclxuICByZWplY3Q6IChlcnJvcjogRXJyb3IpID0+IHZvaWQ7XHJcblxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xyXG4gICAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSB2YWx1ZSBkZXJpdmVkIGFzeW5jaHJvbm91c2x5IGZyb20gYW4gZWxlbWVudCBpbiB0aGUgaXRlbXMgYXJyYXkuXHJcbiAqIFRoZSB0ZXN0IGZ1bmN0aW9uIGlzIGFwcGxpZWQgc2VxdWVudGlhbGx5IHRvIGVhY2ggZWxlbWVudCBpbiBpdGVtcyB1bnRpbFxyXG4gKiBvbmUgcmV0dXJucyBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIG5vbi1udWxsIHZhbHVlLiBXaGVuIHRoaXMgaGFwcGVucyxcclxuICogdGhlIFByb21pc2UgcmV0dXJuZWQgYnkgdGhpcyBtZXRob2Qgd2lsbCByZXNvbHZlIHRvIHRoYXQgbm9uLW51bGwgdmFsdWUuIElmXHJcbiAqIG5vIHN1Y2ggUHJvbWlzZSBpcyBwcm9kdWNlZCwgdGhlbiB0aGUgUHJvbWlzZSByZXR1cm5lZCBieSB0aGlzIGZ1bmN0aW9uXHJcbiAqIHdpbGwgcmVzb2x2ZSB0byBudWxsLlxyXG4gKlxyXG4gKiBAcGFyYW0gaXRlbXMgQXJyYXkgb2YgZWxlbWVudHMgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0ZXN0LCBvbmUgYXQgYSB0aW1lLlxyXG4gKiBAcGFyYW0gdGVzdCBXaWxsIGJlIGNhbGxlZCB3aXRoIGVhY2ggaXRlbSBhbmQgbXVzdCByZXR1cm4gZWl0aGVyOlxyXG4gKiAgICAgKDEpIEEgXCJ0aGVuYWJsZVwiIChpLmUsIGEgUHJvbWlzZSBvciBwcm9taXNlLWxpa2Ugb2JqZWN0KSB0aGF0IHJlc29sdmVzXHJcbiAqICAgICAgICAgdG8gYSBkZXJpdmVkIHZhbHVlICh0aGF0IHdpbGwgYmUgcmV0dXJuZWQpIG9yIG51bGwuXHJcbiAqICAgICAoMikgbnVsbC5cclxuICogICAgIEluIGJvdGggY2FzZXMgd2hlcmUgbnVsbCBpcyByZXR1cm5lZCwgdGVzdCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIG5leHRcclxuICogICAgIGl0ZW0gaW4gdGhlIGFycmF5LlxyXG4gKiBAcGFyYW0gdGhpc0FyZyBSZWNlaXZlciB0aGF0IHdpbGwgYmUgdXNlZCB3aGVuIHRlc3QgaXMgY2FsbGVkLlxyXG4gKiBAcmV0dXJuIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBhc3luY2hyb25vdXNseSBkZXJpdmVkIHZhbHVlIG9yIG51bGwuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYXN5bmNGaW5kPFQsIFU+KFxyXG4gIGl0ZW1zXzogQXJyYXk8VD4sXHJcbiAgdGVzdDogKHQ6IFQpID0+ID9Qcm9taXNlPD9VPixcclxuICB0aGlzQXJnPzogbWl4ZWQsXHJcbik6IFByb21pc2U8P1U+IHtcclxuICBsZXQgaXRlbXMgPSBpdGVtc187XHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgIC8vIENyZWF0ZSBhIGxvY2FsIGNvcHkgb2YgaXRlbXMgdG8gZGVmZW5kIGFnYWluc3QgdGhlIGNhbGxlciBtb2RpZnlpbmcgdGhlXHJcbiAgICAvLyBhcnJheSBiZWZvcmUgdGhpcyBQcm9taXNlIGlzIHJlc29sdmVkLlxyXG4gICAgaXRlbXMgPSBpdGVtcy5zbGljZSgpO1xyXG4gICAgY29uc3QgbnVtSXRlbXMgPSBpdGVtcy5sZW5ndGg7XHJcblxyXG4gICAgY29uc3QgbmV4dCA9IGFzeW5jIGZ1bmN0aW9uKGluZGV4KSB7XHJcbiAgICAgIGlmIChpbmRleCA9PT0gbnVtSXRlbXMpIHtcclxuICAgICAgICByZXNvbHZlKG51bGwpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2luZGV4XTtcclxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGVzdC5jYWxsKHRoaXNBcmcsIGl0ZW0pO1xyXG4gICAgICBpZiAocmVzdWx0ICE9IG51bGwpIHtcclxuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbmV4dChpbmRleCArIDEpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIG5leHQoMCk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkZW5vZGVpZnkoXHJcbiAgZjogKC4uLmFyZ3M6IEFycmF5PGFueT4pID0+IGFueSxcclxuKTogKC4uLmFyZ3M6IEFycmF5PGFueT4pID0+IFByb21pc2U8YW55PiB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3M6IEFycmF5PGFueT4pIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIGZ1bmN0aW9uIGNhbGxiYWNrKGVycm9yLCByZXN1bHQpIHtcclxuICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgZi5hcHBseSh0aGlzLCBhcmdzLmNvbmNhdChbY2FsbGJhY2tdKSk7XHJcbiAgICB9KTtcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogQSBQcm9taXNlIHV0aWxpdHkgdGhhdCBydW5zIGEgbWF4aW11bSBvZiBsaW1pdCBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZVxyXG4gKiBpdGVyYXRpbmcgb3ZlciBhbiBhcnJheSBhbmQgcmV0dXJuaW5nIHRoZSByZXN1bHQgb2YgZXhlY3V0aW9ucy5cclxuICogZS5nLiB0byBsaW1pdCB0aGUgbnVtYmVyIG9mIGZpbGUgcmVhZHMgdG8gNSxcclxuICogcmVwbGFjZSB0aGUgY29kZTpcclxuICogICAgdmFyIGZpbGVDb250ZW50cyA9IGF3YWl0IFByb21pc2UuYWxsKGZpbGVQYXRocy5tYXAoZnNQcm9taXNlLnJlYWRGaWxlKSlcclxuICogd2l0aDpcclxuICogICAgdmFyIGZpbGVDb250ZW50cyA9IGF3YWl0IGFzeW5jTGltaXQoZmlsZVBhdGhzLCA1LCBmc1Byb21pc2UucmVhZEZpbGUpXHJcbiAqXHJcbiAqIFRoaXMgaXMgcGFydGljdWxyaWx5IHVzZWZ1bCB0byBsaW1pdCBJTyBvcGVyYXRpb25zIHRvIGEgY29uZmlndXJhYmxlIG1heGltdW0gKHRvIGF2b2lkXHJcbiAqIGJsb2NraW5nKSwgd2hpbGUgZW5qb3lpbmcgdGhlIGNvbmZpZ3VyZWQgbGV2ZWwgb2YgcGFyYWxsZWxpc20uXHJcbiAqXHJcbiAqIEBwYXJhbSBhcnJheSB0aGUgYXJyYXkgb2YgaXRlbXMgZm9yIGl0ZXJhdGlvbi5cclxuICogQHBhcmFtIGxpbWl0IHRoZSBjb25maWd1cmFibGUgbnVtYmVyIG9mIHBhcmFsbGVsIGFzeW5jIG9wZXJhdGlvbnMuXHJcbiAqIEBwYXJhbSBtYXBwaW5nRnVuY3Rpb24gdGhlIGFzeW5jIFByb21pc2UgZnVuY3Rpb24gdGhhdCBjb3VsZCByZXR1cm4gYSB1c2VmdWwgcmVzdWx0LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFzeW5jTGltaXQ8VCwgVj4oXHJcbiAgYXJyYXk6IEFycmF5PFQ+LFxyXG4gIGxpbWl0OiBudW1iZXIsXHJcbiAgbWFwcGluZ0Z1bmN0aW9uOiAoaXRlbTogVCkgPT4gUHJvbWlzZTxWPixcclxuKTogUHJvbWlzZTxBcnJheTxWPj4ge1xyXG4gIGNvbnN0IHJlc3VsdDogQXJyYXk8Vj4gPSBuZXcgQXJyYXkoYXJyYXkubGVuZ3RoKTtcclxuICBsZXQgcGFyYWxsZWxQcm9taXNlcyA9IDA7XHJcbiAgbGV0IGluZGV4ID0gMDtcclxuXHJcbiAgbGV0IHBhcmFsbGVsTGltaXQgPSBNYXRoLm1pbihsaW1pdCwgYXJyYXkubGVuZ3RoKSB8fCAxO1xyXG5cclxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgY29uc3QgcnVuUHJvbWlzZSA9IGFzeW5jICgpID0+IHtcclxuICAgICAgaWYgKGluZGV4ID09PSBhcnJheS5sZW5ndGgpIHtcclxuICAgICAgICBpZiAocGFyYWxsZWxQcm9taXNlcyA9PT0gMCkge1xyXG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgKytwYXJhbGxlbFByb21pc2VzO1xyXG4gICAgICBjb25zdCBpID0gaW5kZXgrKztcclxuICAgICAgdHJ5IHtcclxuICAgICAgICByZXN1bHRbaV0gPSBhd2FpdCBtYXBwaW5nRnVuY3Rpb24oYXJyYXlbaV0pO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgcmVqZWN0KGUpO1xyXG4gICAgICB9XHJcbiAgICAgIC0tcGFyYWxsZWxQcm9taXNlcztcclxuICAgICAgcnVuUHJvbWlzZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICB3aGlsZSAocGFyYWxsZWxMaW1pdC0tKSB7XHJcbiAgICAgIHJ1blByb21pc2UoKTtcclxuICAgIH1cclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIGBmaWx0ZXJgIFByb21pc2UgdXRpbGl0eSB0aGF0IGFsbG93cyBmaWx0ZXJpbmcgYW4gYXJyYXkgd2l0aCBhbiBhc3luYyBQcm9taXNlIGZ1bmN0aW9uLlxyXG4gKiBJdCdzIGFuIGFsdGVybmF0aXZlIHRvIGBBcnJheS5wcm90b3R5cGUuZmlsdGVyYCB0aGF0IGFjY2VwdHMgYW4gYXN5bmMgZnVuY3Rpb24uXHJcbiAqIFlvdSBjYW4gb3B0aW9uYWxseSBjb25maWd1cmUgYSBsaW1pdCB0byBzZXQgdGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxyXG4gKlxyXG4gKiBQcmV2aW91c2x5LCB3aXRoIHRoZSBgUHJvbWlzZS5hbGxgIHByaW1pdGl2ZSwgd2UgY2FuJ3Qgc2V0IHRoZSBwYXJhbGxlbGlzbSBsaW1pdCBhbmQgd2UgaGF2ZSB0b1xyXG4gKiBgZmlsdGVyYCwgc28sIHdlIHJlcGxhY2UgdGhlIG9sZCBgZmlsdGVyYCBjb2RlOlxyXG4gKiAgICAgdmFyIGV4aXN0aW5nRmlsZVBhdGhzID0gW107XHJcbiAqICAgICBhd2FpdCBQcm9taXNlLmFsbChmaWxlUGF0aHMubWFwKGFzeW5jIChmaWxlUGF0aCkgPT4ge1xyXG4gKiAgICAgICBpZiAoYXdhaXQgZnNQcm9taXNlLmV4aXN0cyhmaWxlUGF0aCkpIHtcclxuICogICAgICAgICBleGlzdGluZ0ZpbGVQYXRocy5wdXNoKGZpbGVQYXRoKTtcclxuICogICAgICAgfVxyXG4gKiAgICAgfSkpO1xyXG4gKiB3aXRoIGxpbWl0IDUgcGFyYWxsZWwgZmlsZXN5c3RlbSBvcGVyYXRpb25zIGF0IGEgdGltZTpcclxuICogICAgdmFyIGV4aXN0aW5nRmlsZVBhdGhzID0gYXdhaXQgYXN5bmNGaWx0ZXIoZmlsZVBhdGhzLCBmc1Byb21pc2UuZXhpc3RzLCA1KTtcclxuICpcclxuICogQHBhcmFtIGFycmF5IHRoZSBhcnJheSBvZiBpdGVtcyBmb3IgYGZpbHRlcmBpbmcuXHJcbiAqIEBwYXJhbSBmaWx0ZXJGdW5jdGlvbiB0aGUgYXN5bmMgYGZpbHRlcmAgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFcclxuICogICBib29sZWFuLlxyXG4gKiBAcGFyYW0gbGltaXQgdGhlIGNvbmZpZ3VyYWJsZSBudW1iZXIgb2YgcGFyYWxsZWwgYXN5bmMgb3BlcmF0aW9ucy5cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY0ZpbHRlcjxUPihcclxuICBhcnJheTogQXJyYXk8VD4sXHJcbiAgZmlsdGVyRnVuY3Rpb246IChpdGVtOiBUKSA9PiBQcm9taXNlPGJvb2xlYW4+LFxyXG4gIGxpbWl0PzogbnVtYmVyLFxyXG4pOiBQcm9taXNlPEFycmF5PFQ+PiB7XHJcbiAgY29uc3QgZmlsdGVyZWRMaXN0ID0gW107XHJcbiAgLy8gZmxvd2xpbnQtbmV4dC1saW5lIHNrZXRjaHktbnVsbC1udW1iZXI6b2ZmXHJcbiAgYXdhaXQgYXN5bmNMaW1pdChhcnJheSwgbGltaXQgfHwgYXJyYXkubGVuZ3RoLCBhc3luYyAoaXRlbTogVCkgPT4ge1xyXG4gICAgaWYgKGF3YWl0IGZpbHRlckZ1bmN0aW9uKGl0ZW0pKSB7XHJcbiAgICAgIGZpbHRlcmVkTGlzdC5wdXNoKGl0ZW0pO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIHJldHVybiBmaWx0ZXJlZExpc3Q7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY09iakZpbHRlcjxUPihcclxuICBvYmo6IHtba2V5OiBzdHJpbmddOiBUfSxcclxuICBmaWx0ZXJGdW5jdGlvbjogKGl0ZW06IFQsIGtleTogc3RyaW5nKSA9PiBQcm9taXNlPGJvb2xlYW4+LFxyXG4gIGxpbWl0PzogbnVtYmVyLFxyXG4pOiBQcm9taXNlPHtba2V5OiBzdHJpbmddOiBUfT4ge1xyXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xyXG4gIGNvbnN0IGZpbHRlcmVkT2JqID0ge307XHJcbiAgLy8gZmxvd2xpbnQtbmV4dC1saW5lIHNrZXRjaHktbnVsbC1udW1iZXI6b2ZmXHJcbiAgYXdhaXQgYXN5bmNMaW1pdChrZXlzLCBsaW1pdCB8fCBrZXlzLmxlbmd0aCwgYXN5bmMgKGtleTogc3RyaW5nKSA9PiB7XHJcbiAgICBjb25zdCBpdGVtID0gb2JqW2tleV07XHJcbiAgICBpZiAoYXdhaXQgZmlsdGVyRnVuY3Rpb24oaXRlbSwga2V5KSkge1xyXG4gICAgICBmaWx0ZXJlZE9ialtrZXldID0gaXRlbTtcclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gZmlsdGVyZWRPYmo7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBgc29tZWAgUHJvbWlzZSB1dGlsaXR5IHRoYXQgYWxsb3dzIGBzb21lYCBhbiBhcnJheSB3aXRoIGFuIGFzeW5jIFByb21pc2Ugc29tZSBmdW5jdGlvbi5cclxuICogSXQncyBhbiBhbHRlcm5hdGl2ZSB0byBgQXJyYXkucHJvdG90eXBlLnNvbWVgIHRoYXQgYWNjZXB0cyBhbiBhc3luYyBzb21lIGZ1bmN0aW9uLlxyXG4gKiBZb3UgY2FuIG9wdGlvbmFsbHkgY29uZmlndXJlIGEgbGltaXQgdG8gc2V0IHRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cclxuICpcclxuICogUHJldmlvdXNseSwgd2l0aCB0aGUgUHJvbWlzZS5hbGwgcHJpbWl0aXZlLCB3ZSBjYW4ndCBzZXQgdGhlIHBhcmFsbGVsaXNtIGxpbWl0IGFuZCB3ZSBoYXZlIHRvXHJcbiAqIGBzb21lYCwgc28sIHdlIHJlcGxhY2UgdGhlIG9sZCBgc29tZWAgY29kZTpcclxuICogICAgIHZhciBzb21lRmlsZUV4aXN0ID0gZmFsc2U7XHJcbiAqICAgICBhd2FpdCBQcm9taXNlLmFsbChmaWxlUGF0aHMubWFwKGFzeW5jIChmaWxlUGF0aCkgPT4ge1xyXG4gKiAgICAgICBpZiAoYXdhaXQgZnNQcm9taXNlLmV4aXN0cyhmaWxlUGF0aCkpIHtcclxuICogICAgICAgICBzb21lRmlsZUV4aXN0ID0gdHJ1ZTtcclxuICogICAgICAgfVxyXG4gKiAgICAgfSkpO1xyXG4gKiB3aXRoIGxpbWl0IDUgcGFyYWxsZWwgZmlsZXN5c3RlbSBvcGVyYXRpb25zIGF0IGEgdGltZTpcclxuICogICAgdmFyIHNvbWVGaWxlRXhpc3QgPSBhd2FpdCBhc3luY1NvbWUoZmlsZVBhdGhzLCBmc1Byb21pc2UuZXhpc3RzLCA1KTtcclxuICpcclxuICogQHBhcmFtIGFycmF5IHRoZSBhcnJheSBvZiBpdGVtcyBmb3IgYHNvbWVgaW5nLlxyXG4gKiBAcGFyYW0gc29tZUZ1bmN0aW9uIHRoZSBhc3luYyBgc29tZWAgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFcclxuICogICBib29sZWFuLlxyXG4gKiBAcGFyYW0gbGltaXQgdGhlIGNvbmZpZ3VyYWJsZSBudW1iZXIgb2YgcGFyYWxsZWwgYXN5bmMgb3BlcmF0aW9ucy5cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY1NvbWU8VD4oXHJcbiAgYXJyYXk6IEFycmF5PFQ+LFxyXG4gIHNvbWVGdW5jdGlvbjogKGl0ZW06IFQpID0+IFByb21pc2U8Ym9vbGVhbj4sXHJcbiAgbGltaXQ/OiBudW1iZXIsXHJcbik6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gIGxldCByZXNvbHZlZCA9IGZhbHNlO1xyXG4gIC8vIGZsb3dsaW50LW5leHQtbGluZSBza2V0Y2h5LW51bGwtbnVtYmVyOm9mZlxyXG4gIGF3YWl0IGFzeW5jTGltaXQoYXJyYXksIGxpbWl0IHx8IGFycmF5Lmxlbmd0aCwgYXN5bmMgKGl0ZW06IFQpID0+IHtcclxuICAgIGlmIChyZXNvbHZlZCkge1xyXG4gICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIGNhbGwgdGhlIHNvbWVGdW5jdGlvbiBhbnltb3JlIG9yIHdhaXQgYW55IGxvbmdlci5cclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKGF3YWl0IHNvbWVGdW5jdGlvbihpdGVtKSkge1xyXG4gICAgICByZXNvbHZlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgcmV0dXJuIHJlc29sdmVkO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgYW4gb2JqZWN0IGlzIFByb21pc2UgYnkgdGVzdGluZyBpZiBpdCBoYXMgYSBgdGhlbmAgZnVuY3Rpb24gcHJvcGVydHkuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNQcm9taXNlKG9iamVjdDogYW55KTogYm9vbGVhbiB7XHJcbiAgcmV0dXJuIChcclxuICAgIEJvb2xlYW4ob2JqZWN0KSAmJlxyXG4gICAgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiZcclxuICAgIHR5cGVvZiBvYmplY3QudGhlbiA9PT0gJ2Z1bmN0aW9uJ1xyXG4gICk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBXZSBjYW4ndCBuYW1lIGEgZnVuY3Rpb24gJ2ZpbmFsbHknLCBzbyB1c2UgbGFzdGx5IGluc3RlYWQuXHJcbiAqIGZuKCkgd2lsbCBiZSBleGVjdXRlZCAoYW5kIGNvbXBsZXRlZCkgYWZ0ZXIgdGhlIHByb3ZpZGVkIHByb21pc2UgcmVzb2x2ZXMvcmVqZWN0cy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBsYXN0bHk8VD4oXHJcbiAgcHJvbWlzZTogUHJvbWlzZTxUPixcclxuICBmbjogKCkgPT4gUHJvbWlzZTxtaXhlZD4gfCBtaXhlZCxcclxuKTogUHJvbWlzZTxUPiB7XHJcbiAgcmV0dXJuIHByb21pc2UudGhlbihcclxuICAgIHJldCA9PiB7XHJcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZm4oKSkudGhlbigoKSA9PiByZXQpO1xyXG4gICAgfSxcclxuICAgIGVyciA9PiB7XHJcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZm4oKSkudGhlbigoKSA9PiBQcm9taXNlLnJlamVjdChlcnIpKTtcclxuICAgIH0sXHJcbiAgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFdpdGggYSBwdXJlIHByb21pc2Ugb2JqZWN0LCB0aGVyZSdzIG5vIHdheSB0byB0ZWxsIHN5bmNocm9ub3VzbHlcclxuICogd2hldGhlciBvciBub3QgaXQgaGFzICdzZXR0bGVkJyAoaS5lLiBiZWVuIGZ1bGZpbGxlZCBvciByZWplY3RlZCkuXHJcbiAqIEhlcmUgd2UgcHJvdmlkZSBhIHdyYXBwZXIgdGhhdCBwcm92aWRlcyB0aGF0IGluZm9ybWF0aW9uLlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgUHJvbWlzZVN0YXRlPFQ+ID1cclxuICB8IHtraW5kOiAncGVuZGluZyd9XHJcbiAgfCB7a2luZDogJ2Z1bGZpbGxlZCcsIHZhbHVlOiBUfVxyXG4gIHwge2tpbmQ6ICdyZWplY3RlZCcsIGVycm9yOiBhbnl9O1xyXG5cclxuZXhwb3J0IGNsYXNzIFByb21pc2VXaXRoU3RhdGU8VD4ge1xyXG4gIF9wcm9taXNlOiBQcm9taXNlPFQ+O1xyXG4gIF9zdGF0ZTogUHJvbWlzZVN0YXRlPFQ+O1xyXG5cclxuICBjb25zdHJ1Y3Rvcihwcm9taXNlOiBQcm9taXNlPFQ+KSB7XHJcbiAgICB0aGlzLl9zdGF0ZSA9IHtraW5kOiAncGVuZGluZyd9O1xyXG4gICAgdGhpcy5fcHJvbWlzZSA9IHByb21pc2UudGhlbihcclxuICAgICAgdmFsdWUgPT4ge1xyXG4gICAgICAgIHRoaXMuX3N0YXRlID0ge2tpbmQ6ICdmdWxmaWxsZWQnLCB2YWx1ZX07XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICB9LFxyXG4gICAgICBlcnJvciA9PiB7XHJcbiAgICAgICAgdGhpcy5fc3RhdGUgPSB7a2luZDogJ3JlamVjdGVkJywgZXJyb3J9O1xyXG4gICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICB9LFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGdldFByb21pc2UoKTogUHJvbWlzZTxUPiB7XHJcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZTtcclxuICB9XHJcblxyXG4gIGdldFN0YXRlKCk6IFByb21pc2VTdGF0ZTxUPiB7XHJcbiAgICByZXR1cm4gdGhpcy5fc3RhdGU7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZGVsYXlUaW1lKG1zOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcclxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgc2V0VGltZW91dChyZXNvbHZlLCBtcyk7XHJcbiAgfSk7XHJcbn1cclxuIl19