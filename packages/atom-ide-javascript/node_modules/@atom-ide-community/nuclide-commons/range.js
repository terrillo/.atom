"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.wordAtPositionFromBuffer = wordAtPositionFromBuffer;
exports.matchRegexEndingAt = matchRegexEndingAt;
exports.isPositionInRange = isPositionInRange;

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */
function wordAtPositionFromBuffer(buffer, position, wordRegex) {
  const {
    row,
    column
  } = position;
  const rowRange = buffer.rangeForRow(row);
  let matchData; // Extract the expression from the row text.

  buffer.scanInRange(wordRegex, rowRange, data => {
    const {
      range
    } = data;

    if (range.start.isLessThanOrEqual(position) && range.end.isGreaterThan(position)) {
      matchData = data;
    } // Stop the scan if the scanner has passed our position.


    if (range.end.column > column) {
      data.stop();
    }
  });

  if (matchData) {
    return {
      wordMatch: matchData.match,
      range: matchData.range
    };
  } else {
    return null;
  }
} // Matches a regex on the text of the line ending at endPosition.
// regex should end with a '$'.
// Useful for autocomplete.


function matchRegexEndingAt(buffer, endPosition, regex) {
  const line = buffer.getTextInRange([[endPosition.row, 0], endPosition]);
  const match = regex.exec(line);
  return match == null ? null : match[0];
}

function isPositionInRange(position, range) {
  return Array.isArray(range) ? range.some(r => r.containsPoint(position)) : range.containsPoint(position);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zL3JhbmdlLmpzIl0sIm5hbWVzIjpbIndvcmRBdFBvc2l0aW9uRnJvbUJ1ZmZlciIsImJ1ZmZlciIsInBvc2l0aW9uIiwid29yZFJlZ2V4Iiwicm93IiwiY29sdW1uIiwicm93UmFuZ2UiLCJyYW5nZUZvclJvdyIsIm1hdGNoRGF0YSIsInNjYW5JblJhbmdlIiwiZGF0YSIsInJhbmdlIiwic3RhcnQiLCJpc0xlc3NUaGFuT3JFcXVhbCIsImVuZCIsImlzR3JlYXRlclRoYW4iLCJzdG9wIiwid29yZE1hdGNoIiwibWF0Y2giLCJtYXRjaFJlZ2V4RW5kaW5nQXQiLCJlbmRQb3NpdGlvbiIsInJlZ2V4IiwibGluZSIsImdldFRleHRJblJhbmdlIiwiZXhlYyIsImlzUG9zaXRpb25JblJhbmdlIiwiQXJyYXkiLCJpc0FycmF5Iiwic29tZSIsInIiLCJjb250YWluc1BvaW50Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7QUFZTyxTQUFTQSx3QkFBVCxDQUNMQyxNQURLLEVBRUxDLFFBRkssRUFHTEMsU0FISyxFQUkyQztBQUNoRCxRQUFNO0FBQUNDLElBQUFBLEdBQUQ7QUFBTUMsSUFBQUE7QUFBTixNQUFnQkgsUUFBdEI7QUFDQSxRQUFNSSxRQUFRLEdBQUdMLE1BQU0sQ0FBQ00sV0FBUCxDQUFtQkgsR0FBbkIsQ0FBakI7QUFDQSxNQUFJSSxTQUFKLENBSGdELENBSWhEOztBQUNBUCxFQUFBQSxNQUFNLENBQUNRLFdBQVAsQ0FBbUJOLFNBQW5CLEVBQThCRyxRQUE5QixFQUF3Q0ksSUFBSSxJQUFJO0FBQzlDLFVBQU07QUFBQ0MsTUFBQUE7QUFBRCxRQUFVRCxJQUFoQjs7QUFDQSxRQUNFQyxLQUFLLENBQUNDLEtBQU4sQ0FBWUMsaUJBQVosQ0FBOEJYLFFBQTlCLEtBQ0FTLEtBQUssQ0FBQ0csR0FBTixDQUFVQyxhQUFWLENBQXdCYixRQUF4QixDQUZGLEVBR0U7QUFDQU0sTUFBQUEsU0FBUyxHQUFHRSxJQUFaO0FBQ0QsS0FQNkMsQ0FROUM7OztBQUNBLFFBQUlDLEtBQUssQ0FBQ0csR0FBTixDQUFVVCxNQUFWLEdBQW1CQSxNQUF2QixFQUErQjtBQUM3QkssTUFBQUEsSUFBSSxDQUFDTSxJQUFMO0FBQ0Q7QUFDRixHQVpEOztBQWFBLE1BQUlSLFNBQUosRUFBZTtBQUNiLFdBQU87QUFDTFMsTUFBQUEsU0FBUyxFQUFFVCxTQUFTLENBQUNVLEtBRGhCO0FBRUxQLE1BQUFBLEtBQUssRUFBRUgsU0FBUyxDQUFDRztBQUZaLEtBQVA7QUFJRCxHQUxELE1BS087QUFDTCxXQUFPLElBQVA7QUFDRDtBQUNGLEMsQ0FFRDtBQUNBO0FBQ0E7OztBQUNPLFNBQVNRLGtCQUFULENBQ0xsQixNQURLLEVBRUxtQixXQUZLLEVBR0xDLEtBSEssRUFJSTtBQUNULFFBQU1DLElBQUksR0FBR3JCLE1BQU0sQ0FBQ3NCLGNBQVAsQ0FBc0IsQ0FBQyxDQUFDSCxXQUFXLENBQUNoQixHQUFiLEVBQWtCLENBQWxCLENBQUQsRUFBdUJnQixXQUF2QixDQUF0QixDQUFiO0FBQ0EsUUFBTUYsS0FBSyxHQUFHRyxLQUFLLENBQUNHLElBQU4sQ0FBV0YsSUFBWCxDQUFkO0FBQ0EsU0FBT0osS0FBSyxJQUFJLElBQVQsR0FBZ0IsSUFBaEIsR0FBdUJBLEtBQUssQ0FBQyxDQUFELENBQW5DO0FBQ0Q7O0FBRU0sU0FBU08saUJBQVQsQ0FDTHZCLFFBREssRUFFTFMsS0FGSyxFQUdJO0FBQ1QsU0FBT2UsS0FBSyxDQUFDQyxPQUFOLENBQWNoQixLQUFkLElBQ0hBLEtBQUssQ0FBQ2lCLElBQU4sQ0FBV0MsQ0FBQyxJQUFJQSxDQUFDLENBQUNDLGFBQUYsQ0FBZ0I1QixRQUFoQixDQUFoQixDQURHLEdBRUhTLEtBQUssQ0FBQ21CLGFBQU4sQ0FBb0I1QixRQUFwQixDQUZKO0FBR0QiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIEBmbG93IHN0cmljdFxyXG4gKiBAZm9ybWF0XHJcbiAqL1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHdvcmRBdFBvc2l0aW9uRnJvbUJ1ZmZlcihcclxuICBidWZmZXI6IGF0b20kVGV4dEJ1ZmZlciB8IHNpbXBsZVRleHRCdWZmZXIkVGV4dEJ1ZmZlcixcclxuICBwb3NpdGlvbjogYXRvbSRQb2ludE9iamVjdCxcclxuICB3b3JkUmVnZXg6IFJlZ0V4cCxcclxuKTogP3t3b3JkTWF0Y2g6IEFycmF5PHN0cmluZz4sIHJhbmdlOiBhdG9tJFJhbmdlfSB7XHJcbiAgY29uc3Qge3JvdywgY29sdW1ufSA9IHBvc2l0aW9uO1xyXG4gIGNvbnN0IHJvd1JhbmdlID0gYnVmZmVyLnJhbmdlRm9yUm93KHJvdyk7XHJcbiAgbGV0IG1hdGNoRGF0YTtcclxuICAvLyBFeHRyYWN0IHRoZSBleHByZXNzaW9uIGZyb20gdGhlIHJvdyB0ZXh0LlxyXG4gIGJ1ZmZlci5zY2FuSW5SYW5nZSh3b3JkUmVnZXgsIHJvd1JhbmdlLCBkYXRhID0+IHtcclxuICAgIGNvbnN0IHtyYW5nZX0gPSBkYXRhO1xyXG4gICAgaWYgKFxyXG4gICAgICByYW5nZS5zdGFydC5pc0xlc3NUaGFuT3JFcXVhbChwb3NpdGlvbikgJiZcclxuICAgICAgcmFuZ2UuZW5kLmlzR3JlYXRlclRoYW4ocG9zaXRpb24pXHJcbiAgICApIHtcclxuICAgICAgbWF0Y2hEYXRhID0gZGF0YTtcclxuICAgIH1cclxuICAgIC8vIFN0b3AgdGhlIHNjYW4gaWYgdGhlIHNjYW5uZXIgaGFzIHBhc3NlZCBvdXIgcG9zaXRpb24uXHJcbiAgICBpZiAocmFuZ2UuZW5kLmNvbHVtbiA+IGNvbHVtbikge1xyXG4gICAgICBkYXRhLnN0b3AoKTtcclxuICAgIH1cclxuICB9KTtcclxuICBpZiAobWF0Y2hEYXRhKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB3b3JkTWF0Y2g6IG1hdGNoRGF0YS5tYXRjaCxcclxuICAgICAgcmFuZ2U6IG1hdGNoRGF0YS5yYW5nZSxcclxuICAgIH07XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuLy8gTWF0Y2hlcyBhIHJlZ2V4IG9uIHRoZSB0ZXh0IG9mIHRoZSBsaW5lIGVuZGluZyBhdCBlbmRQb3NpdGlvbi5cclxuLy8gcmVnZXggc2hvdWxkIGVuZCB3aXRoIGEgJyQnLlxyXG4vLyBVc2VmdWwgZm9yIGF1dG9jb21wbGV0ZS5cclxuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoUmVnZXhFbmRpbmdBdChcclxuICBidWZmZXI6IGF0b20kVGV4dEJ1ZmZlciB8IHNpbXBsZVRleHRCdWZmZXIkVGV4dEJ1ZmZlcixcclxuICBlbmRQb3NpdGlvbjogYXRvbSRQb2ludE9iamVjdCxcclxuICByZWdleDogUmVnRXhwLFxyXG4pOiA/c3RyaW5nIHtcclxuICBjb25zdCBsaW5lID0gYnVmZmVyLmdldFRleHRJblJhbmdlKFtbZW5kUG9zaXRpb24ucm93LCAwXSwgZW5kUG9zaXRpb25dKTtcclxuICBjb25zdCBtYXRjaCA9IHJlZ2V4LmV4ZWMobGluZSk7XHJcbiAgcmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2hbMF07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1Bvc2l0aW9uSW5SYW5nZShcclxuICBwb3NpdGlvbjogYXRvbSRQb2ludCxcclxuICByYW5nZTogYXRvbSRSYW5nZSB8IEFycmF5PGF0b20kUmFuZ2U+LFxyXG4pOiBib29sZWFuIHtcclxuICByZXR1cm4gQXJyYXkuaXNBcnJheShyYW5nZSlcclxuICAgID8gcmFuZ2Uuc29tZShyID0+IHIuY29udGFpbnNQb2ludChwb3NpdGlvbikpXHJcbiAgICA6IHJhbmdlLmNvbnRhaW5zUG9pbnQocG9zaXRpb24pO1xyXG59XHJcbiJdfQ==