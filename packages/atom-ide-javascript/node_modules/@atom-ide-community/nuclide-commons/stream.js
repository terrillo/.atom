"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.observeStream = observeStream;
exports.observeRawStream = observeRawStream;
exports.writeToStream = writeToStream;

var _stream = _interopRequireDefault(require("stream"));

var _rxjsCompatUmdMin = require("rxjs-compat/bundles/rxjs-compat.umd.min.js");

var _UniversalDisposable = _interopRequireDefault(require("./UniversalDisposable"));

var _event = require("./event");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */

/**
 * Observe a stream like stdout or stderr.
 */
function observeStream(stream) {
  return observeRawStream(stream).map(data => data.toString());
}

function observeRawStream(stream) {
  const error = _rxjsCompatUmdMin.Observable.fromEvent(stream, 'error').flatMap(_rxjsCompatUmdMin.Observable.throw);

  return _rxjsCompatUmdMin.Observable.fromEvent(stream, 'data').merge(error).takeUntil(_rxjsCompatUmdMin.Observable.fromEvent(stream, 'end'));
}
/**
 * Write an observed readable stream into a writable stream. Effectively a pipe() for observables.
 * Returns an observable accumulating the number of bytes processed.
 */


function writeToStream(source, destStream) {
  return _rxjsCompatUmdMin.Observable.create(observer => {
    let byteCount = 0;
    const byteCounterStream = new _stream.default.Transform({
      transform(chunk, encoding, cb) {
        byteCount += chunk.byteLength;
        observer.next(byteCount);
        cb(null, chunk);
      }

    });
    byteCounterStream.pipe(destStream);
    return new _UniversalDisposable.default((0, _event.attachEvent)(destStream, 'error', err => {
      observer.error(err);
    }), (0, _event.attachEvent)(destStream, 'close', () => {
      observer.complete();
    }), source.subscribe(buffer => {
      byteCounterStream.write(buffer);
    }, err => {
      observer.error(err);
    }, () => {
      byteCounterStream.end();
    }));
  }).share();
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zL3N0cmVhbS5qcyJdLCJuYW1lcyI6WyJvYnNlcnZlU3RyZWFtIiwic3RyZWFtIiwib2JzZXJ2ZVJhd1N0cmVhbSIsIm1hcCIsImRhdGEiLCJ0b1N0cmluZyIsImVycm9yIiwiT2JzZXJ2YWJsZSIsImZyb21FdmVudCIsImZsYXRNYXAiLCJ0aHJvdyIsIm1lcmdlIiwidGFrZVVudGlsIiwid3JpdGVUb1N0cmVhbSIsInNvdXJjZSIsImRlc3RTdHJlYW0iLCJjcmVhdGUiLCJvYnNlcnZlciIsImJ5dGVDb3VudCIsImJ5dGVDb3VudGVyU3RyZWFtIiwiU3RyZWFtIiwiVHJhbnNmb3JtIiwidHJhbnNmb3JtIiwiY2h1bmsiLCJlbmNvZGluZyIsImNiIiwiYnl0ZUxlbmd0aCIsIm5leHQiLCJwaXBlIiwiVW5pdmVyc2FsRGlzcG9zYWJsZSIsImVyciIsImNvbXBsZXRlIiwic3Vic2NyaWJlIiwiYnVmZmVyIiwid3JpdGUiLCJlbmQiLCJzaGFyZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBWUE7O0FBQ0E7O0FBRUE7O0FBQ0E7Ozs7QUFoQkE7Ozs7Ozs7Ozs7OztBQWtCQTs7O0FBR08sU0FBU0EsYUFBVCxDQUF1QkMsTUFBdkIsRUFBb0U7QUFDekUsU0FBT0MsZ0JBQWdCLENBQUNELE1BQUQsQ0FBaEIsQ0FBeUJFLEdBQXpCLENBQTZCQyxJQUFJLElBQUlBLElBQUksQ0FBQ0MsUUFBTCxFQUFyQyxDQUFQO0FBQ0Q7O0FBRU0sU0FBU0gsZ0JBQVQsQ0FBMEJELE1BQTFCLEVBQXVFO0FBQzVFLFFBQU1LLEtBQUssR0FBR0MsNkJBQVdDLFNBQVgsQ0FBcUJQLE1BQXJCLEVBQTZCLE9BQTdCLEVBQXNDUSxPQUF0QyxDQUE4Q0YsNkJBQVdHLEtBQXpELENBQWQ7O0FBQ0EsU0FBT0gsNkJBQVdDLFNBQVgsQ0FBcUJQLE1BQXJCLEVBQTZCLE1BQTdCLEVBQ0pVLEtBREksQ0FDRUwsS0FERixFQUVKTSxTQUZJLENBRU1MLDZCQUFXQyxTQUFYLENBQXFCUCxNQUFyQixFQUE2QixLQUE3QixDQUZOLENBQVA7QUFHRDtBQUVEOzs7Ozs7QUFJTyxTQUFTWSxhQUFULENBQ0xDLE1BREssRUFFTEMsVUFGSyxFQUdlO0FBQ3BCLFNBQU9SLDZCQUFXUyxNQUFYLENBQWtCQyxRQUFRLElBQUk7QUFDbkMsUUFBSUMsU0FBUyxHQUFHLENBQWhCO0FBRUEsVUFBTUMsaUJBQWlCLEdBQUcsSUFBSUMsZ0JBQU9DLFNBQVgsQ0FBcUI7QUFDN0NDLE1BQUFBLFNBQVMsQ0FBQ0MsS0FBRCxFQUFRQyxRQUFSLEVBQWtCQyxFQUFsQixFQUFzQjtBQUM3QlAsUUFBQUEsU0FBUyxJQUFJSyxLQUFLLENBQUNHLFVBQW5CO0FBQ0FULFFBQUFBLFFBQVEsQ0FBQ1UsSUFBVCxDQUFjVCxTQUFkO0FBQ0FPLFFBQUFBLEVBQUUsQ0FBQyxJQUFELEVBQU9GLEtBQVAsQ0FBRjtBQUNEOztBQUw0QyxLQUFyQixDQUExQjtBQVFBSixJQUFBQSxpQkFBaUIsQ0FBQ1MsSUFBbEIsQ0FBdUJiLFVBQXZCO0FBRUEsV0FBTyxJQUFJYyw0QkFBSixDQUNMLHdCQUFZZCxVQUFaLEVBQXdCLE9BQXhCLEVBQWlDZSxHQUFHLElBQUk7QUFDdENiLE1BQUFBLFFBQVEsQ0FBQ1gsS0FBVCxDQUFld0IsR0FBZjtBQUNELEtBRkQsQ0FESyxFQUlMLHdCQUFZZixVQUFaLEVBQXdCLE9BQXhCLEVBQWlDLE1BQU07QUFDckNFLE1BQUFBLFFBQVEsQ0FBQ2MsUUFBVDtBQUNELEtBRkQsQ0FKSyxFQU9MakIsTUFBTSxDQUFDa0IsU0FBUCxDQUNFQyxNQUFNLElBQUk7QUFDUmQsTUFBQUEsaUJBQWlCLENBQUNlLEtBQWxCLENBQXdCRCxNQUF4QjtBQUNELEtBSEgsRUFJRUgsR0FBRyxJQUFJO0FBQ0xiLE1BQUFBLFFBQVEsQ0FBQ1gsS0FBVCxDQUFld0IsR0FBZjtBQUNELEtBTkgsRUFPRSxNQUFNO0FBQ0pYLE1BQUFBLGlCQUFpQixDQUFDZ0IsR0FBbEI7QUFDRCxLQVRILENBUEssQ0FBUDtBQW1CRCxHQWhDTSxFQWdDSkMsS0FoQ0ksRUFBUDtBQWlDRCIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTctcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogQGZsb3cgc3RyaWN0LWxvY2FsXHJcbiAqIEBmb3JtYXRcclxuICovXHJcblxyXG5pbXBvcnQgU3RyZWFtIGZyb20gJ3N0cmVhbSc7XHJcbmltcG9ydCB7T2JzZXJ2YWJsZX0gZnJvbSAncnhqcy1jb21wYXQvYnVuZGxlcy9yeGpzLWNvbXBhdC51bWQubWluLmpzJztcclxuXHJcbmltcG9ydCBVbml2ZXJzYWxEaXNwb3NhYmxlIGZyb20gJy4vVW5pdmVyc2FsRGlzcG9zYWJsZSc7XHJcbmltcG9ydCB7YXR0YWNoRXZlbnR9IGZyb20gJy4vZXZlbnQnO1xyXG5cclxuLyoqXHJcbiAqIE9ic2VydmUgYSBzdHJlYW0gbGlrZSBzdGRvdXQgb3Igc3RkZXJyLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG9ic2VydmVTdHJlYW0oc3RyZWFtOiBzdHJlYW0kUmVhZGFibGUpOiBPYnNlcnZhYmxlPHN0cmluZz4ge1xyXG4gIHJldHVybiBvYnNlcnZlUmF3U3RyZWFtKHN0cmVhbSkubWFwKGRhdGEgPT4gZGF0YS50b1N0cmluZygpKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG9ic2VydmVSYXdTdHJlYW0oc3RyZWFtOiBzdHJlYW0kUmVhZGFibGUpOiBPYnNlcnZhYmxlPEJ1ZmZlcj4ge1xyXG4gIGNvbnN0IGVycm9yID0gT2JzZXJ2YWJsZS5mcm9tRXZlbnQoc3RyZWFtLCAnZXJyb3InKS5mbGF0TWFwKE9ic2VydmFibGUudGhyb3cpO1xyXG4gIHJldHVybiBPYnNlcnZhYmxlLmZyb21FdmVudChzdHJlYW0sICdkYXRhJylcclxuICAgIC5tZXJnZShlcnJvcilcclxuICAgIC50YWtlVW50aWwoT2JzZXJ2YWJsZS5mcm9tRXZlbnQoc3RyZWFtLCAnZW5kJykpO1xyXG59XHJcblxyXG4vKipcclxuICogV3JpdGUgYW4gb2JzZXJ2ZWQgcmVhZGFibGUgc3RyZWFtIGludG8gYSB3cml0YWJsZSBzdHJlYW0uIEVmZmVjdGl2ZWx5IGEgcGlwZSgpIGZvciBvYnNlcnZhYmxlcy5cclxuICogUmV0dXJucyBhbiBvYnNlcnZhYmxlIGFjY3VtdWxhdGluZyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHByb2Nlc3NlZC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB3cml0ZVRvU3RyZWFtKFxyXG4gIHNvdXJjZTogT2JzZXJ2YWJsZTxCdWZmZXI+LFxyXG4gIGRlc3RTdHJlYW06IHN0cmVhbSRXcml0YWJsZSxcclxuKTogT2JzZXJ2YWJsZTxudW1iZXI+IHtcclxuICByZXR1cm4gT2JzZXJ2YWJsZS5jcmVhdGUob2JzZXJ2ZXIgPT4ge1xyXG4gICAgbGV0IGJ5dGVDb3VudCA9IDA7XHJcblxyXG4gICAgY29uc3QgYnl0ZUNvdW50ZXJTdHJlYW0gPSBuZXcgU3RyZWFtLlRyYW5zZm9ybSh7XHJcbiAgICAgIHRyYW5zZm9ybShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XHJcbiAgICAgICAgYnl0ZUNvdW50ICs9IGNodW5rLmJ5dGVMZW5ndGg7XHJcbiAgICAgICAgb2JzZXJ2ZXIubmV4dChieXRlQ291bnQpO1xyXG4gICAgICAgIGNiKG51bGwsIGNodW5rKTtcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG5cclxuICAgIGJ5dGVDb3VudGVyU3RyZWFtLnBpcGUoZGVzdFN0cmVhbSk7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBVbml2ZXJzYWxEaXNwb3NhYmxlKFxyXG4gICAgICBhdHRhY2hFdmVudChkZXN0U3RyZWFtLCAnZXJyb3InLCBlcnIgPT4ge1xyXG4gICAgICAgIG9ic2VydmVyLmVycm9yKGVycik7XHJcbiAgICAgIH0pLFxyXG4gICAgICBhdHRhY2hFdmVudChkZXN0U3RyZWFtLCAnY2xvc2UnLCAoKSA9PiB7XHJcbiAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcclxuICAgICAgfSksXHJcbiAgICAgIHNvdXJjZS5zdWJzY3JpYmUoXHJcbiAgICAgICAgYnVmZmVyID0+IHtcclxuICAgICAgICAgIGJ5dGVDb3VudGVyU3RyZWFtLndyaXRlKGJ1ZmZlcik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlcnIgPT4ge1xyXG4gICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZXJyKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgICgpID0+IHtcclxuICAgICAgICAgIGJ5dGVDb3VudGVyU3RyZWFtLmVuZCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICksXHJcbiAgICApO1xyXG4gIH0pLnNoYXJlKCk7XHJcbn1cclxuIl19