"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.stringifyError = stringifyError;
exports.maybeToString = maybeToString;
exports.relativeDate = relativeDate;
exports.countOccurrences = countOccurrences;
exports.shellParse = shellParse;
exports.shellParseWithGlobs = shellParseWithGlobs;
exports.shellQuote = shellQuote;
exports.removeCommonPrefix = removeCommonPrefix;
exports.removeCommonSuffix = removeCommonSuffix;
exports.shorten = shorten;
exports.splitOnce = splitOnce;
exports.indent = indent;
exports.pluralize = pluralize;
exports.capitalize = capitalize;
exports.getMatchRanges = getMatchRanges;
exports.escapeMarkdown = escapeMarkdown;
exports.ZERO_WIDTH_SPACE = exports.ELLIPSIS_CHAR = exports.URL_REGEX = void 0;

var _assert = _interopRequireDefault(require("assert"));

var _shellQuote = require("./_shell-quote");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */
function stringifyError(error) {
  return `name: ${error.name}, message: ${error.message}, stack: ${error.stack}.`;
} // As of Flow v0.28, Flow does not alllow implicit string coercion of null or undefined. Use this to
// make it explicit.


function maybeToString(str) {
  // We don't want to encourage the use of this function directly because it coerces anything to a
  // string. We get stricter typechecking by using maybeToString, so it should generally be
  // preferred.
  return String(str);
}
/**
 * Originally adapted from https://github.com/azer/relative-date.
 * We're including it because of https://github.com/npm/npm/issues/12012
 */


const SECOND = 1000;
const MINUTE = 60 * SECOND;
const HOUR = 60 * MINUTE;
const DAY = 24 * HOUR;
const WEEK = 7 * DAY;
const YEAR = DAY * 365;
const MONTH = YEAR / 12;
const shortFormats = [[0.7 * MINUTE, 'now'], [1.5 * MINUTE, '1m'], [60 * MINUTE, 'm', MINUTE], [1.5 * HOUR, '1h'], [DAY, 'h', HOUR], [2 * DAY, '1d'], [7 * DAY, 'd', DAY], [1.5 * WEEK, '1w'], [MONTH, 'w', WEEK], [1.5 * MONTH, '1mo'], [YEAR, 'mo', MONTH], [1.5 * YEAR, '1y'], [Number.MAX_VALUE, 'y', YEAR]];
const longFormats = [[0.7 * MINUTE, 'just now'], [1.5 * MINUTE, 'a minute ago'], [60 * MINUTE, 'minutes ago', MINUTE], [1.5 * HOUR, 'an hour ago'], [DAY, 'hours ago', HOUR], [2 * DAY, 'yesterday'], [7 * DAY, 'days ago', DAY], [1.5 * WEEK, 'a week ago'], [MONTH, 'weeks ago', WEEK], [1.5 * MONTH, 'a month ago'], [YEAR, 'months ago', MONTH], [1.5 * YEAR, 'a year ago'], [Number.MAX_VALUE, 'years ago', YEAR]];
const longFormatsNumbers = [[0.7 * MINUTE, 'just now'], [1.5 * MINUTE, '1 minute ago'], [60 * MINUTE, 'minutes ago', MINUTE], [1.5 * HOUR, '1 hour ago'], [DAY, 'hours ago', HOUR], [2 * DAY, 'yesterday'], [7 * DAY, 'days ago', DAY], [1.5 * WEEK, '1 week ago'], [MONTH, 'weeks ago', WEEK], [1.5 * MONTH, '1 month ago'], [YEAR, 'months ago', MONTH], [1.5 * YEAR, '1 year ago'], [Number.MAX_VALUE, 'years ago', YEAR]];

function relativeDate(input_, reference_, useShortVariant = false, useNumbersOnly = false) {
  let input = input_;
  let reference = reference_;

  if (input instanceof Date) {
    input = input.getTime();
  } // flowlint-next-line sketchy-null-number:off


  if (!reference) {
    reference = new Date().getTime();
  }

  if (reference instanceof Date) {
    reference = reference.getTime();
  }

  const delta = reference - input;
  const formats = useShortVariant ? shortFormats : useNumbersOnly ? longFormatsNumbers : longFormats;

  for (const [limit, relativeFormat, remainder] of formats) {
    if (delta < limit) {
      if (typeof remainder === 'number') {
        return Math.round(delta / remainder) + (useShortVariant ? '' : ' ') + relativeFormat;
      } else {
        return relativeFormat;
      }
    }
  }

  throw new Error('This should never be reached.');
}
/**
 * Count the number of occurrences of `char` in `str`.
 * `char` must be a string of length 1.
 */


function countOccurrences(haystack, char) {
  (0, _assert.default)(char.length === 1, 'char must be a string of length 1');
  let count = 0;
  const code = char.charCodeAt(0);

  for (let i = 0; i < haystack.length; i++) {
    if (haystack.charCodeAt(i) === code) {
      count++;
    }
  }

  return count;
}
/**
 * shell-quote's parse allows pipe operators and comments.
 * Generally users don't care about this, so throw if we encounter any operators.
 */


function shellParse(str, env) {
  const result = (0, _shellQuote.parse)(str, env);

  for (let i = 0; i < result.length; i++) {
    if (typeof result[i] !== 'string') {
      if (result[i].op != null) {
        throw new Error(`Unexpected operator "${result[i].op}" provided to shellParse`);
      } else {
        throw new Error(`Unexpected comment "${result[i].comment}" provided to shellParse`);
      }
    }
  }

  return result;
}
/**
 * shell-quote's parse allows pipe operators and comments and globs
 * We treat glob patterns as normal strings. For the other operators, we throw.
 */


function shellParseWithGlobs(str, env) {
  const result = (0, _shellQuote.parse)(str, env);

  for (let i = 0; i < result.length; i++) {
    if (typeof result[i] !== 'string') {
      if (result[i].op === 'glob') {
        result[i] = result[i].pattern;
      } else if (result[i].op != null) {
        throw new Error(`Unexpected operator "${result[i].op}" provided to shellParse`);
      } else {
        throw new Error(`Unexpected comment "${result[i].comment}" provided to shellParse`);
      }
    }
  }

  return result;
}
/**
 * Technically you can pass in { operator: string } here,
 * but we don't use that in most APIs.
 */


function shellQuote(args) {
  return (0, _shellQuote.quote)(args);
}

function removeCommonPrefix(a, b) {
  let i = 0;

  while (a[i] === b[i] && i < a.length && i < b.length) {
    i++;
  }

  return [a.substring(i), b.substring(i)];
}

function removeCommonSuffix(a, b) {
  let i = 0;

  while (a[a.length - 1 - i] === b[b.length - 1 - i] && i < a.length && i < b.length) {
    i++;
  }

  return [a.substring(0, a.length - i), b.substring(0, b.length - i)];
}

function shorten(str, maxLength, suffix) {
  return str.length < maxLength ? str : str.slice(0, maxLength) + (suffix || '');
}
/**
 * Like String.split, but only splits once.
 */


function splitOnce(str, separator) {
  const index = str.indexOf(separator);
  return index === -1 ? [str, null] : [str.slice(0, index), str.slice(index + separator.length)];
}
/**
 * Indents each line by the specified number of characters.
 */


function indent(str, level = 2, char = ' ') {
  return str.replace(/^([^\n])/gm, char.repeat(level) + '$1');
}

function pluralize(noun, count) {
  return count === 1 ? noun : noun + 's';
}

function capitalize(str) {
  return str.length === 0 ? str : str.charAt(0).toUpperCase().concat(str.slice(1));
}

/**
 * Returns a list of ranges where needle occurs in haystack.
 * This will *not* return overlapping matches; i.e. the returned list will be disjoint.
 * This makes it easier to use for e.g. highlighting matches in a UI.
 */
function getMatchRanges(haystack, needle) {
  if (needle === '') {
    // Not really a valid use.
    return [];
  }

  const ranges = [];
  let matchIndex = 0;

  while ((matchIndex = haystack.indexOf(needle, matchIndex)) !== -1) {
    const prevRange = ranges[ranges.length - 1];

    if (prevRange != null && prevRange[1] === matchIndex) {
      prevRange[1] += needle.length;
    } else {
      ranges.push([matchIndex, matchIndex + needle.length]);
    }

    matchIndex += needle.length;
  }

  return ranges;
}

function escapeMarkdown(markdown) {
  // Which characters can be backslash-escaped?
  // markdown:   ! #    ()*+ -.        [\] _`{ }   https://daringfireball.net/projects/markdown/syntax#backslash
  // commonMark: !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~  https://spec.commonmark.org/0.28/#backslash-escapes
  // We'll only backslash-escape the lowest common denominator.
  const slashEscaped = markdown.replace(/[#!()*+\-.[\\\]_`{}]/g, '\\$&'); // And HTML tags need to be &lt; &gt; escaped.

  return slashEscaped.replace(/</g, '&lt;').replace(/>/g, '&gt;');
} // Originally copied from:
// http://stackoverflow.com/questions/3809401/what-is-a-good-regular-expression-to-match-a-url
// But adopted to match `www.` urls as well as `https?` urls
// and `!` as acceptable url piece.
// Then optimized with https://www.npmjs.com/package/regexp-tree.
// Added a single matching group for use with String.split.
// eslint-disable-next-line max-len


const URL_REGEX = /(https?:\/\/(?:www\.)?[-\w@:%.+~#=]{2,256}\.[a-z]{2,6}\b[-\w@:%+.~#?&/=!]*|www\.[-\w@:%.+~#=]{2,256}\.[a-z]{2,6}\b[-\w@:%+.~#?&/=!]*)/;
exports.URL_REGEX = URL_REGEX;
const ELLIPSIS_CHAR = '\u2026';
exports.ELLIPSIS_CHAR = ELLIPSIS_CHAR;
const ZERO_WIDTH_SPACE = '\u200B';
exports.ZERO_WIDTH_SPACE = ZERO_WIDTH_SPACE;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zL3N0cmluZy5qcyJdLCJuYW1lcyI6WyJzdHJpbmdpZnlFcnJvciIsImVycm9yIiwibmFtZSIsIm1lc3NhZ2UiLCJzdGFjayIsIm1heWJlVG9TdHJpbmciLCJzdHIiLCJTdHJpbmciLCJTRUNPTkQiLCJNSU5VVEUiLCJIT1VSIiwiREFZIiwiV0VFSyIsIllFQVIiLCJNT05USCIsInNob3J0Rm9ybWF0cyIsIk51bWJlciIsIk1BWF9WQUxVRSIsImxvbmdGb3JtYXRzIiwibG9uZ0Zvcm1hdHNOdW1iZXJzIiwicmVsYXRpdmVEYXRlIiwiaW5wdXRfIiwicmVmZXJlbmNlXyIsInVzZVNob3J0VmFyaWFudCIsInVzZU51bWJlcnNPbmx5IiwiaW5wdXQiLCJyZWZlcmVuY2UiLCJEYXRlIiwiZ2V0VGltZSIsImRlbHRhIiwiZm9ybWF0cyIsImxpbWl0IiwicmVsYXRpdmVGb3JtYXQiLCJyZW1haW5kZXIiLCJNYXRoIiwicm91bmQiLCJFcnJvciIsImNvdW50T2NjdXJyZW5jZXMiLCJoYXlzdGFjayIsImNoYXIiLCJsZW5ndGgiLCJjb3VudCIsImNvZGUiLCJjaGFyQ29kZUF0IiwiaSIsInNoZWxsUGFyc2UiLCJlbnYiLCJyZXN1bHQiLCJvcCIsImNvbW1lbnQiLCJzaGVsbFBhcnNlV2l0aEdsb2JzIiwicGF0dGVybiIsInNoZWxsUXVvdGUiLCJhcmdzIiwicmVtb3ZlQ29tbW9uUHJlZml4IiwiYSIsImIiLCJzdWJzdHJpbmciLCJyZW1vdmVDb21tb25TdWZmaXgiLCJzaG9ydGVuIiwibWF4TGVuZ3RoIiwic3VmZml4Iiwic2xpY2UiLCJzcGxpdE9uY2UiLCJzZXBhcmF0b3IiLCJpbmRleCIsImluZGV4T2YiLCJpbmRlbnQiLCJsZXZlbCIsInJlcGxhY2UiLCJyZXBlYXQiLCJwbHVyYWxpemUiLCJub3VuIiwiY2FwaXRhbGl6ZSIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwiY29uY2F0IiwiZ2V0TWF0Y2hSYW5nZXMiLCJuZWVkbGUiLCJyYW5nZXMiLCJtYXRjaEluZGV4IiwicHJldlJhbmdlIiwicHVzaCIsImVzY2FwZU1hcmtkb3duIiwibWFya2Rvd24iLCJzbGFzaEVzY2FwZWQiLCJVUkxfUkVHRVgiLCJFTExJUFNJU19DSEFSIiwiWkVST19XSURUSF9TUEFDRSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFZQTs7QUFDQTs7OztBQWJBOzs7Ozs7Ozs7OztBQWVPLFNBQVNBLGNBQVQsQ0FBd0JDLEtBQXhCLEVBQThDO0FBQ25ELFNBQVEsU0FBUUEsS0FBSyxDQUFDQyxJQUFLLGNBQWFELEtBQUssQ0FBQ0UsT0FBUSxZQUNwREYsS0FBSyxDQUFDRyxLQUNQLEdBRkQ7QUFHRCxDLENBRUQ7QUFDQTs7O0FBQ08sU0FBU0MsYUFBVCxDQUF1QkMsR0FBdkIsRUFBNkM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsU0FBT0MsTUFBTSxDQUFDRCxHQUFELENBQWI7QUFDRDtBQUVEOzs7Ozs7QUFJQSxNQUFNRSxNQUFNLEdBQUcsSUFBZjtBQUNBLE1BQU1DLE1BQU0sR0FBRyxLQUFLRCxNQUFwQjtBQUNBLE1BQU1FLElBQUksR0FBRyxLQUFLRCxNQUFsQjtBQUNBLE1BQU1FLEdBQUcsR0FBRyxLQUFLRCxJQUFqQjtBQUNBLE1BQU1FLElBQUksR0FBRyxJQUFJRCxHQUFqQjtBQUNBLE1BQU1FLElBQUksR0FBR0YsR0FBRyxHQUFHLEdBQW5CO0FBQ0EsTUFBTUcsS0FBSyxHQUFHRCxJQUFJLEdBQUcsRUFBckI7QUFFQSxNQUFNRSxZQUFZLEdBQUcsQ0FDbkIsQ0FBQyxNQUFNTixNQUFQLEVBQWUsS0FBZixDQURtQixFQUVuQixDQUFDLE1BQU1BLE1BQVAsRUFBZSxJQUFmLENBRm1CLEVBR25CLENBQUMsS0FBS0EsTUFBTixFQUFjLEdBQWQsRUFBbUJBLE1BQW5CLENBSG1CLEVBSW5CLENBQUMsTUFBTUMsSUFBUCxFQUFhLElBQWIsQ0FKbUIsRUFLbkIsQ0FBQ0MsR0FBRCxFQUFNLEdBQU4sRUFBV0QsSUFBWCxD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LENBQUMsQ0FBRCxDQUFULElBQWdCSCxNQUFNLENBQUN0QyxNQUF2QjtBQUNELEtBRkQsTUFFTztBQUNMdUMsTUFBQUEsTUFBTSxDQUFDRyxJQUFQLENBQVksQ0FBQ0YsVUFBRCxFQUFhQSxVQUFVLEdBQUdGLE1BQU0sQ0FBQ3RDLE1BQWpDLENBQVo7QUFDRDs7QUFDRHdDLElBQUFBLFVBQVUsSUFBSUYsTUFBTSxDQUFDdEMsTUFBckI7QUFDRDs7QUFDRCxTQUFPdUMsTUFBUDtBQUNEOztBQUVNLFNBQVNJLGNBQVQsQ0FBd0JDLFFBQXhCLEVBQWtEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTUMsWUFBWSxHQUFHRCxRQUFRLENBQUNmLE9BQVQsQ0FBaUIsdUJBQWpCLEVBQTBDLE1BQTFDLENBQXJCLENBTHVELENBTXZEOztBQUNBLFNBQU9nQixZQUFZLENBQUNoQixPQUFiLENBQXFCLElBQXJCLEVBQTJCLE1BQTNCLEVBQW1DQSxPQUFuQyxDQUEyQyxJQUEzQyxFQUFpRCxNQUFqRCxDQUFQO0FBQ0QsQyxDQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDTyxNQUFNaUIsU0FBUyxHQUFHLHVJQUFsQjs7QUFFQSxNQUFNQyxhQUFhLEdBQUcsUUFBdEI7O0FBQ0EsTUFBTUMsZ0JBQWdCLEdBQUcsUUFBekIiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIEBmbG93XHJcbiAqIEBmb3JtYXRcclxuICovXHJcblxyXG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2Fzc2VydCc7XHJcbmltcG9ydCB7cGFyc2UsIHF1b3RlfSBmcm9tICcuL19zaGVsbC1xdW90ZSc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5naWZ5RXJyb3IoZXJyb3I6IEVycm9yKTogc3RyaW5nIHtcclxuICByZXR1cm4gYG5hbWU6ICR7ZXJyb3IubmFtZX0sIG1lc3NhZ2U6ICR7ZXJyb3IubWVzc2FnZX0sIHN0YWNrOiAke1xyXG4gICAgZXJyb3Iuc3RhY2tcclxuICB9LmA7XHJcbn1cclxuXHJcbi8vIEFzIG9mIEZsb3cgdjAuMjgsIEZsb3cgZG9lcyBub3QgYWxsbG93IGltcGxpY2l0IHN0cmluZyBjb2VyY2lvbiBvZiBudWxsIG9yIHVuZGVmaW5lZC4gVXNlIHRoaXMgdG9cclxuLy8gbWFrZSBpdCBleHBsaWNpdC5cclxuZXhwb3J0IGZ1bmN0aW9uIG1heWJlVG9TdHJpbmcoc3RyOiA/c3RyaW5nKTogc3RyaW5nIHtcclxuICAvLyBXZSBkb24ndCB3YW50IHRvIGVuY291cmFnZSB0aGUgdXNlIG9mIHRoaXMgZnVuY3Rpb24gZGlyZWN0bHkgYmVjYXVzZSBpdCBjb2VyY2VzIGFueXRoaW5nIHRvIGFcclxuICAvLyBzdHJpbmcuIFdlIGdldCBzdHJpY3RlciB0eXBlY2hlY2tpbmcgYnkgdXNpbmcgbWF5YmVUb1N0cmluZywgc28gaXQgc2hvdWxkIGdlbmVyYWxseSBiZVxyXG4gIC8vIHByZWZlcnJlZC5cclxuICByZXR1cm4gU3RyaW5nKHN0cik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBPcmlnaW5hbGx5IGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYXplci9yZWxhdGl2ZS1kYXRlLlxyXG4gKiBXZSdyZSBpbmNsdWRpbmcgaXQgYmVjYXVzZSBvZiBodHRwczovL2dpdGh1Yi5jb20vbnBtL25wbS9pc3N1ZXMvMTIwMTJcclxuICovXHJcbmNvbnN0IFNFQ09ORCA9IDEwMDA7XHJcbmNvbnN0IE1JTlVURSA9IDYwICogU0VDT05EO1xyXG5jb25zdCBIT1VSID0gNjAgKiBNSU5VVEU7XHJcbmNvbnN0IERBWSA9IDI0ICogSE9VUjtcclxuY29uc3QgV0VFSyA9IDcgKiBEQVk7XHJcbmNvbnN0IFlFQVIgPSBEQVkgKiAzNjU7XHJcbmNvbnN0IE1PTlRIID0gWUVBUiAvIDEyO1xyXG5cclxuY29uc3Qgc2hvcnRGb3JtYXRzID0gW1xyXG4gIFswLjcgKiBNSU5VVEUsICdub3cnXSxcclxuICBbMS41ICogTUlOVVRFLCAnMW0nXSxcclxuICBbNjAgKiBNSU5VVEUsICdtJywgTUlOVVRFXSxcclxuICBbMS41ICogSE9VUiwgJzFoJ10sXHJcbiAgW0RBWSwgJ2gnLCBIT1VSXSxcclxuICBbMiAqIERBWSwgJzFkJ10sXHJcbiAgWzcgKiBEQVksICdkJywgREFZXSxcclxuICBbMS41ICogV0VFSywgJzF3J10sXHJcbiAgW01PTlRILCAndycsIFdFRUtdLFxyXG4gIFsxLjUgKiBNT05USCwgJzFtbyddLFxyXG4gIFtZRUFSLCAnbW8nLCBNT05USF0sXHJcbiAgWzEuNSAqIFlFQVIsICcxeSddLFxyXG4gIFtOdW1iZXIuTUFYX1ZBTFVFLCAneScsIFlFQVJdLFxyXG5dO1xyXG5cclxuY29uc3QgbG9uZ0Zvcm1hdHMgPSBbXHJcbiAgWzAuNyAqIE1JTlVURSwgJ2p1c3Qgbm93J10sXHJcbiAgWzEuNSAqIE1JTlVURSwgJ2EgbWludXRlIGFnbyddLFxyXG4gIFs2MCAqIE1JTlVURSwgJ21pbnV0ZXMgYWdvJywgTUlOVVRFXSxcclxuICBbMS41ICogSE9VUiwgJ2FuIGhvdXIgYWdvJ10sXHJcbiAgW0RBWSwgJ2hvdXJzIGFnbycsIEhPVVJdLFxyXG4gIFsyICogREFZLCAneWVzdGVyZGF5J10sXHJcbiAgWzcgKiBEQVksICdkYXlzIGFnbycsIERBWV0sXHJcbiAgWzEuNSAqIFdFRUssICdhIHdlZWsgYWdvJ10sXHJcbiAgW01PTlRILCAnd2Vla3MgYWdvJywgV0VFS10sXHJcbiAgWzEuNSAqIE1PTlRILCAnYSBtb250aCBhZ28nXSxcclxuICBbWUVBUiwgJ21vbnRocyBhZ28nLCBNT05USF0sXHJcbiAgWzEuNSAqIFlFQVIsICdhIHllYXIgYWdvJ10sXHJcbiAgW051bWJlci5NQVhfVkFMVUUsICd5ZWFycyBhZ28nLCBZRUFSXSxcclxuXTtcclxuXHJcbmNvbnN0IGxvbmdGb3JtYXRzTnVtYmVycyA9IFtcclxuICBbMC43ICogTUlOVVRFLCAnanVzdCBub3cnXSxcclxuICBbMS41ICogTUlOVVRFLCAnMSBtaW51dGUgYWdvJ10sXHJcbiAgWzYwICogTUlOVVRFLCAnbWludXRlcyBhZ28nLCBNSU5VVEVdLFxyXG4gIFsxLjUgKiBIT1VSLCAnMSBob3VyIGFnbyddLFxyXG4gIFtEQVksICdob3VycyBhZ28nLCBIT1VSXSxcclxuICBbMiAqIERBWSwgJ3llc3RlcmRheSddLFxyXG4gIFs3ICogREFZLCAnZGF5cyBhZ28nLCBEQVldLFxyXG4gIFsxLjUgKiBXRUVLLCAnMSB3ZWVrIGFnbyddLFxyXG4gIFtNT05USCwgJ3dlZWtzIGFnbycsIFdFRUtdLFxyXG4gIFsxLjUgKiBNT05USCwgJzEgbW9udGggYWdvJ10sXHJcbiAgW1lFQVIsICdtb250aHMgYWdvJywgTU9OVEhdLFxyXG4gIFsxLjUgKiBZRUFSLCAnMSB5ZWFyIGFnbyddLFxyXG4gIFtOdW1iZXIuTUFYX1ZBTFVFLCAneWVhcnMgYWdvJywgWUVBUl0sXHJcbl07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmVsYXRpdmVEYXRlKFxyXG4gIGlucHV0XzogbnVtYmVyIHwgRGF0ZSxcclxuICByZWZlcmVuY2VfPzogbnVtYmVyIHwgRGF0ZSxcclxuICB1c2VTaG9ydFZhcmlhbnQ/OiBib29sZWFuID0gZmFsc2UsXHJcbiAgdXNlTnVtYmVyc09ubHk/OiBib29sZWFuID0gZmFsc2UsXHJcbik6IHN0cmluZyB7XHJcbiAgbGV0IGlucHV0ID0gaW5wdXRfO1xyXG4gIGxldCByZWZlcmVuY2UgPSByZWZlcmVuY2VfO1xyXG4gIGlmIChpbnB1dCBpbnN0YW5jZW9mIERhdGUpIHtcclxuICAgIGlucHV0ID0gaW5wdXQuZ2V0VGltZSgpO1xyXG4gIH1cclxuICAvLyBmbG93bGludC1uZXh0LWxpbmUgc2tldGNoeS1udWxsLW51bWJlcjpvZmZcclxuICBpZiAoIXJlZmVyZW5jZSkge1xyXG4gICAgcmVmZXJlbmNlID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgfVxyXG4gIGlmIChyZWZlcmVuY2UgaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICByZWZlcmVuY2UgPSByZWZlcmVuY2UuZ2V0VGltZSgpO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgZGVsdGEgPSByZWZlcmVuY2UgLSBpbnB1dDtcclxuICBjb25zdCBmb3JtYXRzID0gdXNlU2hvcnRWYXJpYW50XHJcbiAgICA/IHNob3J0Rm9ybWF0c1xyXG4gICAgOiB1c2VOdW1iZXJzT25seVxyXG4gICAgICA/IGxvbmdGb3JtYXRzTnVtYmVyc1xyXG4gICAgICA6IGxvbmdGb3JtYXRzO1xyXG4gIGZvciAoY29uc3QgW2xpbWl0LCByZWxhdGl2ZUZvcm1hdCwgcmVtYWluZGVyXSBvZiBmb3JtYXRzKSB7XHJcbiAgICBpZiAoZGVsdGEgPCBsaW1pdCkge1xyXG4gICAgICBpZiAodHlwZW9mIHJlbWFpbmRlciA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgTWF0aC5yb3VuZChkZWx0YSAvIHJlbWFpbmRlcikgK1xyXG4gICAgICAgICAgKHVzZVNob3J0VmFyaWFudCA/ICcnIDogJyAnKSArXHJcbiAgICAgICAgICByZWxhdGl2ZUZvcm1hdFxyXG4gICAgICAgICk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHJlbGF0aXZlRm9ybWF0O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgc2hvdWxkIG5ldmVyIGJlIHJlYWNoZWQuJyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb3VudCB0aGUgbnVtYmVyIG9mIG9jY3VycmVuY2VzIG9mIGBjaGFyYCBpbiBgc3RyYC5cclxuICogYGNoYXJgIG11c3QgYmUgYSBzdHJpbmcgb2YgbGVuZ3RoIDEuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY291bnRPY2N1cnJlbmNlcyhoYXlzdGFjazogc3RyaW5nLCBjaGFyOiBzdHJpbmcpIHtcclxuICBpbnZhcmlhbnQoY2hhci5sZW5ndGggPT09IDEsICdjaGFyIG11c3QgYmUgYSBzdHJpbmcgb2YgbGVuZ3RoIDEnKTtcclxuXHJcbiAgbGV0IGNvdW50ID0gMDtcclxuICBjb25zdCBjb2RlID0gY2hhci5jaGFyQ29kZUF0KDApO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaGF5c3RhY2subGVuZ3RoOyBpKyspIHtcclxuICAgIGlmIChoYXlzdGFjay5jaGFyQ29kZUF0KGkpID09PSBjb2RlKSB7XHJcbiAgICAgIGNvdW50Kys7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBjb3VudDtcclxufVxyXG5cclxuLyoqXHJcbiAqIHNoZWxsLXF1b3RlJ3MgcGFyc2UgYWxsb3dzIHBpcGUgb3BlcmF0b3JzIGFuZCBjb21tZW50cy5cclxuICogR2VuZXJhbGx5IHVzZXJzIGRvbid0IGNhcmUgYWJvdXQgdGhpcywgc28gdGhyb3cgaWYgd2UgZW5jb3VudGVyIGFueSBvcGVyYXRvcnMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2hlbGxQYXJzZShzdHI6IHN0cmluZywgZW52PzogT2JqZWN0KTogQXJyYXk8c3RyaW5nPiB7XHJcbiAgY29uc3QgcmVzdWx0ID0gcGFyc2Uoc3RyLCBlbnYpO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICBpZiAodHlwZW9mIHJlc3VsdFtpXSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgaWYgKHJlc3VsdFtpXS5vcCAhPSBudWxsKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgYFVuZXhwZWN0ZWQgb3BlcmF0b3IgXCIke3Jlc3VsdFtpXS5vcH1cIiBwcm92aWRlZCB0byBzaGVsbFBhcnNlYCxcclxuICAgICAgICApO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgIGBVbmV4cGVjdGVkIGNvbW1lbnQgXCIke3Jlc3VsdFtpXS5jb21tZW50fVwiIHByb3ZpZGVkIHRvIHNoZWxsUGFyc2VgLFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIHNoZWxsLXF1b3RlJ3MgcGFyc2UgYWxsb3dzIHBpcGUgb3BlcmF0b3JzIGFuZCBjb21tZW50cyBhbmQgZ2xvYnNcclxuICogV2UgdHJlYXQgZ2xvYiBwYXR0ZXJucyBhcyBub3JtYWwgc3RyaW5ncy4gRm9yIHRoZSBvdGhlciBvcGVyYXRvcnMsIHdlIHRocm93LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNoZWxsUGFyc2VXaXRoR2xvYnMoc3RyOiBzdHJpbmcsIGVudj86IE9iamVjdCk6IEFycmF5PHN0cmluZz4ge1xyXG4gIGNvbnN0IHJlc3VsdCA9IHBhcnNlKHN0ciwgZW52KTtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xyXG4gICAgaWYgKHR5cGVvZiByZXN1bHRbaV0gIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIGlmIChyZXN1bHRbaV0ub3AgPT09ICdnbG9iJykge1xyXG4gICAgICAgIHJlc3VsdFtpXSA9IHJlc3VsdFtpXS5wYXR0ZXJuO1xyXG4gICAgICB9IGVsc2UgaWYgKHJlc3VsdFtpXS5vcCAhPSBudWxsKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgYFVuZXhwZWN0ZWQgb3BlcmF0b3IgXCIke3Jlc3VsdFtpXS5vcH1cIiBwcm92aWRlZCB0byBzaGVsbFBhcnNlYCxcclxuICAgICAgICApO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgIGBVbmV4cGVjdGVkIGNvbW1lbnQgXCIke3Jlc3VsdFtpXS5jb21tZW50fVwiIHByb3ZpZGVkIHRvIHNoZWxsUGFyc2VgLFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRlY2huaWNhbGx5IHlvdSBjYW4gcGFzcyBpbiB7IG9wZXJhdG9yOiBzdHJpbmcgfSBoZXJlLFxyXG4gKiBidXQgd2UgZG9uJ3QgdXNlIHRoYXQgaW4gbW9zdCBBUElzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNoZWxsUXVvdGUoYXJnczogQXJyYXk8c3RyaW5nPik6IHN0cmluZyB7XHJcbiAgcmV0dXJuIHF1b3RlKGFyZ3MpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQ29tbW9uUHJlZml4KGE6IHN0cmluZywgYjogc3RyaW5nKTogW3N0cmluZywgc3RyaW5nXSB7XHJcbiAgbGV0IGkgPSAwO1xyXG4gIHdoaWxlIChhW2ldID09PSBiW2ldICYmIGkgPCBhLmxlbmd0aCAmJiBpIDwgYi5sZW5ndGgpIHtcclxuICAgIGkrKztcclxuICB9XHJcbiAgcmV0dXJuIFthLnN1YnN0cmluZyhpKSwgYi5zdWJzdHJpbmcoaSldO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQ29tbW9uU3VmZml4KGE6IHN0cmluZywgYjogc3RyaW5nKTogW3N0cmluZywgc3RyaW5nXSB7XHJcbiAgbGV0IGkgPSAwO1xyXG4gIHdoaWxlIChcclxuICAgIGFbYS5sZW5ndGggLSAxIC0gaV0gPT09IGJbYi5sZW5ndGggLSAxIC0gaV0gJiZcclxuICAgIGkgPCBhLmxlbmd0aCAmJlxyXG4gICAgaSA8IGIubGVuZ3RoXHJcbiAgKSB7XHJcbiAgICBpKys7XHJcbiAgfVxyXG4gIHJldHVybiBbYS5zdWJzdHJpbmcoMCwgYS5sZW5ndGggLSBpKSwgYi5zdWJzdHJpbmcoMCwgYi5sZW5ndGggLSBpKV07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzaG9ydGVuKFxyXG4gIHN0cjogc3RyaW5nLFxyXG4gIG1heExlbmd0aDogbnVtYmVyLFxyXG4gIHN1ZmZpeD86IHN0cmluZyxcclxuKTogc3RyaW5nIHtcclxuICByZXR1cm4gc3RyLmxlbmd0aCA8IG1heExlbmd0aFxyXG4gICAgPyBzdHJcclxuICAgIDogc3RyLnNsaWNlKDAsIG1heExlbmd0aCkgKyAoc3VmZml4IHx8ICcnKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIExpa2UgU3RyaW5nLnNwbGl0LCBidXQgb25seSBzcGxpdHMgb25jZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzcGxpdE9uY2Uoc3RyOiBzdHJpbmcsIHNlcGFyYXRvcjogc3RyaW5nKTogW3N0cmluZywgP3N0cmluZ10ge1xyXG4gIGNvbnN0IGluZGV4ID0gc3RyLmluZGV4T2Yoc2VwYXJhdG9yKTtcclxuICByZXR1cm4gaW5kZXggPT09IC0xXHJcbiAgICA/IFtzdHIsIG51bGxdXHJcbiAgICA6IFtzdHIuc2xpY2UoMCwgaW5kZXgpLCBzdHIuc2xpY2UoaW5kZXggKyBzZXBhcmF0b3IubGVuZ3RoKV07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbmRlbnRzIGVhY2ggbGluZSBieSB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBjaGFyYWN0ZXJzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGluZGVudChcclxuICBzdHI6IHN0cmluZyxcclxuICBsZXZlbDogbnVtYmVyID0gMixcclxuICBjaGFyOiBzdHJpbmcgPSAnICcsXHJcbik6IHN0cmluZyB7XHJcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eKFteXFxuXSkvZ20sIGNoYXIucmVwZWF0KGxldmVsKSArICckMScpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcGx1cmFsaXplKG5vdW46IHN0cmluZywgY291bnQ6IG51bWJlcikge1xyXG4gIHJldHVybiBjb3VudCA9PT0gMSA/IG5vdW4gOiBub3VuICsgJ3MnO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHI6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgcmV0dXJuIHN0ci5sZW5ndGggPT09IDBcclxuICAgID8gc3RyXHJcbiAgICA6IHN0clxyXG4gICAgICAgIC5jaGFyQXQoMClcclxuICAgICAgICAudG9VcHBlckNhc2UoKVxyXG4gICAgICAgIC5jb25jYXQoc3RyLnNsaWNlKDEpKTtcclxufVxyXG5cclxudHlwZSBNYXRjaFJhbmdlID0gWy8qIHN0YXJ0ICovIG51bWJlciwgLyogZW5kICovIG51bWJlcl07XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIGxpc3Qgb2YgcmFuZ2VzIHdoZXJlIG5lZWRsZSBvY2N1cnMgaW4gaGF5c3RhY2suXHJcbiAqIFRoaXMgd2lsbCAqbm90KiByZXR1cm4gb3ZlcmxhcHBpbmcgbWF0Y2hlczsgaS5lLiB0aGUgcmV0dXJuZWQgbGlzdCB3aWxsIGJlIGRpc2pvaW50LlxyXG4gKiBUaGlzIG1ha2VzIGl0IGVhc2llciB0byB1c2UgZm9yIGUuZy4gaGlnaGxpZ2h0aW5nIG1hdGNoZXMgaW4gYSBVSS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXRjaFJhbmdlcyhcclxuICBoYXlzdGFjazogc3RyaW5nLFxyXG4gIG5lZWRsZTogc3RyaW5nLFxyXG4pOiBBcnJheTxNYXRjaFJhbmdlPiB7XHJcbiAgaWYgKG5lZWRsZSA9PT0gJycpIHtcclxuICAgIC8vIE5vdCByZWFsbHkgYSB2YWxpZCB1c2UuXHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG5cclxuICBjb25zdCByYW5nZXMgPSBbXTtcclxuICBsZXQgbWF0Y2hJbmRleCA9IDA7XHJcbiAgd2hpbGUgKChtYXRjaEluZGV4ID0gaGF5c3RhY2suaW5kZXhPZihuZWVkbGUsIG1hdGNoSW5kZXgpKSAhPT0gLTEpIHtcclxuICAgIGNvbnN0IHByZXZSYW5nZSA9IHJhbmdlc1tyYW5nZXMubGVuZ3RoIC0gMV07XHJcbiAgICBpZiAocHJldlJhbmdlICE9IG51bGwgJiYgcHJldlJhbmdlWzFdID09PSBtYXRjaEluZGV4KSB7XHJcbiAgICAgIHByZXZSYW5nZVsxXSArPSBuZWVkbGUubGVuZ3RoO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmFuZ2VzLnB1c2goW21hdGNoSW5kZXgsIG1hdGNoSW5kZXggKyBuZWVkbGUubGVuZ3RoXSk7XHJcbiAgICB9XHJcbiAgICBtYXRjaEluZGV4ICs9IG5lZWRsZS5sZW5ndGg7XHJcbiAgfVxyXG4gIHJldHVybiByYW5nZXM7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVNYXJrZG93bihtYXJrZG93bjogc3RyaW5nKTogc3RyaW5nIHtcclxuICAvLyBXaGljaCBjaGFyYWN0ZXJzIGNhbiBiZSBiYWNrc2xhc2gtZXNjYXBlZD9cclxuICAvLyBtYXJrZG93bjogICAhICMgICAgKCkqKyAtLiAgICAgICAgW1xcXSBfYHsgfSAgIGh0dHBzOi8vZGFyaW5nZmlyZWJhbGwubmV0L3Byb2plY3RzL21hcmtkb3duL3N5bnRheCNiYWNrc2xhc2hcclxuICAvLyBjb21tb25NYXJrOiAhXCIjJCUmJygpKissLS4vOjs8PT4/QFtcXF1eX2B7fH1+ICBodHRwczovL3NwZWMuY29tbW9ubWFyay5vcmcvMC4yOC8jYmFja3NsYXNoLWVzY2FwZXNcclxuICAvLyBXZSdsbCBvbmx5IGJhY2tzbGFzaC1lc2NhcGUgdGhlIGxvd2VzdCBjb21tb24gZGVub21pbmF0b3IuXHJcbiAgY29uc3Qgc2xhc2hFc2NhcGVkID0gbWFya2Rvd24ucmVwbGFjZSgvWyMhKCkqK1xcLS5bXFxcXFxcXV9ge31dL2csICdcXFxcJCYnKTtcclxuICAvLyBBbmQgSFRNTCB0YWdzIG5lZWQgdG8gYmUgJmx0OyAmZ3Q7IGVzY2FwZWQuXHJcbiAgcmV0dXJuIHNsYXNoRXNjYXBlZC5yZXBsYWNlKC88L2csICcmbHQ7JykucmVwbGFjZSgvPi9nLCAnJmd0OycpO1xyXG59XHJcblxyXG4vLyBPcmlnaW5hbGx5IGNvcGllZCBmcm9tOlxyXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM4MDk0MDEvd2hhdC1pcy1hLWdvb2QtcmVndWxhci1leHByZXNzaW9uLXRvLW1hdGNoLWEtdXJsXHJcbi8vIEJ1dCBhZG9wdGVkIHRvIG1hdGNoIGB3d3cuYCB1cmxzIGFzIHdlbGwgYXMgYGh0dHBzP2AgdXJsc1xyXG4vLyBhbmQgYCFgIGFzIGFjY2VwdGFibGUgdXJsIHBpZWNlLlxyXG4vLyBUaGVuIG9wdGltaXplZCB3aXRoIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL3JlZ2V4cC10cmVlLlxyXG4vLyBBZGRlZCBhIHNpbmdsZSBtYXRjaGluZyBncm91cCBmb3IgdXNlIHdpdGggU3RyaW5nLnNwbGl0LlxyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxyXG5leHBvcnQgY29uc3QgVVJMX1JFR0VYID0gLyhodHRwcz86XFwvXFwvKD86d3d3XFwuKT9bLVxcd0A6JS4rfiM9XXsyLDI1Nn1cXC5bYS16XXsyLDZ9XFxiWy1cXHdAOiUrLn4jPyYvPSFdKnx3d3dcXC5bLVxcd0A6JS4rfiM9XXsyLDI1Nn1cXC5bYS16XXsyLDZ9XFxiWy1cXHdAOiUrLn4jPyYvPSFdKikvO1xyXG5cclxuZXhwb3J0IGNvbnN0IEVMTElQU0lTX0NIQVIgPSAnXFx1MjAyNic7XHJcbmV4cG9ydCBjb25zdCBaRVJPX1dJRFRIX1NQQUNFID0gJ1xcdTIwMEInO1xyXG4iXX0=