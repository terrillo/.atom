"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.expectAsyncFailure = expectAsyncFailure;
exports.clearRequireCache = clearRequireCache;
exports.uncachedRequire = uncachedRequire;
exports.spyOnGetterValue = spyOnGetterValue;
exports.arePropertiesEqual = arePropertiesEqual;
exports.expectObservableToStartWith = expectObservableToStartWith;
exports.generateFixture = generateFixture;
exports.writeCoverage = writeCoverage;

var _assert = _interopRequireDefault(require("assert"));

var _fs = _interopRequireDefault(require("fs"));

var _temp = _interopRequireDefault(require("temp"));

var _uuid = _interopRequireDefault(require("uuid"));

var _fsPromise = _interopRequireDefault(require("./fsPromise"));

var _nuclideUri = _interopRequireDefault(require("./nuclideUri"));

var _promise = require("./promise");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */
(0, _assert.default)(typeof atom !== 'undefined' && atom.inSpecMode() || process.env.NODE_ENV === 'test', 'Test helpers should only be used in spec mode');
/**
 * Verifies that a Promise fails with an Error with specific expectations. When
 * running a test where a Promise is expected to fail, it is important to verify
 * that it failed in the expected way to avoid false positives in test results.
 *
 * This function should be used with `await` inside `waitsForPromise()`.
 *
 * @param promise will be awaited. It is expected to reject. If it does not
 *     reject, then this function will return a rejected Promise.
 * @param verify should confirm expectations about the Error produced by the
 *     rejection of `promise`. If these expectations are not met, then
 *     `verify()` must throw an exception.
 */

async function expectAsyncFailure(promise, verify) {
  try {
    await promise;
    return Promise.reject(new Error('Promise should have failed, but did not.'));
  } catch (e) {
    verify(e);
  }
}
/**
 * This is useful for mocking a module that the module under test requires.
 * After setting up the mocks, you must invalidate the require cache and then
 * re-require the module under test so that it picks up the mocked
 * dependencies.
 *
 * The require parameter is needed because require is bound differently in each
 * file, and we need to execute this in the caller's context.
 */


function clearRequireCache(require, module) {
  delete require.cache[require.resolve(module)];
}

function uncachedRequire(require, module) {
  clearRequireCache(require, module); // $FlowIgnore

  return require(module);
}
/**
 * Jasmine has trouble spying on properties supplied by getters, so to make it
 * work we have to get the value, delete the getter, and set the value as a
 * property.
 *
 * This makes two assumptions:
 * - The getter is idempotent (otherwise, callers in other tests might be
 *   surprised when the value here is returned)
 * - The getter returns a function (otherwise, it doesn't make sense to spy on
 *   it)
 */


function spyOnGetterValue(object, f) {
  const value = object[f];
  delete object[f];
  object[f] = value;
  return spyOn(object, f);
}
/**
 * Checks if the two objects have equal properties. This considers a property
 * set to undefined to be equivalent to a property that was not set at all.
 */


function arePropertiesEqual(obj1, obj2) {
  const allProps = new Set();

  function addAllProps(obj) {
    for (const prop of Object.keys(obj)) {
      allProps.add(prop);
    }
  }

  [obj1, obj2].forEach(addAllProps);

  for (const prop of allProps) {
    if (obj1[prop] !== obj2[prop]) {
      return false;
    }
  }

  return true;
}
/**
 * Warning: Callsites *must* await the resulting promise, or test failures may go unreported or
 * misattributed.
 */


async function expectObservableToStartWith(source, expected) {
  const actual = await source.take(expected.length).toArray().toPromise();
  expect(actual).toEqual(expected);
}
/**
 * Takes of Map of file/file-content pairs, and creates a temp dir that matches
 * the file structure of the Map. Example:
 *
 * generateFixture('myfixture', new Map([
 *   ['foo.js'],
 *   ['bar/baz.txt', 'some text'],
 * ]));
 *
 * Creates:
 *
 * /tmp/myfixture_1/foo.js (empty file)
 * /tmp/myfixture_1/bar/baz.txt (with 'some text')
 */


async function generateFixture(fixtureName, files) {
  _temp.default.track();

  const MAX_CONCURRENT_FILE_OPS = 100;
  const tempDir = await _fsPromise.default.tempdir(fixtureName);

  if (files == null) {
    return tempDir;
  } // Map -> Array with full paths


  const fileTuples = Array.from(files, tuple => {
    // It's our own array - it's ok to mutate it
    tuple[0] = _nuclideUri.default.join(tempDir, tuple[0]);
    return tuple;
  }); // Dedupe the dirs that we have to make.

  const dirsToMake = fileTuples.map(([filename]) => _nuclideUri.default.dirname(filename)).filter((dirname, i, arr) => arr.indexOf(dirname) === i);
  await (0, _promise.asyncLimit)(dirsToMake, MAX_CONCURRENT_FILE_OPS, dirname => _fsPromise.default.mkdirp(dirname));
  await (0, _promise.asyncLimit)(fileTuples, MAX_CONCURRENT_FILE_OPS, ([filename, contents]) => {
    // We can't use fsPromise/fs-plus because it does too much extra work.
    // They call `mkdirp` before `writeFile`. We know that the target dir
    // exists, so we can optimize by going straight to `fs`. When you're
    // making 10k files, this adds ~500ms.
    return new Promise((resolve, reject) => {
      _fs.default.writeFile(filename, contents || '', err => {
        if (err) {
          reject(err);
        } else {
          resolve();
        }
      });
    });
  });
  return tempDir;
}

function writeCoverage() {
  const {
    COVERAGE_DIR
  } = process.env;

  if (COVERAGE_DIR != null) {
    const coverage = global.__coverage__;

    if (coverage != null) {
      _fs.default.writeFileSync(_nuclideUri.default.join(COVERAGE_DIR, _uuid.default.v4() + '.json'), JSON.stringify(coverage));
    }
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zL3Rlc3QtaGVscGVycy5qcyJdLCJuYW1lcyI6WyJhdG9tIiwiaW5TcGVjTW9kZSIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImV4cGVjdEFzeW5jRmFpbHVyZSIsInByb21pc2UiLCJ2ZXJpZnkiLCJQcm9taXNlIiwicmVqZWN0IiwiRXJyb3IiLCJlIiwiY2xlYXJSZXF1aXJlQ2FjaGUiLCJyZXF1aXJlIiwibW9kdWxlIiwiY2FjaGUiLCJyZXNvbHZlIiwidW5jYWNoZWRSZXF1aXJlIiwic3B5T25HZXR0ZXJWYWx1ZSIsIm9iamVjdCIsImYiLCJ2YWx1ZSIsInNweU9uIiwiYXJlUHJvcGVydGllc0VxdWFsIiwib2JqMSIsIm9iajIiLCJhbGxQcm9wcyIsIlNldCIsImFkZEFsbFByb3BzIiwib2JqIiwicHJvcCIsIk9iamVjdCIsImtleXMiLCJhZGQiLCJmb3JFYWNoIiwiZXhwZWN0T2JzZXJ2YWJsZVRvU3RhcnRXaXRoIiwic291cmNlIiwiZXhwZWN0ZWQiLCJhY3R1YWwiLCJ0YWtlIiwibGVuZ3RoIiwidG9BcnJheSIsInRvUHJvbWlzZSIsImV4cGVjdCIsInRvRXF1YWwiLCJnZW5lcmF0ZUZpeHR1cmUiLCJmaXh0dXJlTmFtZSIsImZpbGVzIiwidGVtcCIsInRyYWNrIiwiTUFYX0NPTkNVUlJFTlRfRklMRV9PUFMiLCJ0ZW1wRGlyIiwiZnNQcm9taXNlIiwidGVtcGRpciIsImZpbGVUdXBsZXMiLCJBcnJheSIsImZyb20iLCJ0dXBsZSIsIm51Y2xpZGVVcmkiLCJqb2luIiwiZGlyc1RvTWFrZSIsIm1hcCIsImZpbGVuYW1lIiwiZGlybmFtZSIsImZpbHRlciIsImkiLCJhcnIiLCJpbmRleE9mIiwibWtkaXJwIiwiY29udGVudHMiLCJmcyIsIndyaXRlRmlsZSIsImVyciIsIndyaXRlQ292ZXJhZ2UiLCJDT1ZFUkFHRV9ESVIiLCJjb3ZlcmFnZSIsImdsb2JhbCIsIl9fY292ZXJhZ2VfXyIsIndy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R0FBRCxDQUFOO0FBQ0QsU0FGRCxNQUVPO0FBQ0x4RCxVQUFBQSxPQUFPO0FBQ1I7QUFDRixPQU5EO0FBT0QsS0FSTSxDQUFQO0FBU0QsR0FqQkcsQ0FBTjtBQW9CQSxTQUFPbUMsT0FBUDtBQUNEOztBQUVNLFNBQVNzQixhQUFULEdBQStCO0FBQ3BDLFFBQU07QUFBQ0MsSUFBQUE7QUFBRCxNQUFpQnhFLE9BQU8sQ0FBQ0MsR0FBL0I7O0FBQ0EsTUFBSXVFLFlBQVksSUFBSSxJQUFwQixFQUEwQjtBQUN4QixVQUFNQyxRQUFRLEdBQUdDLE1BQU0sQ0FBQ0MsWUFBeEI7O0FBQ0EsUUFBSUYsUUFBUSxJQUFJLElBQWhCLEVBQXNCO0FBQ3BCTCxrQkFBR1EsYUFBSCxDQUNFcEIsb0JBQVdDLElBQVgsQ0FBZ0JlLFlBQWhCLEVBQThCSyxjQUFLQyxFQUFMLEtBQVksT0FBMUMsQ0FERixFQUVFQyxJQUFJLENBQUNDLFNBQUwsQ0FBZVAsUUFBZixDQUZGO0FBSUQ7QUFDRjtBQUNGIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBAZmxvd1xyXG4gKiBAZm9ybWF0XHJcbiAqL1xyXG5cclxuaW1wb3J0IHR5cGUge09ic2VydmFibGV9IGZyb20gJ3J4anMtY29tcGF0L2J1bmRsZXMvcnhqcy1jb21wYXQudW1kLm1pbi5qcyc7XHJcblxyXG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2Fzc2VydCc7XHJcbmltcG9ydCBmcyBmcm9tICdmcyc7XHJcbmltcG9ydCB0ZW1wIGZyb20gJ3RlbXAnO1xyXG5pbXBvcnQgdXVpZCBmcm9tICd1dWlkJztcclxuaW1wb3J0IGZzUHJvbWlzZSBmcm9tICcuL2ZzUHJvbWlzZSc7XHJcbmltcG9ydCBudWNsaWRlVXJpIGZyb20gJy4vbnVjbGlkZVVyaSc7XHJcbmltcG9ydCB7YXN5bmNMaW1pdH0gZnJvbSAnLi9wcm9taXNlJztcclxuXHJcbmludmFyaWFudChcclxuICAodHlwZW9mIGF0b20gIT09ICd1bmRlZmluZWQnICYmIGF0b20uaW5TcGVjTW9kZSgpKSB8fFxyXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICd0ZXN0JyxcclxuICAnVGVzdCBoZWxwZXJzIHNob3VsZCBvbmx5IGJlIHVzZWQgaW4gc3BlYyBtb2RlJyxcclxuKTtcclxuXHJcbi8qKlxyXG4gKiBWZXJpZmllcyB0aGF0IGEgUHJvbWlzZSBmYWlscyB3aXRoIGFuIEVycm9yIHdpdGggc3BlY2lmaWMgZXhwZWN0YXRpb25zLiBXaGVuXHJcbiAqIHJ1bm5pbmcgYSB0ZXN0IHdoZXJlIGEgUHJvbWlzZSBpcyBleHBlY3RlZCB0byBmYWlsLCBpdCBpcyBpbXBvcnRhbnQgdG8gdmVyaWZ5XHJcbiAqIHRoYXQgaXQgZmFpbGVkIGluIHRoZSBleHBlY3RlZCB3YXkgdG8gYXZvaWQgZmFsc2UgcG9zaXRpdmVzIGluIHRlc3QgcmVzdWx0cy5cclxuICpcclxuICogVGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgdXNlZCB3aXRoIGBhd2FpdGAgaW5zaWRlIGB3YWl0c0ZvclByb21pc2UoKWAuXHJcbiAqXHJcbiAqIEBwYXJhbSBwcm9taXNlIHdpbGwgYmUgYXdhaXRlZC4gSXQgaXMgZXhwZWN0ZWQgdG8gcmVqZWN0LiBJZiBpdCBkb2VzIG5vdFxyXG4gKiAgICAgcmVqZWN0LCB0aGVuIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gYSByZWplY3RlZCBQcm9taXNlLlxyXG4gKiBAcGFyYW0gdmVyaWZ5IHNob3VsZCBjb25maXJtIGV4cGVjdGF0aW9ucyBhYm91dCB0aGUgRXJyb3IgcHJvZHVjZWQgYnkgdGhlXHJcbiAqICAgICByZWplY3Rpb24gb2YgYHByb21pc2VgLiBJZiB0aGVzZSBleHBlY3RhdGlvbnMgYXJlIG5vdCBtZXQsIHRoZW5cclxuICogICAgIGB2ZXJpZnkoKWAgbXVzdCB0aHJvdyBhbiBleGNlcHRpb24uXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXhwZWN0QXN5bmNGYWlsdXJlKFxyXG4gIHByb21pc2U6IFByb21pc2U8YW55PixcclxuICB2ZXJpZnk6IChlcnJvcjogRXJyb3IpID0+IHZvaWQsXHJcbik6IFByb21pc2U8YW55PiB7XHJcbiAgdHJ5IHtcclxuICAgIGF3YWl0IHByb21pc2U7XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXHJcbiAgICAgIG5ldyBFcnJvcignUHJvbWlzZSBzaG91bGQgaGF2ZSBmYWlsZWQsIGJ1dCBkaWQgbm90LicpLFxyXG4gICAgKTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICB2ZXJpZnkoZSk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogVGhpcyBpcyB1c2VmdWwgZm9yIG1vY2tpbmcgYSBtb2R1bGUgdGhhdCB0aGUgbW9kdWxlIHVuZGVyIHRlc3QgcmVxdWlyZXMuXHJcbiAqIEFmdGVyIHNldHRpbmcgdXAgdGhlIG1vY2tzLCB5b3UgbXVzdCBpbnZhbGlkYXRlIHRoZSByZXF1aXJlIGNhY2hlIGFuZCB0aGVuXHJcbiAqIHJlLXJlcXVpcmUgdGhlIG1vZHVsZSB1bmRlciB0ZXN0IHNvIHRoYXQgaXQgcGlja3MgdXAgdGhlIG1vY2tlZFxyXG4gKiBkZXBlbmRlbmNpZXMuXHJcbiAqXHJcbiAqIFRoZSByZXF1aXJlIHBhcmFtZXRlciBpcyBuZWVkZWQgYmVjYXVzZSByZXF1aXJlIGlzIGJvdW5kIGRpZmZlcmVudGx5IGluIGVhY2hcclxuICogZmlsZSwgYW5kIHdlIG5lZWQgdG8gZXhlY3V0ZSB0aGlzIGluIHRoZSBjYWxsZXIncyBjb250ZXh0LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyUmVxdWlyZUNhY2hlKHJlcXVpcmU6IE9iamVjdCwgbW9kdWxlOiBzdHJpbmcpOiB2b2lkIHtcclxuICBkZWxldGUgcmVxdWlyZS5jYWNoZVtyZXF1aXJlLnJlc29sdmUobW9kdWxlKV07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1bmNhY2hlZFJlcXVpcmUocmVxdWlyZTogT2JqZWN0LCBtb2R1bGU6IHN0cmluZyk6IG1peGVkIHtcclxuICBjbGVhclJlcXVpcmVDYWNoZShyZXF1aXJlLCBtb2R1bGUpO1xyXG4gIC8vICRGbG93SWdub3JlXHJcbiAgcmV0dXJuIHJlcXVpcmUobW9kdWxlKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEphc21pbmUgaGFzIHRyb3VibGUgc3B5aW5nIG9uIHByb3BlcnRpZXMgc3VwcGxpZWQgYnkgZ2V0dGVycywgc28gdG8gbWFrZSBpdFxyXG4gKiB3b3JrIHdlIGhhdmUgdG8gZ2V0IHRoZSB2YWx1ZSwgZGVsZXRlIHRoZSBnZXR0ZXIsIGFuZCBzZXQgdGhlIHZhbHVlIGFzIGFcclxuICogcHJvcGVydHkuXHJcbiAqXHJcbiAqIFRoaXMgbWFrZXMgdHdvIGFzc3VtcHRpb25zOlxyXG4gKiAtIFRoZSBnZXR0ZXIgaXMgaWRlbXBvdGVudCAob3RoZXJ3aXNlLCBjYWxsZXJzIGluIG90aGVyIHRlc3RzIG1pZ2h0IGJlXHJcbiAqICAgc3VycHJpc2VkIHdoZW4gdGhlIHZhbHVlIGhlcmUgaXMgcmV0dXJuZWQpXHJcbiAqIC0gVGhlIGdldHRlciByZXR1cm5zIGEgZnVuY3Rpb24gKG90aGVyd2lzZSwgaXQgZG9lc24ndCBtYWtlIHNlbnNlIHRvIHNweSBvblxyXG4gKiAgIGl0KVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNweU9uR2V0dGVyVmFsdWUob2JqZWN0OiBPYmplY3QsIGY6IHN0cmluZyk6IEphc21pbmVTcHkge1xyXG4gIGNvbnN0IHZhbHVlID0gb2JqZWN0W2ZdO1xyXG4gIGRlbGV0ZSBvYmplY3RbZl07XHJcbiAgb2JqZWN0W2ZdID0gdmFsdWU7XHJcbiAgcmV0dXJuIHNweU9uKG9iamVjdCwgZik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgdGhlIHR3byBvYmplY3RzIGhhdmUgZXF1YWwgcHJvcGVydGllcy4gVGhpcyBjb25zaWRlcnMgYSBwcm9wZXJ0eVxyXG4gKiBzZXQgdG8gdW5kZWZpbmVkIHRvIGJlIGVxdWl2YWxlbnQgdG8gYSBwcm9wZXJ0eSB0aGF0IHdhcyBub3Qgc2V0IGF0IGFsbC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhcmVQcm9wZXJ0aWVzRXF1YWwob2JqMTogT2JqZWN0LCBvYmoyOiBPYmplY3QpOiBib29sZWFuIHtcclxuICBjb25zdCBhbGxQcm9wcyA9IG5ldyBTZXQoKTtcclxuICBmdW5jdGlvbiBhZGRBbGxQcm9wcyhvYmopIHtcclxuICAgIGZvciAoY29uc3QgcHJvcCBvZiBPYmplY3Qua2V5cyhvYmopKSB7XHJcbiAgICAgIGFsbFByb3BzLmFkZChwcm9wKTtcclxuICAgIH1cclxuICB9XHJcbiAgW29iajEsIG9iajJdLmZvckVhY2goYWRkQWxsUHJvcHMpO1xyXG4gIGZvciAoY29uc3QgcHJvcCBvZiBhbGxQcm9wcykge1xyXG4gICAgaWYgKG9iajFbcHJvcF0gIT09IG9iajJbcHJvcF0pIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFdhcm5pbmc6IENhbGxzaXRlcyAqbXVzdCogYXdhaXQgdGhlIHJlc3VsdGluZyBwcm9taXNlLCBvciB0ZXN0IGZhaWx1cmVzIG1heSBnbyB1bnJlcG9ydGVkIG9yXHJcbiAqIG1pc2F0dHJpYnV0ZWQuXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXhwZWN0T2JzZXJ2YWJsZVRvU3RhcnRXaXRoPFQ+KFxyXG4gIHNvdXJjZTogT2JzZXJ2YWJsZTxUPixcclxuICBleHBlY3RlZDogQXJyYXk8VD4sXHJcbik6IFByb21pc2U8dm9pZD4ge1xyXG4gIGNvbnN0IGFjdHVhbDogQXJyYXk8VD4gPSBhd2FpdCBzb3VyY2VcclxuICAgIC50YWtlKGV4cGVjdGVkLmxlbmd0aClcclxuICAgIC50b0FycmF5KClcclxuICAgIC50b1Byb21pc2UoKTtcclxuICBleHBlY3QoYWN0dWFsKS50b0VxdWFsKGV4cGVjdGVkKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRha2VzIG9mIE1hcCBvZiBmaWxlL2ZpbGUtY29udGVudCBwYWlycywgYW5kIGNyZWF0ZXMgYSB0ZW1wIGRpciB0aGF0IG1hdGNoZXNcclxuICogdGhlIGZpbGUgc3RydWN0dXJlIG9mIHRoZSBNYXAuIEV4YW1wbGU6XHJcbiAqXHJcbiAqIGdlbmVyYXRlRml4dHVyZSgnbXlmaXh0dXJlJywgbmV3IE1hcChbXHJcbiAqICAgWydmb28uanMnXSxcclxuICogICBbJ2Jhci9iYXoudHh0JywgJ3NvbWUgdGV4dCddLFxyXG4gKiBdKSk7XHJcbiAqXHJcbiAqIENyZWF0ZXM6XHJcbiAqXHJcbiAqIC90bXAvbXlmaXh0dXJlXzEvZm9vLmpzIChlbXB0eSBmaWxlKVxyXG4gKiAvdG1wL215Zml4dHVyZV8xL2Jhci9iYXoudHh0ICh3aXRoICdzb21lIHRleHQnKVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlRml4dHVyZShcclxuICBmaXh0dXJlTmFtZTogc3RyaW5nLFxyXG4gIGZpbGVzOiA/TWFwPHN0cmluZywgP3N0cmluZz4sXHJcbik6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgdGVtcC50cmFjaygpO1xyXG5cclxuICBjb25zdCBNQVhfQ09OQ1VSUkVOVF9GSUxFX09QUyA9IDEwMDtcclxuICBjb25zdCB0ZW1wRGlyID0gYXdhaXQgZnNQcm9taXNlLnRlbXBkaXIoZml4dHVyZU5hbWUpO1xyXG5cclxuICBpZiAoZmlsZXMgPT0gbnVsbCkge1xyXG4gICAgcmV0dXJuIHRlbXBEaXI7XHJcbiAgfVxyXG5cclxuICAvLyBNYXAgLT4gQXJyYXkgd2l0aCBmdWxsIHBhdGhzXHJcbiAgY29uc3QgZmlsZVR1cGxlcyA9IEFycmF5LmZyb20oZmlsZXMsIHR1cGxlID0+IHtcclxuICAgIC8vIEl0J3Mgb3VyIG93biBhcnJheSAtIGl0J3Mgb2sgdG8gbXV0YXRlIGl0XHJcbiAgICB0dXBsZVswXSA9IG51Y2xpZGVVcmkuam9pbih0ZW1wRGlyLCB0dXBsZVswXSk7XHJcbiAgICByZXR1cm4gdHVwbGU7XHJcbiAgfSk7XHJcblxyXG4gIC8vIERlZHVwZSB0aGUgZGlycyB0aGF0IHdlIGhhdmUgdG8gbWFrZS5cclxuICBjb25zdCBkaXJzVG9NYWtlID0gZmlsZVR1cGxlc1xyXG4gICAgLm1hcCgoW2ZpbGVuYW1lXSkgPT4gbnVjbGlkZVVyaS5kaXJuYW1lKGZpbGVuYW1lKSlcclxuICAgIC5maWx0ZXIoKGRpcm5hbWUsIGksIGFycikgPT4gYXJyLmluZGV4T2YoZGlybmFtZSkgPT09IGkpO1xyXG5cclxuICBhd2FpdCBhc3luY0xpbWl0KGRpcnNUb01ha2UsIE1BWF9DT05DVVJSRU5UX0ZJTEVfT1BTLCBkaXJuYW1lID0+XHJcbiAgICBmc1Byb21pc2UubWtkaXJwKGRpcm5hbWUpLFxyXG4gICk7XHJcblxyXG4gIGF3YWl0IGFzeW5jTGltaXQoXHJcbiAgICBmaWxlVHVwbGVzLFxyXG4gICAgTUFYX0NPTkNVUlJFTlRfRklMRV9PUFMsXHJcbiAgICAoW2ZpbGVuYW1lLCBjb250ZW50c10pID0+IHtcclxuICAgICAgLy8gV2UgY2FuJ3QgdXNlIGZzUHJvbWlzZS9mcy1wbHVzIGJlY2F1c2UgaXQgZG9lcyB0b28gbXVjaCBleHRyYSB3b3JrLlxyXG4gICAgICAvLyBUaGV5IGNhbGwgYG1rZGlycGAgYmVmb3JlIGB3cml0ZUZpbGVgLiBXZSBrbm93IHRoYXQgdGhlIHRhcmdldCBkaXJcclxuICAgICAgLy8gZXhpc3RzLCBzbyB3ZSBjYW4gb3B0aW1pemUgYnkgZ29pbmcgc3RyYWlnaHQgdG8gYGZzYC4gV2hlbiB5b3UncmVcclxuICAgICAgLy8gbWFraW5nIDEwayBmaWxlcywgdGhpcyBhZGRzIH41MDBtcy5cclxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICBmcy53cml0ZUZpbGUoZmlsZW5hbWUsIGNvbnRlbnRzIHx8ICcnLCBlcnIgPT4ge1xyXG4gICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICk7XHJcblxyXG4gIHJldHVybiB0ZW1wRGlyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gd3JpdGVDb3ZlcmFnZSgpOiB2b2lkIHtcclxuICBjb25zdCB7Q09WRVJBR0VfRElSfSA9IHByb2Nlc3MuZW52O1xyXG4gIGlmIChDT1ZFUkFHRV9ESVIgIT0gbnVsbCkge1xyXG4gICAgY29uc3QgY292ZXJhZ2UgPSBnbG9iYWwuX19jb3ZlcmFnZV9fO1xyXG4gICAgaWYgKGNvdmVyYWdlICE9IG51bGwpIHtcclxuICAgICAgZnMud3JpdGVGaWxlU3luYyhcclxuICAgICAgICBudWNsaWRlVXJpLmpvaW4oQ09WRVJBR0VfRElSLCB1dWlkLnY0KCkgKyAnLmpzb24nKSxcclxuICAgICAgICBKU09OLnN0cmluZ2lmeShjb3ZlcmFnZSksXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiJdfQ==