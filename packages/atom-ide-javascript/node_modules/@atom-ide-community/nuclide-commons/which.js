"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _os = _interopRequireDefault(require("os"));

var _nuclideUri = _interopRequireDefault(require("./nuclideUri"));

var _process = require("./process");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */

/**
 * Provides a cross-platform way to check whether a binary is available.
 *
 * We ran into problems with the npm `which` package (the nature of which I unfortunately don't
 * remember) so we can use this for now.
 */
function sanitizePathForWindows(path) {
  if (_nuclideUri.default.basename(path) === path) {
    // simple binary in $PATH like `flow`
    return path;
  } else {
    return `${_nuclideUri.default.dirname(path)}:${_nuclideUri.default.basename(path)}`;
  }
}

var which = async function which(path, options = {}) {
  const isWindows = process.platform === 'win32';
  const whichCommand = isWindows ? 'where' : 'which';
  const searchPath = isWindows ? sanitizePathForWindows(path) : path;

  try {
    const result = await (0, _process.runCommand)(whichCommand, [searchPath], options).toPromise();
    return result.split(_os.default.EOL)[0];
  } catch (e) {
    return null;
  }
};

exports.default = which;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zL3doaWNoLmpzIl0sIm5hbWVzIjpbInNhbml0aXplUGF0aEZvcldpbmRvd3MiLCJwYXRoIiwibnVjbGlkZVVyaSIsImJhc2VuYW1lIiwiZGlybmFtZSIsIndoaWNoIiwib3B0aW9ucyIsImlzV2luZG93cyIsInByb2Nlc3MiLCJwbGF0Zm9ybSIsIndoaWNoQ29tbWFuZCIsInNlYXJjaFBhdGgiLCJyZXN1bHQiLCJ0b1Byb21pc2UiLCJzcGxpdCIsIm9zIiwiRU9MIiwiZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQWNBOztBQUNBOztBQUNBOzs7O0FBaEJBOzs7Ozs7Ozs7Ozs7QUFrQkE7Ozs7OztBQU9BLFNBQVNBLHNCQUFULENBQWdDQyxJQUFoQyxFQUFzRDtBQUNwRCxNQUFJQyxvQkFBV0MsUUFBWCxDQUFvQkYsSUFBcEIsTUFBOEJBLElBQWxDLEVBQXdDO0FBQ3RDO0FBQ0EsV0FBT0EsSUFBUDtBQUNELEdBSEQsTUFHTztBQUNMLFdBQVEsR0FBRUMsb0JBQVdFLE9BQVgsQ0FBbUJILElBQW5CLENBQXlCLElBQUdDLG9CQUFXQyxRQUFYLENBQW9CRixJQUFwQixDQUEwQixFQUFoRTtBQUNEO0FBQ0Y7O0lBRThCSSxLLEdBQWYsZUFBZUEsS0FBZixDQUNkSixJQURjLEVBRWRLLE9BQStCLEdBQUcsRUFGcEIsRUFHSTtBQUNsQixRQUFNQyxTQUFTLEdBQUdDLE9BQU8sQ0FBQ0MsUUFBUixLQUFxQixPQUF2QztBQUNBLFFBQU1DLFlBQVksR0FBR0gsU0FBUyxHQUFHLE9BQUgsR0FBYSxPQUEzQztBQUNBLFFBQU1JLFVBQVUsR0FBR0osU0FBUyxHQUFHUCxzQkFBc0IsQ0FBQ0MsSUFBRCxDQUF6QixHQUFrQ0EsSUFBOUQ7O0FBQ0EsTUFBSTtBQUNGLFVBQU1XLE1BQU0sR0FBRyxNQUFNLHlCQUNuQkYsWUFEbUIsRUFFbkIsQ0FBQ0MsVUFBRCxDQUZtQixFQUduQkwsT0FIbUIsRUFJbkJPLFNBSm1CLEVBQXJCO0FBS0EsV0FBT0QsTUFBTSxDQUFDRSxLQUFQLENBQWFDLFlBQUdDLEdBQWhCLEVBQXFCLENBQXJCLENBQVA7QUFDRCxHQVBELENBT0UsT0FBT0MsQ0FBUCxFQUFVO0FBQ1YsV0FBTyxJQUFQO0FBQ0Q7QUFDRixDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBAZmxvdyBzdHJpY3QtbG9jYWxcclxuICogQGZvcm1hdFxyXG4gKi9cclxuXHJcbmltcG9ydCB0eXBlIHtPYnNlcnZlUHJvY2Vzc09wdGlvbnN9IGZyb20gJy4vcHJvY2Vzcyc7XHJcblxyXG5pbXBvcnQgb3MgZnJvbSAnb3MnO1xyXG5pbXBvcnQgbnVjbGlkZVVyaSBmcm9tICcuL251Y2xpZGVVcmknO1xyXG5pbXBvcnQge3J1bkNvbW1hbmR9IGZyb20gJy4vcHJvY2Vzcyc7XHJcblxyXG4vKipcclxuICogUHJvdmlkZXMgYSBjcm9zcy1wbGF0Zm9ybSB3YXkgdG8gY2hlY2sgd2hldGhlciBhIGJpbmFyeSBpcyBhdmFpbGFibGUuXHJcbiAqXHJcbiAqIFdlIHJhbiBpbnRvIHByb2JsZW1zIHdpdGggdGhlIG5wbSBgd2hpY2hgIHBhY2thZ2UgKHRoZSBuYXR1cmUgb2Ygd2hpY2ggSSB1bmZvcnR1bmF0ZWx5IGRvbid0XHJcbiAqIHJlbWVtYmVyKSBzbyB3ZSBjYW4gdXNlIHRoaXMgZm9yIG5vdy5cclxuICovXHJcblxyXG5mdW5jdGlvbiBzYW5pdGl6ZVBhdGhGb3JXaW5kb3dzKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgaWYgKG51Y2xpZGVVcmkuYmFzZW5hbWUocGF0aCkgPT09IHBhdGgpIHtcclxuICAgIC8vIHNpbXBsZSBiaW5hcnkgaW4gJFBBVEggbGlrZSBgZmxvd2BcclxuICAgIHJldHVybiBwYXRoO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gYCR7bnVjbGlkZVVyaS5kaXJuYW1lKHBhdGgpfToke251Y2xpZGVVcmkuYmFzZW5hbWUocGF0aCl9YDtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IChhc3luYyBmdW5jdGlvbiB3aGljaChcclxuICBwYXRoOiBzdHJpbmcsXHJcbiAgb3B0aW9ucz86IE9ic2VydmVQcm9jZXNzT3B0aW9ucyA9IHt9LFxyXG4pOiBQcm9taXNlPD9zdHJpbmc+IHtcclxuICBjb25zdCBpc1dpbmRvd3MgPSBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInO1xyXG4gIGNvbnN0IHdoaWNoQ29tbWFuZCA9IGlzV2luZG93cyA/ICd3aGVyZScgOiAnd2hpY2gnO1xyXG4gIGNvbnN0IHNlYXJjaFBhdGggPSBpc1dpbmRvd3MgPyBzYW5pdGl6ZVBhdGhGb3JXaW5kb3dzKHBhdGgpIDogcGF0aDtcclxuICB0cnkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcnVuQ29tbWFuZChcclxuICAgICAgd2hpY2hDb21tYW5kLFxyXG4gICAgICBbc2VhcmNoUGF0aF0sXHJcbiAgICAgIG9wdGlvbnMsXHJcbiAgICApLnRvUHJvbWlzZSgpO1xyXG4gICAgcmV0dXJuIHJlc3VsdC5zcGxpdChvcy5FT0wpWzBdO1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufSk7XHJcbiJdfQ==