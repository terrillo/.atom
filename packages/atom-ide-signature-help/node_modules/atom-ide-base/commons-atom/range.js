"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isPositionInRange = exports.matchRegexEndingAt = exports.wordAtPositionFromBuffer = exports.getWordFromCursorOrSelection = exports.getWordFromMouseEvent = exports.trimRange = exports.wordAtPosition = void 0;
const atom_1 = require("atom");
const assert_1 = __importDefault(require("assert"));
/**
 * Finds the word at the position. You can either provide a word regex yourself, or have Atom use the word regex in
 * force at the scopes at that position, in which case it uses the optional includeNonWordCharacters, default true. (I
 * know that's a weird default but it follows Atom's convention...)
 */
function wordAtPosition(editor, position, wordRegex) {
    let wordRegex_;
    if (wordRegex instanceof RegExp) {
        wordRegex_ = wordRegex;
    }
    else {
        // What is the word regex associated with the position? We'd like to use
        // Cursor.wordRegExp, except that function gets the regex associated
        // with the editor's current cursor while we want the regex associated with
        // the specific position. So we re-implement it ourselves...
        // @ts-ignore: https://github.com/atom/atom/blob/aa3c34bedb361e09a5068dce9620b460a20ca3fb/src/text-editor.js#L5032
        const nonWordChars = editor.getNonWordCharacters(position);
        const escaped = nonWordChars.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
        // We copied this escaping regex from Cursor.wordRegexp, rather than
        // using the library function 'escapeStringRegExp'. That's because the
        // library function doesn't escape the hyphen character and so is
        // unsuitable for use inside a range.
        let r = `^[\t ]*$|[^\\s${escaped}]+`;
        if (wordRegex == null || wordRegex.includeNonWordCharacters) {
            r += `|[${escaped}]+`;
        }
        wordRegex_ = new RegExp(r, "g");
    }
    return wordAtPositionFromBuffer(editor.getBuffer(), position, wordRegex_);
}
exports.wordAtPosition = wordAtPosition;
/**
 * Gets the trimmed range from a given range, i.e. moves the start and end points to the first and last non-whitespace
 * characters (or specified regex) within the range respectively.
 *
 * @param editor The editor containing the range
 * @param rangeToTrim The range to trim
 * @param stopRegex Stop trimming when the first match is found for this regex, defaults to first non-whitespace character
 * @returns Range the trimmed range
 */
function trimRange(editor, rangeToTrim, stopRegex = /\S/) {
    const buffer = editor.getBuffer();
    let { start, end } = rangeToTrim;
    buffer.scanInRange(stopRegex, rangeToTrim, ({ range, stop }) => {
        start = range.start;
        stop();
    });
    buffer.backwardsScanInRange(stopRegex, rangeToTrim, ({ range, stop }) => {
        end = range.end;
        stop();
    });
    return new atom_1.Range(start, end);
}
exports.trimRange = trimRange;
function getSingleWordAtPosition(editor, position) {
    const match = wordAtPosition(editor, position);
    // We should only receive a single identifier from a single point.
    if (match == null || match.wordMatch.length !== 1) {
        return null;
    }
    return match.wordMatch[0];
}
/**
 * Gets the word being right-clicked on in a MouseEvent. A good use case for this is performing an action on a word from
 * a context menu.
 *
 * @param editor The editor containing the word where the MouseEvent occurred from
 * @param event The MouseEvent containing the screen position of the click
 */
function getWordFromMouseEvent(editor, event) {
    // We can't immediately get the identifier right-clicked on from
    // the MouseEvent. Using its target element content would work in
    // some cases but wouldn't work if there was additional content
    // in the same element, such as in a comment.
    // @ts-ignore: https://github.com/atom/atom/blob/aa3c34bedb361e09a5068dce9620b460a20ca3fb/src/text-editor.js#L5075
    const component = editor.getElement().component;
    assert_1.default(component);
    // This solution doesn't feel ideal but it is the way hyperclick does it.
    const point = component.screenPositionForMouseEvent(event);
    return getSingleWordAtPosition(editor, point);
}
exports.getWordFromMouseEvent = getWordFromMouseEvent;
/**
 * Attempts to get a word from the last selection or cursor. A good use case for this is performing an action on an
 * 'active' word after a command is triggered via a keybinding.
 *
 * @param editor The editor containing the 'active' word when the keybinding is triggered
 */
function getWordFromCursorOrSelection(editor) {
    const selection = editor.getSelectedText();
    if (selection && selection.length > 0) {
        return selection;
    }
    // There was no selection so we can go ahead and try the cursor position.
    const point = editor.getCursorScreenPosition();
    return getSingleWordAtPosition(editor, point);
}
exports.getWordFromCursorOrSelection = getWordFromCursorOrSelection;
function wordAtPositionFromBuffer(buffer, position, wordRegex) {
    const { row, column } = position;
    const rowRange = buffer.rangeForRow(row);
    let matchData;
    // Extract the expression from the row text.
    buffer.scanInRange(wordRegex, rowRange, (data) => {
        const { range } = data;
        if (range.start.isLessThanOrEqual(position) && range.end.isGreaterThan(position)) {
            matchData = data;
        }
        // Stop the scan if the scanner has passed our position.
        if (range.end.column > column) {
            data.stop();
        }
    });
    // @ts-ignore (it is assigned above)
    if (matchData) {
        return {
            wordMatch: matchData.match,
            range: matchData.range,
        };
    }
    else {
        return null;
    }
}
exports.wordAtPositionFromBuffer = wordAtPositionFromBuffer;
// Matches a regex on the text of the line ending at endPosition.
// regex should end with a '$'.
// Useful for autocomplete.
function matchRegexEndingAt(buffer, endPosition, regex) {
    const line = buffer.getTextInRange([[endPosition.row, 0], endPosition]);
    const match = regex.exec(line);
    return match == null ? null : match[0];
}
exports.matchRegexEndingAt = matchRegexEndingAt;
function isPositionInRange(position, range) {
    return Array.isArray(range) ? range.some((r) => r.containsPoint(position)) : range.containsPoint(position);
}
exports.isPositionInRange = isPositionInRange;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmFuZ2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMtY29tbW9ucy1hdG9tL3JhbmdlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLCtCQUFnRjtBQUNoRixvREFBOEI7QUFFOUI7Ozs7R0FJRztBQUNILFNBQWdCLGNBQWMsQ0FDNUIsTUFBa0IsRUFDbEIsUUFBZSxFQUNmLFNBQTBEO0lBRTFELElBQUksVUFBVSxDQUFBO0lBQ2QsSUFBSSxTQUFTLFlBQVksTUFBTSxFQUFFO1FBQy9CLFVBQVUsR0FBRyxTQUFTLENBQUE7S0FDdkI7U0FBTTtRQUNMLHdFQUF3RTtRQUN4RSxvRUFBb0U7UUFDcEUsMkVBQTJFO1FBQzNFLDREQUE0RDtRQUM1RCxrSEFBa0g7UUFDbEgsTUFBTSxZQUFZLEdBQVcsTUFBTSxDQUFDLG9CQUFvQixDQUFDLFFBQVEsQ0FBQyxDQUFBO1FBQ2xFLE1BQU0sT0FBTyxHQUFHLFlBQVksQ0FBQyxPQUFPLENBQUMsdUJBQXVCLEVBQUUsTUFBTSxDQUFDLENBQUE7UUFDckUsb0VBQW9FO1FBQ3BFLHNFQUFzRTtRQUN0RSxpRUFBaUU7UUFDakUscUNBQXFDO1FBQ3JDLElBQUksQ0FBQyxHQUFHLGlCQUFpQixPQUFPLElBQUksQ0FBQTtRQUNwQyxJQUFJLFNBQVMsSUFBSSxJQUFJLElBQUksU0FBUyxDQUFDLHdCQUF3QixFQUFFO1lBQzNELENBQUMsSUFBSSxLQUFLLE9BQU8sSUFBSSxDQUFBO1NBQ3RCO1FBQ0QsVUFBVSxHQUFHLElBQUksTUFBTSxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQTtLQUNoQztJQUNELE9BQU8sd0JBQXdCLENBQUMsTUFBTSxDQUFDLFNBQVMsRUFBRSxFQUFFLFFBQVEsRUFBRSxVQUFVLENBQUMsQ0FBQTtBQUMzRSxDQUFDO0FBM0JELHdDQTJCQztBQUVEOzs7Ozs7OztHQVFHO0FBQ0gsU0FBZ0IsU0FBUyxDQUFDLE1BQWtCLEVBQUUsV0FBa0IsRUFBRSxZQUFvQixJ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QUMsUUFBUSxDQUFDLENBQUE7QUFDNUcsQ0FBQztBQUZELDhDQUVDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVGV4dEVkaXRvciwgVGV4dEVkaXRvckNvbXBvbmVudCwgVGV4dEJ1ZmZlciwgUmFuZ2UsIFBvaW50IH0gZnJvbSBcImF0b21cIlxuaW1wb3J0IGludmFyaWFudCBmcm9tIFwiYXNzZXJ0XCJcblxuLyoqXG4gKiBGaW5kcyB0aGUgd29yZCBhdCB0aGUgcG9zaXRpb24uIFlvdSBjYW4gZWl0aGVyIHByb3ZpZGUgYSB3b3JkIHJlZ2V4IHlvdXJzZWxmLCBvciBoYXZlIEF0b20gdXNlIHRoZSB3b3JkIHJlZ2V4IGluXG4gKiBmb3JjZSBhdCB0aGUgc2NvcGVzIGF0IHRoYXQgcG9zaXRpb24sIGluIHdoaWNoIGNhc2UgaXQgdXNlcyB0aGUgb3B0aW9uYWwgaW5jbHVkZU5vbldvcmRDaGFyYWN0ZXJzLCBkZWZhdWx0IHRydWUuIChJXG4gKiBrbm93IHRoYXQncyBhIHdlaXJkIGRlZmF1bHQgYnV0IGl0IGZvbGxvd3MgQXRvbSdzIGNvbnZlbnRpb24uLi4pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3b3JkQXRQb3NpdGlvbihcbiAgZWRpdG9yOiBUZXh0RWRpdG9yLFxuICBwb3NpdGlvbjogUG9pbnQsXG4gIHdvcmRSZWdleD86IFJlZ0V4cCB8IHsgaW5jbHVkZU5vbldvcmRDaGFyYWN0ZXJzOiBib29sZWFuIH1cbik6IHsgd29yZE1hdGNoOiBBcnJheTxzdHJpbmc+OyByYW5nZTogUmFuZ2UgfSB8IG51bGwge1xuICBsZXQgd29yZFJlZ2V4X1xuICBpZiAod29yZFJlZ2V4IGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgd29yZFJlZ2V4XyA9IHdvcmRSZWdleFxuICB9IGVsc2Uge1xuICAgIC8vIFdoYXQgaXMgdGhlIHdvcmQgcmVnZXggYXNzb2NpYXRlZCB3aXRoIHRoZSBwb3NpdGlvbj8gV2UnZCBsaWtlIHRvIHVzZVxuICAgIC8vIEN1cnNvci53b3JkUmVnRXhwLCBleGNlcHQgdGhhdCBmdW5jdGlvbiBnZXRzIHRoZSByZWdleCBhc3NvY2lhdGVkXG4gICAgLy8gd2l0aCB0aGUgZWRpdG9yJ3MgY3VycmVudCBjdXJzb3Igd2hpbGUgd2Ugd2FudCB0aGUgcmVnZXggYXNzb2NpYXRlZCB3aXRoXG4gICAgLy8gdGhlIHNwZWNpZmljIHBvc2l0aW9uLiBTbyB3ZSByZS1pbXBsZW1lbnQgaXQgb3Vyc2VsdmVzLi4uXG4gICAgLy8gQHRzLWlnbm9yZTogaHR0cHM6Ly9naXRodWIuY29tL2F0b20vYXRvbS9ibG9iL2FhM2MzNGJlZGIzNjFlMDlhNTA2OGRjZTk2MjBiNDYwYTIwY2EzZmIvc3JjL3RleHQtZWRpdG9yLmpzI0w1MDMyXG4gICAgY29uc3Qgbm9uV29yZENoYXJzOiBzdHJpbmcgPSBlZGl0b3IuZ2V0Tm9uV29yZENoYXJhY3RlcnMocG9zaXRpb24pXG4gICAgY29uc3QgZXNjYXBlZCA9IG5vbldvcmRDaGFycy5yZXBsYWNlKC9bLS9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCBcIlxcXFwkJlwiKVxuICAgIC8vIFdlIGNvcGllZCB0aGlzIGVzY2FwaW5nIHJlZ2V4IGZyb20gQ3Vyc29yLndvcmRSZWdleHAsIHJhdGhlciB0aGFuXG4gICAgLy8gdXNpbmcgdGhlIGxpYnJhcnkgZnVuY3Rpb24gJ2VzY2FwZVN0cmluZ1JlZ0V4cCcuIFRoYXQncyBiZWNhdXNlIHRoZVxuICAgIC8vIGxpYnJhcnkgZnVuY3Rpb24gZG9lc24ndCBlc2NhcGUgdGhlIGh5cGhlbiBjaGFyYWN0ZXIgYW5kIHNvIGlzXG4gICAgLy8gdW5zdWl0YWJsZSBmb3IgdXNlIGluc2lkZSBhIHJhbmdlLlxuICAgIGxldCByID0gYF5bXFx0IF0qJHxbXlxcXFxzJHtlc2NhcGVkfV0rYFxuICAgIGlmICh3b3JkUmVnZXggPT0gbnVsbCB8fCB3b3JkUmVnZXguaW5jbHVkZU5vbldvcmRDaGFyYWN0ZXJzKSB7XG4gICAgICByICs9IGB8WyR7ZXNjYXBlZH1dK2BcbiAgICB9XG4gICAgd29yZFJlZ2V4XyA9IG5ldyBSZWdFeHAociwgXCJnXCIpXG4gIH1cbiAgcmV0dXJuIHdvcmRBdFBvc2l0aW9uRnJvbUJ1ZmZlcihlZGl0b3IuZ2V0QnVmZmVyKCksIHBvc2l0aW9uLCB3b3JkUmVnZXhfKVxufVxuXG4vKipcbiAqIEdldHMgdGhlIHRyaW1tZWQgcmFuZ2UgZnJvbSBhIGdpdmVuIHJhbmdlLCBpLmUuIG1vdmVzIHRoZSBzdGFydCBhbmQgZW5kIHBvaW50cyB0byB0aGUgZmlyc3QgYW5kIGxhc3Qgbm9uLXdoaXRlc3BhY2VcbiAqIGNoYXJhY3RlcnMgKG9yIHNwZWNpZmllZCByZWdleCkgd2l0aGluIHRoZSByYW5nZSByZXNwZWN0aXZlbHkuXG4gKlxuICogQHBhcmFtIGVkaXRvciBUaGUgZWRpdG9yIGNvbnRhaW5pbmcgdGhlIHJhbmdlXG4gKiBAcGFyYW0gcmFuZ2VUb1RyaW0gVGhlIHJhbmdlIHRvIHRyaW1cbiAqIEBwYXJhbSBzdG9wUmVnZXggU3RvcCB0cmltbWluZyB3aGVuIHRoZSBmaXJzdCBtYXRjaCBpcyBmb3VuZCBmb3IgdGhpcyByZWdleCwgZGVmYXVsdHMgdG8gZmlyc3Qgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyXG4gKiBAcmV0dXJucyBSYW5nZSB0aGUgdHJpbW1lZCByYW5nZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJpbVJhbmdlKGVkaXRvcjogVGV4dEVkaXRvciwgcmFuZ2VUb1RyaW06IFJhbmdlLCBzdG9wUmVnZXg6IFJlZ0V4cCA9IC9cXFMvKTogUmFuZ2Uge1xuICBjb25zdCBidWZmZXIgPSBlZGl0b3IuZ2V0QnVmZmVyKClcbiAgbGV0IHsgc3RhcnQsIGVuZCB9ID0gcmFuZ2VUb1RyaW1cbiAgYnVmZmVyLnNjYW5JblJhbmdlKHN0b3BSZWdleCwgcmFuZ2VUb1RyaW0sICh7IHJhbmdlLCBzdG9wIH0pID0+IHtcbiAgICBzdGFydCA9IHJhbmdlLnN0YXJ0XG4gICAgc3RvcCgpXG4gIH0pXG4gIGJ1ZmZlci5iYWNrd2FyZHNTY2FuSW5SYW5nZShzdG9wUmVnZXgsIHJhbmdlVG9UcmltLCAoeyByYW5nZSwgc3RvcCB9KSA9PiB7XG4gICAgZW5kID0gcmFuZ2UuZW5kXG4gICAgc3RvcCgpXG4gIH0pXG4gIHJldHVybiBuZXcgUmFuZ2Uoc3RhcnQsIGVuZClcbn1cblxuZnVuY3Rpb24gZ2V0U2luZ2xlV29yZEF0UG9zaXRpb24oZWRpdG9yOiBUZXh0RWRpdG9yLCBwb3NpdGlvbjogUG9pbnQpOiBzdHJpbmcgfCBudWxsIHtcbiAgY29uc3QgbWF0Y2ggPSB3b3JkQXRQb3NpdGlvbihlZGl0b3IsIHBvc2l0aW9uKVxuICAvLyBXZSBzaG91bGQgb25seSByZWNlaXZlIGEgc2luZ2xlIGlkZW50aWZpZXIgZnJvbSBhIHNpbmdsZSBwb2ludC5cbiAgaWYgKG1hdGNoID09IG51bGwgfHwgbWF0Y2gud29yZE1hdGNoLmxlbmd0aCAhPT0gMSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICByZXR1cm4gbWF0Y2gud29yZE1hdGNoWzBdXG59XG5cbi8qKlxuICogR2V0cyB0aGUgd29yZCBiZWluZyByaWdodC1jbGlja2VkIG9uIGluIGEgTW91c2VFdmVudC4gQSBnb29kIHVzZSBjYXNlIGZvciB0aGlzIGlzIHBlcmZvcm1pbmcgYW4gYWN0aW9uIG9uIGEgd29yZCBmcm9tXG4gKiBhIGNvbnRleHQgbWVudS5cbiAqXG4gKiBAcGFyYW0gZWRpdG9yIFRoZSBlZGl0b3IgY29udGFpbmluZyB0aGUgd29yZCB3aGVyZSB0aGUgTW91c2VFdmVudCBvY2N1cnJlZCBmcm9tXG4gKiBAcGFyYW0gZXZlbnQgVGhlIE1vdXNlRXZlbnQgY29udGFpbmluZyB0aGUgc2NyZWVuIHBvc2l0aW9uIG9mIHRoZSBjbGlja1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0V29yZEZyb21Nb3VzZUV2ZW50KGVkaXRvcjogVGV4dEVkaXRvciwgZXZlbnQ6IE1vdXNlRXZlbnQpOiBzdHJpbmcgfCBudWxsIHtcbiAgLy8gV2UgY2FuJ3QgaW1tZWRpYXRlbHkgZ2V0IHRoZSBpZGVudGlmaWVyIHJpZ2h0LWNsaWNrZWQgb24gZnJvbVxuICAvLyB0aGUgTW91c2VFdmVudC4gVXNpbmcgaXRzIHRhcmdldCBlbGVtZW50IGNvbnRlbnQgd291bGQgd29yayBpblxuICAvLyBzb21lIGNhc2VzIGJ1dCB3b3VsZG4ndCB3b3JrIGlmIHRoZXJlIHdhcyBhZGRpdGlvbmFsIGNvbnRlbnRcbiAgLy8gaW4gdGhlIHNhbWUgZWxlbWVudCwgc3VjaCBhcyBpbiBhIGNvbW1lbnQuXG4gIC8vIEB0cy1pZ25vcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hdG9tL2F0b20vYmxvYi9hYTNjMzRiZWRiMzYxZTA5YTUwNjhkY2U5NjIwYjQ2MGEyMGNhM2ZiL3NyYy90ZXh0LWVkaXRvci5qcyNMNTA3NVxuICBjb25zdCBjb21wb25lbnQ6IFRleHRFZGl0b3JDb21wb25lbnQgPSBlZGl0b3IuZ2V0RWxlbWVudCgpLmNvbXBvbmVudFxuICBpbnZhcmlhbnQoY29tcG9uZW50KVxuICAvLyBUaGlzIHNvbHV0aW9uIGRvZXNuJ3QgZmVlbCBpZGVhbCBidXQgaXQgaXMgdGhlIHdheSBoeXBlcmNsaWNrIGRvZXMgaXQuXG4gIGNvbnN0IHBvaW50ID0gY29tcG9uZW50LnNjcmVlblBvc2l0aW9uRm9yTW91c2VFdmVudChldmVudClcbiAgcmV0dXJuIGdldFNpbmdsZVdvcmRBdFBvc2l0aW9uKGVkaXRvciwgcG9pbnQpXG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gZ2V0IGEgd29yZCBmcm9tIHRoZSBsYXN0IHNlbGVjdGlvbiBvciBjdXJzb3IuIEEgZ29vZCB1c2UgY2FzZSBmb3IgdGhpcyBpcyBwZXJmb3JtaW5nIGFuIGFjdGlvbiBvbiBhblxuICogJ2FjdGl2ZScgd29yZCBhZnRlciBhIGNvbW1hbmQgaXMgdHJpZ2dlcmVkIHZpYSBhIGtleWJpbmRpbmcuXG4gKlxuICogQHBhcmFtIGVkaXRvciBUaGUgZWRpdG9yIGNvbnRhaW5pbmcgdGhlICdhY3RpdmUnIHdvcmQgd2hlbiB0aGUga2V5YmluZGluZyBpcyB0cmlnZ2VyZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFdvcmRGcm9tQ3Vyc29yT3JTZWxlY3Rpb24oZWRpdG9yOiBUZXh0RWRpdG9yKTogc3RyaW5nIHwgbnVsbCB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3RlZFRleHQoKVxuICBpZiAoc2VsZWN0aW9uICYmIHNlbGVjdGlvbi5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHNlbGVjdGlvblxuICB9XG5cbiAgLy8gVGhlcmUgd2FzIG5vIHNlbGVjdGlvbiBzbyB3ZSBjYW4gZ28gYWhlYWQgYW5kIHRyeSB0aGUgY3Vyc29yIHBvc2l0aW9uLlxuICBjb25zdCBwb2ludCA9IGVkaXRvci5nZXRDdXJzb3JTY3JlZW5Qb3NpdGlvbigpXG4gIHJldHVybiBnZXRTaW5nbGVXb3JkQXRQb3NpdGlvbihlZGl0b3IsIHBvaW50KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gd29yZEF0UG9zaXRpb25Gcm9tQnVmZmVyKFxuICBidWZmZXI6IFRleHRCdWZmZXIsXG4gIHBvc2l0aW9uOiBQb2ludCxcbiAgd29yZFJlZ2V4OiBSZWdFeHBcbik6IHsgd29yZE1hdGNoOiBBcnJheTxzdHJpbmc+OyByYW5nZTogUmFuZ2UgfSB8IG51bGwge1xuICBjb25zdCB7IHJvdywgY29sdW1uIH0gPSBwb3NpdGlvblxuICBjb25zdCByb3dSYW5nZSA9IGJ1ZmZlci5yYW5nZUZvclJvdyhyb3cpXG4gIGxldCBtYXRjaERhdGE6IHsgbWF0Y2g6IEFycmF5PHN0cmluZz47IHJhbmdlOiBSYW5nZSB9IHwgbnVsbFxuICAvLyBFeHRyYWN0IHRoZSBleHByZXNzaW9uIGZyb20gdGhlIHJvdyB0ZXh0LlxuICBidWZmZXIuc2NhbkluUmFuZ2Uod29yZFJlZ2V4LCByb3dSYW5nZSwgKGRhdGEpID0+IHtcbiAgICBjb25zdCB7IHJhbmdlIH0gPSBkYXRhXG4gICAgaWYgKHJhbmdlLnN0YXJ0LmlzTGVzc1RoYW5PckVxdWFsKHBvc2l0aW9uKSAmJiByYW5nZS5lbmQuaXNHcmVhdGVyVGhhbihwb3NpdGlvbikpIHtcbiAgICAgIG1hdGNoRGF0YSA9IGRhdGFcbiAgICB9XG4gICAgLy8gU3RvcCB0aGUgc2NhbiBpZiB0aGUgc2Nhbm5lciBoYXMgcGFzc2VkIG91ciBwb3NpdGlvbi5cbiAgICBpZiAocmFuZ2UuZW5kLmNvbHVtbiA+IGNvbHVtbikge1xuICAgICAgZGF0YS5zdG9wKClcbiAgICB9XG4gIH0pXG4gIC8vIEB0cy1pZ25vcmUgKGl0IGlzIGFzc2lnbmVkIGFib3ZlKVxuICBpZiAobWF0Y2hEYXRhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdvcmRNYXRjaDogbWF0Y2hEYXRhLm1hdGNoLFxuICAgICAgcmFuZ2U6IG1hdGNoRGF0YS5yYW5nZSxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG4vLyBNYXRjaGVzIGEgcmVnZXggb24gdGhlIHRleHQgb2YgdGhlIGxpbmUgZW5kaW5nIGF0IGVuZFBvc2l0aW9uLlxuLy8gcmVnZXggc2hvdWxkIGVuZCB3aXRoIGEgJyQnLlxuLy8gVXNlZnVsIGZvciBhdXRvY29tcGxldGUuXG5leHBvcnQgZnVuY3Rpb24gbWF0Y2hSZWdleEVuZGluZ0F0KGJ1ZmZlcjogVGV4dEJ1ZmZlciwgZW5kUG9zaXRpb246IFBvaW50LCByZWdleDogUmVnRXhwKTogc3RyaW5nIHwgbnVsbCB7XG4gIGNvbnN0IGxpbmUgPSBidWZmZXIuZ2V0VGV4dEluUmFuZ2UoW1tlbmRQb3NpdGlvbi5yb3csIDBdLCBlbmRQb3NpdGlvbl0pXG4gIGNvbnN0IG1hdGNoID0gcmVnZXguZXhlYyhsaW5lKVxuICByZXR1cm4gbWF0Y2ggPT0gbnVsbCA/IG51bGwgOiBtYXRjaFswXVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNQb3NpdGlvbkluUmFuZ2UocG9zaXRpb246IFBvaW50LCByYW5nZTogUmFuZ2UgfCBBcnJheTxSYW5nZT4pOiBib29sZWFuIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkocmFuZ2UpID8gcmFuZ2Uuc29tZSgocikgPT4gci5jb250YWluc1BvaW50KHBvc2l0aW9uKSkgOiByYW5nZS5jb250YWluc1BvaW50KHBvc2l0aW9uKVxufVxuIl19