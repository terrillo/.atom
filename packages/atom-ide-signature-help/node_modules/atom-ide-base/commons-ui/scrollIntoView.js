"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.scrollIntoView = scrollIntoView;
exports.scrollIntoViewIfNeeded = scrollIntoViewIfNeeded;
exports.isOverflowHidden = isOverflowHidden;

/* globals getComputedStyle */

/**
 * Use these functions instead of `Element::scrollIntoView()` and `Element::scrollIntoViewIfNeeded()`!
 *
 * We've had a recurring issue in Nuclide (e.g. T20028138) where the UI would shift, leaving part of the workspace
 * element offscreen and a blank area in the window. This was caused by called to the native `scrollIntoView()` and
 * `scrollIntoViewIfNeeded()` which, according to the spec, has two potentially surprising behaviors:
 *
 * 1. It scrolls every scrollable ancestor (not just the closest), where
 * 2. "scrollable" is explicitly defined to include elements with `overflow: hidden`
 *
 * This is surprising because `overflow: hidden` is typically used to make elements *not scrollable*.
 *
 * Once the `overflow: hidden` element is scrolled, the user has no way to return it to its original position (as it has
 * no scrollbars).
 *
 * Note that this API doesn't support smooth scrolling. If that becomes necessary, we'll need to come up with a better fix.
 *
 * It's tempting to assume that using `scrollIntoViewIfNeeded()` would fix this issue, however, if the window is small
 * enough so that no amount of scrolling the desired scrollable element would ever reveal the element you're trying to,
 * the browser will keep scrolling ancestors.
 */
function scrollIntoView(el, alignToTop) {
  const scrollTops = getScrollTops(el);
  el.scrollIntoView(alignToTop);
  restoreOverflowHiddenScrollTops(scrollTops);
}

function scrollIntoViewIfNeeded(el, center = true) {
  var _scrollIntoViewIfNeed, _scrollIntoViewIfNeed2, _ref;

  const scrollTops = getScrollTops(el) // eslint-disable-next-line no-unused-expressions
  ;
  (_scrollIntoViewIfNeed = (_scrollIntoViewIfNeed2 = (_ref = el).scrollIntoViewIfNeeded) === null || _scrollIntoViewIfNeed2 === void 0 ? void 0 : _scrollIntoViewIfNeed2.call(_ref, center)) !== null && _scrollIntoViewIfNeed !== void 0 ? _scrollIntoViewIfNeed : el.scrollIntoView(center);
  restoreOverflowHiddenScrollTops(scrollTops);
}

function getScrollTops(el_) {
  let el = el_;
  const scrollTops = new Map();

  while (el !== null) {
    scrollTops.set(el, el.scrollTop);
    el = el.parentElement;
  }

  return scrollTops;
}

function restoreOverflowHiddenScrollTops(scrollTops) {
  scrollTops.forEach((scrollTop, el) => {
    if (el.scrollTop !== scrollTop && isOverflowHidden(el)) {
      el.scrollTop = scrollTop;
    }
  });
}

function isOverflowHidden(el) {
  const overflowStyle = el === null || el === void 0 ? void 0 : el.style.overflow;
  const overflow = overflowStyle !== null && overflowStyle !== void 0 ? overflowStyle : getComputedStyle(el).overflow;
  return overflow === "hidden";
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy1jb21tb25zLXVpL3Njcm9sbEludG9WaWV3LnRzIl0sIm5hbWVzIjpbInNjcm9sbEludG9WaWV3IiwiZWwiLCJhbGlnblRvVG9wIiwic2Nyb2xsVG9wcyIsImdldFNjcm9sbFRvcHMiLCJyZXN0b3JlT3ZlcmZsb3dIaWRkZW5TY3JvbGxUb3BzIiwic2Nyb2xsSW50b1ZpZXdJZk5lZWRlZCIsImNlbnRlciIsImVsXyIsIk1hcCIsInNldCIsInNjcm9sbFRvcCIsInBhcmVudEVsZW1lbnQiLCJmb3JFYWNoIiwiaXNPdmVyZmxvd0hpZGRlbiIsIm92ZXJmbG93U3R5bGUiLCJzdHlsZSIsIm92ZXJmbG93IiwiZ2V0Q29tcHV0ZWRTdHlsZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRU8sU0FBU0EsY0FBVCxDQUF3QkMsRUFBeEIsRUFBcUNDLFVBQXJDLEVBQWlFO0FBQ3RFLFFBQU1DLFVBQVUsR0FBR0MsYUFBYSxDQUFDSCxFQUFELENBQWhDO0FBQ0FBLEVBQUFBLEVBQUUsQ0FBQ0QsY0FBSCxDQUFrQkUsVUFBbEI7QUFDQUcsRUFBQUEsK0JBQStCLENBQUNGLFVBQUQsQ0FBL0I7QUFDRDs7QUFJTSxTQUFTRyxzQkFBVCxDQUFnQ0wsRUFBaEMsRUFBNkNNLE1BQWUsR0FBRyxJQUEvRCxFQUEyRTtBQUFBOztBQUNoRixRQUFNSixVQUFVLEdBQUdDLGFBQWEsQ0FBQ0gsRUFBRCxDQUFoQyxDQUNBO0FBREE7QUFFQyw2REFBQ0EsRUFBRCxFQUF3Qkssc0JBQXhCLDZGQUFpREMsTUFBakQsMEVBQTRETixFQUFFLENBQUNELGNBQUgsQ0FBa0JPLE1BQWxCLENBQTVEO0FBQ0RGLEVBQUFBLCtCQUErQixDQUFDRixVQUFELENBQS9CO0FBQ0Q7O0FBRUQsU0FBU0MsYUFBVCxDQUF1QkksR0FBdkIsRUFBMkQ7QUFDekQsTUFBSVAsRUFBa0IsR0FBR08sR0FBekI7QUFDQSxRQUFNTCxVQUFVLEdBQUcsSUFBSU0sR0FBSixFQUFuQjs7QUFDQSxTQUFPUixFQUFFLEtBQUssSUFBZCxFQUFvQjtBQUNsQkUsSUFBQUEsVUFBVSxDQUFDTyxHQUFYLENBQWVULEVBQWYsRUFBbUJBLEVBQUUsQ0FBQ1UsU0FBdEI7QUFDQVYsSUFBQUEsRUFBRSxHQUFHQSxFQUFFLENBQUNXLGFBQVI7QUFDRDs7QUFDRCxTQUFPVCxVQUFQO0FBQ0Q7O0FBRUQsU0FBU0UsK0JBQVQsQ0FBeUNGLFVBQXpDLEVBQWlGO0FBQy9FQSxFQUFBQSxVQUFVLENBQUNVLE9BQVgsQ0FBbUIsQ0FBQ0YsU0FBRCxFQUFZVixFQUFaLEtBQW1CO0FBQ3BDLFFBQUlBLEVBQUUsQ0FBQ1UsU0FBSCxLQUFpQkEsU0FBakIsSUFBOEJHLGdCQUFnQixDQUFDYixFQUFELENBQWxELEVBQXdEO0FBQ3REQSxNQUFBQSxFQUFFLENBQUNVLFNBQUgsR0FBZUEsU0FBZjtBQUNEO0FBQ0YsR0FKRDtBQUtEOztBQUVNLFNBQVNHLGdCQUFULENBQTBCYixFQUExQixFQUEyRTtBQUNoRixRQUFNYyxhQUFhLEdBQUlkLEVBQUosYUFBSUEsRUFBSix1QkFBSUEsRUFBRCxDQUFxQmUsS0FBckIsQ0FBMkJDLFFBQWpEO0FBQ0EsUUFBTUEsUUFBUSxHQUFHRixhQUFILGFBQUdBLGFBQUgsY0FBR0EsYUFBSCxHQUFvQkcsZ0JBQWdCLENBQUNqQixFQUFELENBQWhCLENBQXFCZ0IsUUFBdkQ7QUFDQSxTQUFPQSxRQUFRLEtBQUssUUFBcEI7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbHMgZ2V0Q29tcHV0ZWRTdHlsZSAqL1xuXG4vKipcbiAqIFVzZSB0aGVzZSBmdW5jdGlvbnMgaW5zdGVhZCBvZiBgRWxlbWVudDo6c2Nyb2xsSW50b1ZpZXcoKWAgYW5kIGBFbGVtZW50OjpzY3JvbGxJbnRvVmlld0lmTmVlZGVkKClgIVxuICpcbiAqIFdlJ3ZlIGhhZCBhIHJlY3VycmluZyBpc3N1ZSBpbiBOdWNsaWRlIChlLmcuIFQyMDAyODEzOCkgd2hlcmUgdGhlIFVJIHdvdWxkIHNoaWZ0LCBsZWF2aW5nIHBhcnQgb2YgdGhlIHdvcmtzcGFjZVxuICogZWxlbWVudCBvZmZzY3JlZW4gYW5kIGEgYmxhbmsgYXJlYSBpbiB0aGUgd2luZG93LiBUaGlzIHdhcyBjYXVzZWQgYnkgY2FsbGVkIHRvIHRoZSBuYXRpdmUgYHNjcm9sbEludG9WaWV3KClgIGFuZFxuICogYHNjcm9sbEludG9WaWV3SWZOZWVkZWQoKWAgd2hpY2gsIGFjY29yZGluZyB0byB0aGUgc3BlYywgaGFzIHR3byBwb3RlbnRpYWxseSBzdXJwcmlzaW5nIGJlaGF2aW9yczpcbiAqXG4gKiAxLiBJdCBzY3JvbGxzIGV2ZXJ5IHNjcm9sbGFibGUgYW5jZXN0b3IgKG5vdCBqdXN0IHRoZSBjbG9zZXN0KSwgd2hlcmVcbiAqIDIuIFwic2Nyb2xsYWJsZVwiIGlzIGV4cGxpY2l0bHkgZGVmaW5lZCB0byBpbmNsdWRlIGVsZW1lbnRzIHdpdGggYG92ZXJmbG93OiBoaWRkZW5gXG4gKlxuICogVGhpcyBpcyBzdXJwcmlzaW5nIGJlY2F1c2UgYG92ZXJmbG93OiBoaWRkZW5gIGlzIHR5cGljYWxseSB1c2VkIHRvIG1ha2UgZWxlbWVudHMgKm5vdCBzY3JvbGxhYmxlKi5cbiAqXG4gKiBPbmNlIHRoZSBgb3ZlcmZsb3c6IGhpZGRlbmAgZWxlbWVudCBpcyBzY3JvbGxlZCwgdGhlIHVzZXIgaGFzIG5vIHdheSB0byByZXR1cm4gaXQgdG8gaXRzIG9yaWdpbmFsIHBvc2l0aW9uIChhcyBpdCBoYXNcbiAqIG5vIHNjcm9sbGJhcnMpLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIEFQSSBkb2Vzbid0IHN1cHBvcnQgc21vb3RoIHNjcm9sbGluZy4gSWYgdGhhdCBiZWNvbWVzIG5lY2Vzc2FyeSwgd2UnbGwgbmVlZCB0byBjb21lIHVwIHdpdGggYSBiZXR0ZXIgZml4LlxuICpcbiAqIEl0J3MgdGVtcHRpbmcgdG8gYXNzdW1lIHRoYXQgdXNpbmcgYHNjcm9sbEludG9WaWV3SWZOZWVkZWQoKWAgd291bGQgZml4IHRoaXMgaXNzdWUsIGhvd2V2ZXIsIGlmIHRoZSB3aW5kb3cgaXMgc21hbGxcbiAqIGVub3VnaCBzbyB0aGF0IG5vIGFtb3VudCBvZiBzY3JvbGxpbmcgdGhlIGRlc2lyZWQgc2Nyb2xsYWJsZSBlbGVtZW50IHdvdWxkIGV2ZXIgcmV2ZWFsIHRoZSBlbGVtZW50IHlvdSdyZSB0cnlpbmcgdG8sXG4gKiB0aGUgYnJvd3NlciB3aWxsIGtlZXAgc2Nyb2xsaW5nIGFuY2VzdG9ycy5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2Nyb2xsSW50b1ZpZXcoZWw6IEVsZW1lbnQsIGFsaWduVG9Ub3A/OiBib29sZWFuKTogdm9pZCB7XG4gIGNvbnN0IHNjcm9sbFRvcHMgPSBnZXRTY3JvbGxUb3BzKGVsKVxuICBlbC5zY3JvbGxJbnRvVmlldyhhbGlnblRvVG9wKVxuICByZXN0b3JlT3ZlcmZsb3dIaWRkZW5TY3JvbGxUb3BzKHNjcm9sbFRvcHMpXG59XG5cbmV4cG9ydCB0eXBlIEVsZW1lbnRFeHRlbmRlZCA9IEVsZW1lbnQgJiB7IHNjcm9sbEludG9WaWV3SWZOZWVkZWQ/OiAoc2hvdWxkQ2VudGVyOiBib29sZWFuKSA9PiB2b2lkIH1cblxuZXhwb3J0IGZ1bmN0aW9uIHNjcm9sbEludG9WaWV3SWZOZWVkZWQoZWw6IEVsZW1lbnQsIGNlbnRlcjogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcbiAgY29uc3Qgc2Nyb2xsVG9wcyA9IGdldFNjcm9sbFRvcHMoZWwpXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcbiAgOyhlbCBhcyBFbGVtZW50RXh0ZW5kZWQpLnNjcm9sbEludG9WaWV3SWZOZWVkZWQ/LihjZW50ZXIpID8/IGVsLnNjcm9sbEludG9WaWV3KGNlbnRlcilcbiAgcmVzdG9yZU92ZXJmbG93SGlkZGVuU2Nyb2xsVG9wcyhzY3JvbGxUb3BzKVxufVxuXG5mdW5jdGlvbiBnZXRTY3JvbGxUb3BzKGVsXzogRWxlbWVudCk6IE1hcDxFbGVtZW50LCBudW1iZXI+IHtcbiAgbGV0IGVsOiBFbGVtZW50IHwgbnVsbCA9IGVsX1xuICBjb25zdCBzY3JvbGxUb3BzID0gbmV3IE1hcDxFbGVtZW50LCBudW1iZXI+KClcbiAgd2hpbGUgKGVsICE9PSBudWxsKSB7XG4gICAgc2Nyb2xsVG9wcy5zZXQoZWwsIGVsLnNjcm9sbFRvcClcbiAgICBlbCA9IGVsLnBhcmVudEVsZW1lbnRcbiAgfVxuICByZXR1cm4gc2Nyb2xsVG9wc1xufVxuXG5mdW5jdGlvbiByZXN0b3JlT3ZlcmZsb3dIaWRkZW5TY3JvbGxUb3BzKHNjcm9sbFRvcHM6IE1hcDxFbGVtZW50LCBudW1iZXI+KTogdm9pZCB7XG4gIHNjcm9sbFRvcHMuZm9yRWFjaCgoc2Nyb2xsVG9wLCBlbCkgPT4ge1xuICAgIGlmIChlbC5zY3JvbGxUb3AgIT09IHNjcm9sbFRvcCAmJiBpc092ZXJmbG93SGlkZGVuKGVsKSkge1xuICAgICAgZWwuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wXG4gICAgfVxuICB9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNPdmVyZmxvd0hpZGRlbihlbDogSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50IHwgRWxlbWVudCk6IGJvb2xlYW4ge1xuICBjb25zdCBvdmVyZmxvd1N0eWxlID0gKGVsIGFzIEhUTUxFbGVtZW50KT8uc3R5bGUub3ZlcmZsb3dcbiAgY29uc3Qgb3ZlcmZsb3cgPSBvdmVyZmxvd1N0eWxlID8/IGdldENvbXB1dGVkU3R5bGUoZWwpLm92ZXJmbG93XG4gIHJldHVybiBvdmVyZmxvdyA9PT0gXCJoaWRkZW5cIlxufVxuIl19