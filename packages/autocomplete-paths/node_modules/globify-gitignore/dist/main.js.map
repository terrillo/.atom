{"version":3,"file":"main.js","sources":["../node_modules/is-glob/index.js","../node_modules/is-extglob/index.js","../node_modules/.pnpm/is-valid-path@0.1.1/node_modules/is-invalid-path/index.js","../node_modules/.pnpm/is-valid-path@0.1.1/node_modules/is-valid-path/index.js","../node_modules/.pnpm/dedent@0.7.0/node_modules/dedent/dist/dedent.js","../src/main.ts","../src/utils.ts"],"sourcesContent":["/*!\n * is-glob <https://github.com/jonschlinkert/is-glob>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar isExtglob = require('is-extglob');\nvar chars = { '{': '}', '(': ')', '[': ']'};\nvar strictRegex = /\\\\(.)|(^!|\\*|[\\].+)]\\?|\\[[^\\\\\\]]+\\]|\\{[^\\\\}]+\\}|\\(\\?[:!=][^\\\\)]+\\)|\\([^|]+\\|[^\\\\)]+\\))/;\nvar relaxedRegex = /\\\\(.)|(^!|[*?{}()[\\]]|\\(\\?)/;\n\nmodule.exports = function isGlob(str, options) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  if (isExtglob(str)) {\n    return true;\n  }\n\n  var regex = strictRegex;\n  var match;\n\n  // optionally relax regex\n  if (options && options.strict === false) {\n    regex = relaxedRegex;\n  }\n\n  while ((match = regex.exec(str))) {\n    if (match[2]) return true;\n    var idx = match.index + match[0].length;\n\n    // if an open bracket/brace/paren is escaped,\n    // set the index to the next closing character\n    var open = match[1];\n    var close = open ? chars[open] : null;\n    if (open && close) {\n      var n = str.indexOf(close, idx);\n      if (n !== -1) {\n        idx = n + 1;\n      }\n    }\n\n    str = str.slice(idx);\n  }\n  return false;\n};\n","/*!\n * is-extglob <https://github.com/jonschlinkert/is-extglob>\n *\n * Copyright (c) 2014-2016, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nmodule.exports = function isExtglob(str) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  var match;\n  while ((match = /(\\\\).|([@?!+*]\\(.*\\))/g.exec(str))) {\n    if (match[2]) return true;\n    str = str.slice(match.index + match[0].length);\n  }\n\n  return false;\n};\n","/*!\n * is-invalid-path <https://github.com/jonschlinkert/is-invalid-path>\n *\n * Copyright (c) 2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\nvar isGlob = require('is-glob');\nvar re = /[‘“!#$%&+^<=>`]/;\n\nmodule.exports = function (str) {\n  return (typeof str !== 'string') || isGlob(str) || re.test(str);\n};\n","/*!\n * is-valid-path <https://github.com/jonschlinkert/is-valid-path>\n *\n * Copyright (c) 2015 Jon Schlinkert, contributors.\n * Licensed under the MIT license.\n */\n\n'use strict';\n\nvar isInvalidPath = require('is-invalid-path');\n\nmodule.exports = function (str) {\n  return isInvalidPath(str) === false;\n};\n","\"use strict\";\n\nfunction dedent(strings) {\n\n  var raw = void 0;\n  if (typeof strings === \"string\") {\n    // dedent can be used as a plain function\n    raw = [strings];\n  } else {\n    raw = strings.raw;\n  }\n\n  // first, perform interpolation\n  var result = \"\";\n  for (var i = 0; i < raw.length; i++) {\n    result += raw[i].\n    // join lines when there is a suppressed newline\n    replace(/\\\\\\n[ \\t]*/g, \"\").\n\n    // handle escaped backticks\n    replace(/\\\\`/g, \"`\");\n\n    if (i < (arguments.length <= 1 ? 0 : arguments.length - 1)) {\n      result += arguments.length <= i + 1 ? undefined : arguments[i + 1];\n    }\n  }\n\n  // now strip indentation\n  var lines = result.split(\"\\n\");\n  var mindent = null;\n  lines.forEach(function (l) {\n    var m = l.match(/^(\\s+)\\S+/);\n    if (m) {\n      var indent = m[1].length;\n      if (!mindent) {\n        // this is the first indented line\n        mindent = indent;\n      } else {\n        mindent = Math.min(mindent, indent);\n      }\n    }\n  });\n\n  if (mindent !== null) {\n    result = lines.map(function (l) {\n      return l[0] === \" \" ? l.slice(mindent) : l;\n    }).join(\"\\n\");\n  }\n\n  // dedent eats leading and trailing whitespace too\n  result = result.trim();\n\n  // handle escaped newlines at the end to ensure they don't get stripped too\n  return result.replace(/\\\\n/g, \"\\n\");\n}\n\nif (typeof module !== \"undefined\") {\n  module.exports = dedent;\n}\n","import { join, normalize } from \"path\"\nimport { promises } from \"fs\"\nconst { readFile, stat } = promises\nimport isPath from \"is-valid-path\"\nimport { unique } from \"./utils\"\nimport dedent from \"dedent\"\n\n/**\n * Converts given path to Posix (replacing \\ with /)\n *\n * @param {string} givenPath Path to convert\n * @returns {string} Converted filepath\n */\nexport function posixifyPath(givenPath: string): string {\n  return normalize(givenPath).replace(/\\\\/g, \"/\")\n}\n\n/**\n * Converts given path to Posix (replacing \\ with /) and removing ending slashes\n *\n * @param {string} givenPath Path to convert\n * @returns {string} Converted filepath\n */\nexport function posixifyPathNormalized(givenPath: string): string {\n  return posixifyPath(givenPath).replace(/\\/$/, \"\")\n}\n\n/**\n * @param {string} givenPath The given path to be globified\n * @param {string} givenDirectory [process.cwd()] The cwd to use to resolve relative path names\n * @returns {Promise<string | [string, string]>} The glob path or the file path itself\n */\nexport function globifyPath(\n  givenPath: string,\n  givenDirectory: string = process.cwd()\n): Promise<string | [string, string]> {\n  return globifyGitIgnoreEntry(posixifyPath(givenPath), givenDirectory)\n}\n\n/**\n * Globifies a directory\n *\n * @param {string} givenDirectory The given directory to be globified\n */\nexport function globifyDirectory(givenDirectory: string) {\n  return `${posixifyPathNormalized(givenDirectory)}/**`\n}\n\n/**\n * Parse and globy the `.gitingore` file that exists in a directory\n *\n * @param {string} gitIgnoreDirectory The given directory that has the `.gitignore` file\n * @returns {Promise<string[]>} An array of glob patterns\n */\nexport async function globifyGitIgnoreFile(gitIgnoreDirectory: string): Promise<Array<string>> {\n  return globifyGitIgnore(await readFile(join(gitIgnoreDirectory, \".gitignore\"), \"utf-8\"), gitIgnoreDirectory)\n}\n\n/**\n * Read `.gitingore` file from a directory\n *\n * @param {string} gitIgnoreContent The content of the gitignore file\n * @param {string | undefined} gitIgnoreDirectory The directory of gitignore\n * @returns {Promise<string[]>} An array of glob patterns\n */\nexport async function globifyGitIgnore(\n  gitIgnoreContent: string,\n  gitIgnoreDirectory: string | undefined = undefined\n): Promise<Array<string>> {\n  const gitIgnoreEntries = dedent(gitIgnoreContent)\n    .split(\"\\n\") // Remove empty lines and comments.\n    .filter((entry) => !(isWhitespace(entry) || isGitIgnoreComment(entry))) // Remove surrounding whitespace\n    .map((entry) => trimWhiteSpace(entry))\n  const gitIgnoreEntriesNum = gitIgnoreEntries.length\n  const globEntries = new Array(gitIgnoreEntriesNum)\n\n  for (let iEntry = 0; iEntry < gitIgnoreEntriesNum; iEntry++) {\n    const globifyOutput = await globifyGitIgnoreEntry(gitIgnoreEntries[iEntry], gitIgnoreDirectory)\n\n    // Check if `globifyGitIgnoreEntry` returns a pair or a string\n    if (typeof globifyOutput === \"string\") {\n      // string\n      globEntries[iEntry] = globifyOutput // Place the entry in the output array\n    } else {\n      // pair\n      globEntries[iEntry] = globifyOutput[0] // Place the entry in the output array\n\n      globEntries.push(globifyOutput[1]) // Push the additional entry\n    }\n  }\n\n  // unique in the end\n  return unique(globEntries)\n}\n\n/**\n * @param {string} gitIgnoreEntry One git ignore entry (it expects a valid non-comment gitignore entry with no\n *   surrounding whitespace)\n * @param {string | undefined} gitIgnoreDirectory The directory of gitignore\n * @returns {Promise<string | [string, string]>} The equivalent glob\n */\nasync function globifyGitIgnoreEntry(\n  gitIgnoreEntry: string,\n  gitIgnoreDirectory: string | undefined\n): Promise<string | [string, string]> {\n  // output glob entry\n  let entry = gitIgnoreEntry\n  // Process the entry beginning\n  // '!' in .gitignore means to force include the pattern\n  // remove \"!\" to allow the processing of the pattern and swap ! in the end of the loop\n  let forceInclude = false\n\n  if (entry[0] === \"!\") {\n    entry = entry.substring(1)\n    forceInclude = true\n  }\n\n  // If there is a separator at the beginning or middle (or both) of the pattern,\n  // then the pattern is relative to the directory level of the particular .gitignore file itself\n  // Process slash\n\n  /** @type {PATH_TYPE.OTHER | PATH_TYPE.DIRECTORY | PATH_TYPE.FILE} */\n  let pathType: PATH_TYPE.OTHER | PATH_TYPE.DIRECTORY | PATH_TYPE.FILE = PATH_TYPE.OTHER\n\n  if (entry[0] === \"/\") {\n    // Patterns starting with '/' in gitignore are considered relative to the project directory while glob\n    // treats them as relative to the OS root directory.\n    // So we trim the slash to make it relative to project folder from glob perspective.\n    entry = entry.substring(1)\n\n    // Check if it is a directory or file\n    if (isPath(entry)) {\n      pathType = await getPathType(gitIgnoreDirectory ? join(gitIgnoreDirectory, entry) : entry)\n    }\n  } else {\n    const slashPlacement = entry.indexOf(\"/\")\n\n    if (slashPlacement === -1) {\n      // Patterns that don't have `/` are '**/' from glob perspective (can match at any level)\n      if (!entry.startsWith(\"**/\")) {\n        entry = `**/${entry}`\n      }\n    } else if (slashPlacement === entry.length - 1) {\n      // If there is a separator at the end of the pattern then it only matches directories\n      // slash is in the end\n      pathType = PATH_TYPE.DIRECTORY\n    } else {\n      // has `/` in the middle so it is a relative path\n      // Check if it is a directory or file\n      if (isPath(entry)) {\n        pathType = await getPathType(gitIgnoreDirectory ? join(gitIgnoreDirectory, entry) : entry)\n      }\n    }\n  }\n\n  // prepend the absolute root directory\n  if (gitIgnoreDirectory) {\n    entry = `${posixifyPath(gitIgnoreDirectory)}/${entry}`\n  }\n\n  // swap !\n  entry = forceInclude ? entry : `!${entry}`\n\n  // Process the entry ending\n  if (pathType === PATH_TYPE.DIRECTORY) {\n    // in glob this is equal to `directory/**`\n    if (entry.endsWith(\"/\")) {\n      return `${entry}**`\n    } else {\n      return `${entry}/**`\n    }\n  } else if (pathType === PATH_TYPE.FILE) {\n    // return as is for file\n    return entry\n  } else if (!entry.endsWith(\"/**\")) {\n    // the pattern can match both files and directories\n    // so we should include both `entry` and `entry/**`\n    return [entry, `${entry}/**`]\n  } else {\n    return entry\n  }\n}\n\nfunction isWhitespace(str: string) {\n  return /^\\s*$/.test(str)\n}\n\n/**\n * A line starting with # serves as a comment. Put a backslash (\"\") in front of the first hash for patterns that begin\n * with a hash.\n */\nfunction isGitIgnoreComment(pattern: string) {\n  return pattern[0] === \"#\"\n}\n\n/** Trailing spaces should be removed unless they are quoted with backslash (\"\\ \"). */\nfunction trimTrailingWhitespace(str: string) {\n  if (!/\\\\\\s+$/.test(str)) {\n    // No escaped trailing whitespace, remove\n    return str.replace(/\\s+$/, \"\")\n  } else {\n    // Trailing whitespace detected, remove only the backslash\n    return str.replace(/\\\\(\\s+)$/, \"$1\")\n  }\n}\n\n/** Remove leading whitespace */\nfunction trimLeadingWhiteSpace(str: string) {\n  return str.replace(/^\\s+/, \"\")\n}\n\n/** Remove whitespace from a gitignore entry */\nfunction trimWhiteSpace(str: string) {\n  return trimLeadingWhiteSpace(trimTrailingWhitespace(str))\n}\n\n/** Enum that specifies the path type. 1 for directory, 2 for file, 0 for others */\nenum PATH_TYPE {\n  OTHER,\n  DIRECTORY,\n  FILE,\n}\n\n/**\n * Get the type of the given path\n *\n * @param {string} givenPath Absolute path\n * @returns {Promise<PATH_TYPE>}\n */\nasync function getPathType(filepath: string): Promise<PATH_TYPE> {\n  let pathStat\n  try {\n    pathStat = await stat(filepath)\n  } catch (error) {\n    return PATH_TYPE.OTHER\n  }\n  if (pathStat.isDirectory()) {\n    return PATH_TYPE.DIRECTORY\n  } else if (pathStat.isFile()) {\n    return PATH_TYPE.FILE\n  }\n  return PATH_TYPE.OTHER\n}\n","// get unique entries of an array\nexport function unique(arr: Array<any>) {\n  return [...new Set(arr)]\n}\n"],"names":["isExtglob","str","match","exec","slice","index","length","chars","{","(","[","strictRegex","relaxedRegex","isGlob","options","regex","strict","idx","open","close","n","indexOf","re","isInvalidPath","test","isValidPath","strings","raw","result","i","replace","arguments","undefined","lines","split","mindent","forEach","l","m","indent","Math","min","map","join","trim","readFile","stat","promises","posixifyPath","givenPath","normalize","posixifyPathNormalized","async","globifyGitIgnore","gitIgnoreContent","gitIgnoreDirectory","gitIgnoreEntries","dedent","filter","entry","pattern","trimLeadingWhiteSpace","trimTrailingWhitespace","gitIgnoreEntriesNum","globEntries","Array","iEntry","globifyOutput","globifyGitIgnoreEntry","push","Set","gitIgnoreEntry","forceInclude","substring","pathType","PATH_TYPE","OTHER","isPath","getPathType","slashPlacement","startsWith","DIRECTORY","endsWith","FILE","filepath","pathStat","error","isDirectory","isFile","givenDirectory","process","cwd"],"mappings":"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"}