import * as Binding from "./binding";
export interface IOptions {
    /** @default false */
    allowErrors?: boolean;
    /** @default true */
    usePathScoring?: boolean;
    /** @default false */
    useExtensionBonus?: boolean;
    pathSeparator?: "/" | "\\" | string;
    /** @deprecated: there is no major benefit by precomputing something just for the query. */
    preparedQuery?: {};
}
export declare type IFilterOptions<T extends StringOrObjectArray> = IOptions & {
    /** @deprecated The key to use when candidates is an object
     * Deprecated option. Pass the key as a string to the second argument of 'ArrayFilterer.setCandidates' or to the third argument of 'filter'
     */
    key?: T extends string ? never : keyof T;
    /** The maximum numbers of results to return */
    maxResults?: number;
};
export declare type ObjectElement = object & Record<string, string>;
export declare type StringOrObjectArray = string | ObjectElement;
/** ArrayFilterer is a class that allows to set the `candidates` only once and perform filtering on them multiple times.
 *  This is much more efficient than calling the `filter` function directly.
 */
export declare class ArrayFilterer<T extends StringOrObjectArray> {
    obj: Binding.Zadeh;
    candidates: Array<T>;
    constructor(candidates?: Array<T>, dataKey?: string);
    /** The method to set the candidates that are going to be filtered
     * @param candidates An array of tree objects.
     * @param dataKey (optional) if `candidates` is an array of objects, pass the key in the object which holds the data.
     */
    setCandidates(candidates: Array<T>, dataKey?: string): boolean;
    /** The method to perform the filtering on the already set candidates
     *  @param query A string query to match each candidate against.
     *  @param options options
     *  @return returns an array of candidates sorted by best match against the query.
     */
    filter(query: string, options?: IFilterOptions<T>): Array<T>;
}
/**
 * @deprecated use ArrayFilterer or TreeFilterer classes instead
 */
export declare const New: () => ArrayFilterer<StringOrObjectArray>;
/** Sort and filter the given candidates by matching them against the given query.
 * @param candidates An array of strings or objects.
 * @param query A string query to match each candidate against.
 * @param options options
 * @return returns an array of candidates sorted by best match against the query.
 */
export declare function filter<T extends StringOrObjectArray>(candidates: T[], query: string, options?: IFilterOptions<T>): T[];
export interface TreeFilterResult {
    data: string;
    index: number;
    level: number;
}
/** TreeFilterer is a class that allows to set the `candidates` only once and perform filtering on them multiple times.
 *  This is much more efficient than calling the `filterTree` function directly.
 */
export declare class TreeFilterer<T extends Tree = Tree> {
    obj: Binding.Zadeh;
    candidates: Array<T>;
    constructor(candidates?: Array<T>, dataKey?: string, childrenKey?: string);
    /** The method to set the candidates that are going to be filtered
     * @param candidates An array of tree objects.
     * @param dataKey the key of the object (and its children) which holds the data (defaults to `"data"`)
     * @param childrenKey the key of the object (and its children) which hold the children (defaults to `"children"`)
     */
    setCandidates(candidates: Array<T>, dataKey?: string, childrenKey?: string): boolean;
    /** The method to perform the filtering on the already set candidates
     *  @param query A string query to match each candidate against.
     *  @param options options
     *  @return An array of candidate objects in form of `{data, index, level}` sorted by best match against the query. Each objects has the address of the object in the tree using `index` and `level`.
     */
    filter(query: string, options?: IFilterOptions<ObjectElement>): TreeFilterResult[];
}
export declare type Tree = Record<string, string>;
/** Sort and filter the given Tree candidates by matching them against the given query.
 * A tree object is an object in which each entry stores the data in its dataKey and it has (may have) some children (with a similar structure) in its childrenKey
 * @param candidatesTrees An array of tree objects.
 * @param query A string query to match each candidate against.
 * @param dataKey the key of the object (and its children) which holds the data (defaults to `"data"`)
 * @param childrenKey the key of the object (and its children) which hold the children (defaults to `"children"`)
 * @param options options
 * @return An array of candidate objects in form of `{data, index, level}` sorted by best match against the query. Each objects has the address of the object in the tree using `index` and `level`.
 */
export declare function filterTree(candidatesTrees: Tree[], query: string, dataKey?: string, childrenKey?: string, options?: IFilterOptions<Tree>): TreeFilterResult[];
/** Score the given string against the given query.
 * @param candidate The string the score.
 * @param query The query to score the string against.
 * @param options options
 */
export declare function score(candidate: string, query: string, options?: IOptions): number;
/** Gives an array of indices at which the query matches the given string */
export declare function match(str: string, query: string, options?: IOptions): number[];
/** Gives an HTML/Markdown string that highlights the range for which the match happens */
export declare function wrap(str: string, query: string, options?: IOptions): string;
/** @deprecated: there is no major benefit by precomputing something just for the query. */
export declare function prepareQuery(query: string, options?: IOptions): {};
