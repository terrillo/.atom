{"version":3,"file":"index.js","sources":["src/binding/index.ts"],"sourcesContent":["// @ts-ignore\nimport nodeGypBuld from \"node-gyp-build\"\n\nimport * as Binding from \"./binding\"\nconst binding = nodeGypBuld(__dirname) as typeof Binding // __dirname relies on Parcel to bundle this file in the root of the package, so __dirname becomes correct\n\n/*\n ██████  ██████  ████████ ██  ██████  ███    ██ ███████\n██    ██ ██   ██    ██    ██ ██    ██ ████   ██ ██\n██    ██ ██████     ██    ██ ██    ██ ██ ██  ██ ███████\n██    ██ ██         ██    ██ ██    ██ ██  ██ ██      ██\n ██████  ██         ██    ██  ██████  ██   ████ ███████\n*/\n\nexport interface IOptions {\n  /** @default false */\n  allowErrors?: boolean\n\n  /** @default true */\n  usePathScoring?: boolean\n\n  /** @default false */\n  useExtensionBonus?: boolean\n\n  pathSeparator?: \"/\" | \"\\\\\" | string\n\n  // TODO not implemented?\n  // optCharRegEx?: RegExp\n\n  // TODO not implemented?\n  // wrap?: { tagOpen?: string; tagClass?: string; tagClose?: string }\n\n  /** @deprecated: there is no major benefit by precomputing something just for the query. */\n  preparedQuery?: {}\n}\n\nexport type IFilterOptions<T extends StringOrObjectArray> = IOptions & {\n  /** @deprecated The key to use when candidates is an object\n   * Deprecated option. Pass the key as a string to the second argument of 'ArrayFilterer.setCandidates' or to the third argument of 'filter'\n   */\n  key?: T extends string ? never : keyof T\n\n  /** The maximum numbers of results to return */\n  maxResults?: number\n\n  // TODO not implemented\n  // maxInners?: number\n}\n\nconst defaultPathSeparator = process.platform === \"win32\" ? \"\\\\\" : \"/\"\n\nfunction parseOptions(options: IOptions) {\n  // options.allowErrors ? = false\n  if (options.usePathScoring === undefined || options.usePathScoring === null) {\n    options.usePathScoring = true\n  }\n  // options.useExtensionBonus ? = false\n  if (!options.pathSeparator) {\n    options.pathSeparator = defaultPathSeparator\n  }\n}\n\nfunction parseFilterOptions<T extends StringOrObjectArray>(filterOptions: IFilterOptions<T>) {\n  // options.optCharRegEx ? = null\n  // options.wrap ? = null\n  if (!filterOptions.maxResults) {\n    filterOptions.maxResults = 0\n  }\n  // parse common options\n  parseOptions(filterOptions)\n}\n\nfunction getDataKey<T extends StringOrObjectArray>(dataKey: string | IFilterOptions<T>): string | undefined {\n  if (typeof dataKey === \"string\") {\n    return dataKey\n  } else if (dataKey?.key) {\n    // console.warn(`Zadeh: deprecated option.\n    // Pass the key as a string to the second argument of 'ArrayFilterer.setCandidates'\n    // or to the third argument of 'filter'`)\n    // an object (options) containing the key\n    // @ts-ignore\n    return dataKey.key\n  } else {\n    return undefined\n  }\n}\n\n/*\n █████  ██████  ██████   █████  ██    ██     ███████ ██ ██   ████████ ███████ ██████\n██   ██ ██   ██ ██   ██ ██   ██  ██  ██      ██      ██ ██      ██    ██      ██   ██\n███████ ██████  ██████  ███████   ████       █████   ██ ██      ██    █████   ██████\n██   ██ ██   ██ ██   ██ ██   ██    ██        ██      ██ ██      ██    ██      ██   ██\n██   ██ ██   ██ ██   ██ ██   ██    ██        ██      ██ ███████ ██    ███████ ██   ██\n*/\n\nexport type ObjectElement = object & Record<string, string>\nexport type StringOrObjectArray = string | ObjectElement\n\n/** ArrayFilterer is a class that allows to set the `candidates` only once and perform filtering on them multiple times.\n *  This is much more efficient than calling the `filter` function directly.\n */\nexport class ArrayFilterer<T extends StringOrObjectArray> {\n  obj = new binding.Zadeh()\n  // @ts-ignore\n  candidates: Array<T>\n\n  constructor(candidates?: Array<T>, dataKey?: string) {\n    if (candidates) {\n      this.setCandidates(candidates, dataKey)\n    } else {\n      this.candidates = []\n    }\n  }\n\n  /** The method to set the candidates that are going to be filtered\n   * @param candidates An array of tree objects.\n   * @param dataKey (optional) if `candidates` is an array of objects, pass the key in the object which holds the data.\n   */\n  setCandidates(candidates: Array<T>, dataKey?: string) {\n    this.candidates = candidates\n    let candidateStrings: string[]\n    if (dataKey) {\n      const validDataKey = getDataKey<T>(dataKey)\n      candidateStrings = (candidates as Array<Record<string, string>>).map((item) => item[validDataKey as string])\n    } else {\n      candidateStrings = candidates as string[]\n    }\n    return this.obj.setArrayFiltererCandidates(candidateStrings)\n  }\n\n  /** The method to perform the filtering on the already set candidates\n   *  @param query A string query to match each candidate against.\n   *  @param options options\n   *  @return returns an array of candidates sorted by best match against the query.\n   */\n  filter(query: string, options: IFilterOptions<T> = {}): Array<T> {\n    parseFilterOptions(options)\n    const res = this.obj.filter(\n      query,\n      options.maxResults as number /* numberified by parseFilterOptions */,\n      Boolean(options.usePathScoring),\n      Boolean(options.useExtensionBonus)\n    )\n    return res.map((ind: number) => this.candidates[ind])\n  }\n}\n\n/**\n * @deprecated use ArrayFilterer or TreeFilterer classes instead\n */\nexport const New = () => new ArrayFilterer()\n\n/** Sort and filter the given candidates by matching them against the given query.\n * @param candidates An array of strings or objects.\n * @param query A string query to match each candidate against.\n * @param options options\n * @return returns an array of candidates sorted by best match against the query.\n */\nexport function filter<T extends StringOrObjectArray>(\n  candidates: T[],\n  query: string,\n  options: IFilterOptions<T> = {}\n): T[] {\n  if (!candidates || !query) {\n    console.warn(`Zadeh: bad input to filter candidates: ${candidates}, query: ${query}`)\n    return []\n  }\n  const arrayFilterer = new ArrayFilterer<T>()\n  arrayFilterer.setCandidates(candidates, getDataKey(options))\n  return arrayFilterer.filter(query, options)\n}\n\n/*\n████████ ██████  ███████ ███████     ███████ ██ ██   ████████ ███████ ██████\n   ██    ██   ██ ██      ██          ██      ██ ██      ██    ██      ██   ██\n   ██    ██████  █████   █████       █████   ██ ██      ██    █████   ██████\n   ██    ██   ██ ██      ██          ██      ██ ██      ██    ██      ██   ██\n   ██    ██   ██ ███████ ███████     ██      ██ ███████ ██    ███████ ██   ██\n*/\n\n// The object (an element of the array) returned from filtering trees. It has the address of the object in the tree using `index` and `level`.\nexport interface TreeFilterResult {\n  data: string\n  index: number\n  level: number\n}\n\n/** TreeFilterer is a class that allows to set the `candidates` only once and perform filtering on them multiple times.\n *  This is much more efficient than calling the `filterTree` function directly.\n */\nexport class TreeFilterer<T extends Tree = Tree> {\n  obj = new binding.Zadeh()\n  // @ts-ignore\n  candidates: Array<T>\n\n  constructor(candidates?: Array<T>, dataKey: string = \"data\", childrenKey: string = \"children\") {\n    if (candidates) {\n      this.setCandidates(candidates, dataKey, childrenKey)\n    } else {\n      this.candidates = []\n    }\n  }\n\n  /** The method to set the candidates that are going to be filtered\n   * @param candidates An array of tree objects.\n   * @param dataKey the key of the object (and its children) which holds the data (defaults to `\"data\"`)\n   * @param childrenKey the key of the object (and its children) which hold the children (defaults to `\"children\"`)\n   */\n  setCandidates(candidates: Array<T>, dataKey: string = \"data\", childrenKey: string = \"children\") {\n    this.candidates = candidates\n    return this.obj.setTreeFiltererCandidates(candidates, dataKey, childrenKey)\n  }\n\n  /** The method to perform the filtering on the already set candidates\n   *  @param query A string query to match each candidate against.\n   *  @param options options\n   *  @return An array of candidate objects in form of `{data, index, level}` sorted by best match against the query. Each objects has the address of the object in the tree using `index` and `level`.\n   */\n  filter(query: string, options: IFilterOptions<ObjectElement> = {}): TreeFilterResult[] {\n    parseFilterOptions(options)\n    return this.obj.filterTree(\n      query,\n      options.maxResults as number /* numberified by parseFilterOptions */,\n      Boolean(options.usePathScoring),\n      Boolean(options.useExtensionBonus)\n    )\n  }\n}\n\n// TODO better type\nexport type Tree = Record<string, string>\n\n/** Sort and filter the given Tree candidates by matching them against the given query.\n * A tree object is an object in which each entry stores the data in its dataKey and it has (may have) some children (with a similar structure) in its childrenKey\n * @param candidatesTrees An array of tree objects.\n * @param query A string query to match each candidate against.\n * @param dataKey the key of the object (and its children) which holds the data (defaults to `\"data\"`)\n * @param childrenKey the key of the object (and its children) which hold the children (defaults to `\"children\"`)\n * @param options options\n * @return An array of candidate objects in form of `{data, index, level}` sorted by best match against the query. Each objects has the address of the object in the tree using `index` and `level`.\n */\nexport function filterTree(\n  candidatesTrees: Tree[],\n  query: string,\n  dataKey: string = \"data\",\n  childrenKey: string = \"children\",\n  options: IFilterOptions<Tree> = {}\n): TreeFilterResult[] {\n  if (!candidatesTrees || !query) {\n    console.warn(`Zadeh: bad input to filterTree candidatesTrees: ${candidatesTrees}, query: ${query}`)\n    return []\n  }\n  const treeFilterer = new TreeFilterer()\n  treeFilterer.setCandidates(candidatesTrees, dataKey, childrenKey)\n  return treeFilterer.filter(query, options)\n}\n\n/*\n███████  ██████  ██████  ██████  ███████\n██      ██      ██    ██ ██   ██ ██\n███████ ██      ██    ██ ██████  █████\n     ██ ██      ██    ██ ██   ██ ██\n███████  ██████  ██████  ██   ██ ███████\n*/\n\n/** Score the given string against the given query.\n * @param candidate The string the score.\n * @param query The query to score the string against.\n * @param options options\n */\nexport function score(candidate: string, query: string, options: IOptions = {}): number {\n  if (!candidate || !query) {\n    console.warn(`Zadeh: bad input to score candidates: ${candidate}, query: ${query}`)\n    return 0\n  }\n  parseOptions(options)\n  return binding.score(candidate, query, Boolean(options.usePathScoring), Boolean(options.useExtensionBonus))\n}\n\n/*\n███    ███  █████  ████████  ██████ ██   ██\n████  ████ ██   ██    ██    ██      ██   ██\n██ ████ ██ ███████    ██    ██      ███████\n██  ██  ██ ██   ██    ██    ██      ██   ██\n██      ██ ██   ██    ██     ██████ ██   ██\n*/\n\n/** Gives an array of indices at which the query matches the given string */\nexport function match(str: string, query: string, options: IOptions = {}): number[] {\n  if (!str || !query) {\n    console.warn(`Zadeh: bad input to match str: ${str}, query: ${query}`)\n    return []\n  }\n  if (str === query) {\n    return Array.from(Array(str.length).keys())\n  }\n  parseOptions(options)\n  return binding.match(str, query, options.pathSeparator as string /* stringified by parseOption */)\n}\n\n/*\n██     ██ ██████   █████  ██████\n██     ██ ██   ██ ██   ██ ██   ██\n██  █  ██ ██████  ███████ ██████\n██ ███ ██ ██   ██ ██   ██ ██\n ███ ███  ██   ██ ██   ██ ██\n*/\n\n/** Gives an HTML/Markdown string that highlights the range for which the match happens */\nexport function wrap(str: string, query: string, options: IOptions = {}): string {\n  if (!str || !query) {\n    console.warn(`Zadeh: bad input to wrap str: ${str}, query: ${query}`)\n    // @ts-ignore\n    return []\n  }\n  parseOptions(options)\n  return binding.wrap(str, query, options.pathSeparator as string /* stringified by parseOption */)\n}\n\n/*\n ██████  ████████ ██   ██ ███████ ██████\n██    ██    ██    ██   ██ ██      ██   ██\n██    ██    ██    ███████ █████   ██████\n██    ██    ██    ██   ██ ██      ██   ██\n ██████     ██    ██   ██ ███████ ██   ██\n*/\n\n/** @deprecated: there is no major benefit by precomputing something just for the query. */\n/* eslint-disable @typescript-eslint/no-unused-vars */\n// @ts-ignore\nexport function prepareQuery(query: string, options: IOptions = {}): {} {\n  console.warn(\n    \"Zadeh: prepareQuery is deprecated. There is no major benefit by precomputing something just for the query. \"\n  )\n  // This is no - op since there is no major benefit by precomputing something\n  // just for the query.\n  return {}\n}\n"],"names":["binding","__dirname","defaultPathSeparator","process","platform","parseOptions","options","undefined","usePathScoring","pathSeparator","parseFilterOptions","filterOptions","maxResults","getDataKey","dataKey","key","candidates","this","Zadeh","setCandidates","ArrayFilterer","candidateStrings","validDataKey_1","map","item","obj","setArrayFiltererCandidates","query","filter","Boolean","useExtensionBonus","ind","_this","childrenKey","TreeFilterer","setTreeFiltererCandidates","filterTree","console","warn","arrayFilterer","candidatesTrees","treeFilterer","str","Array","from","length","keys","match","candidate","score","wrap"],"mappings":"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"}