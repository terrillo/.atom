{"mappings":"oGAoCgBA,KAAmBC,MAGhB,iBAANA,EAAK,IACC,iBAANA,EAAK,IACC,kBAANA,EAAK,IACC,kBAANA,EAAK,GAAgB,MAGpBC,MAAK,iCAAkCD,YAIrCE,KAAuCF,OAChDG,MAAMC,QAAQJ,EAAK,IAAC,MACbC,MAAK,qDAAsDD,YCShEK,EAAaC,QAEWC,IAA3BD,EAAQE,iBACVF,EAAQE,gBAAiB,QAGGD,IAA1BD,EAAQG,gBACVH,EAAQG,cAAgBC,YAInBC,EAAmBC,QAGOL,IAA7BK,EAAcC,aAChBD,EAAcC,WAAa,GAG7BR,EAAaO,cAyR+BE,EAAAC,EAAiBT,EAAA,YAG3CS,4HAiBZC,kFAMFA,GAAkB,kBAmCRC,OAAAF,EAAAT,mCAEZY,YACQC,KAAA,uEAIqB,IAAAC,EAAsBN,GAC3BG,OAAQF,EAAQT,GAE1C,MAAAL,MAAA,0CAAuBa,aAAkBC,eAAgBT,wLDpWzBN,QAGf,iBAANA,EAAK,IACC,iBAANA,EAAK,IACC,kBAANA,EAAK,IACC,kBAANA,EAAK,GAAgB,MAGpBC,MAAK,gCAAiCD,oOAIlBA,QAGf,iBAANA,EAAK,IACC,iBAANA,EAAK,IACC,iBAANA,EAAK,IAC4B,IAAnBA,EAAK,GAAGqB,OAAY,MAGjCpB,MAAK,gCAAiCD,4KAInBA,QAGd,iBAANA,EAAK,IACC,iBAANA,EAAK,IACC,iBAANA,EAAK,IAC4B,IAAnBA,EAAK,GAAGqB,OAAY,MAGjCpB,MAAK,+BAAgCD,mjBCzG7CsB,EAAUC,EAAYC,WAsDtBd,EAAuC,UAAhBe,QAAQC,SAAoB,KAAO,UAwCnDN,iBAmBXO,KAAAC,IAAA,IAAAN,EAAAO,WAMoBtB,MAAUoB,KAAAG,cAAAC,GAE5BJ,KAAAK,WAAA,6CAeF9B,EAAA8B,yDAwBW,OAAAL,KAAAM,cAAAlB,EAAAT,GAAmB4B,KAAAC,GAAAR,KAAAK,WAAAG,6BA+BQ7B,wBAGtCE,IAAAF,EAAAE,gDAQsEO,EAAAqB,EAAc5B,EAAA6B,6DAsBlFV,KAAAC,IAAA,IAAAN,EAAAO,WACgBtB,YAA8BA,IAAhB+B,EAAkBX,KAAcG,cAAES,EAAiBD,oCAwBrEN,EAAEQ,GACdb,KAAAK,WAAAA,6BAIuCS,GACvCd,KAAAC,IAAAc,2BAAAD,cAWgB,WAEZd,KAAAM,cAAAlB,EAAAT,GAAA4B,KAAAC,GAAuBR,KAAAK,WAAAG,KAqC7BQ,cAAA5B,EAAAT,EAAA,MAauBA,WAEdA,EAAUO,gCAInBwB,IAAA/B,EAAA+B,kBAcE,SAF4BtB,EAAAqB,EAAA5B,EAAA6B,GAE5B,IAAAtB,EAAAM,UAIFM,KAAAC,IAAAK,cAAAlB,EAAAqB,EAAA5B,EAAA6B,WAWiD,KACR,sBA0F7BvB,EACH8B,EAAW,OAASC,EAAa,YAE1ClB,KAAAC,IAAA,IAAAN,EAAoBO,MAEdf,EAAaa,KAAGG,cAAQhB,EAAwB8B,EAAAC,GAEtDlB,KAAAK,WAAA,wEDnYoDhC,SAC9CG,MAAMC,QAAQJ,EAAK,KAAoB,iBAANA,EAAK,IAAgC,iBAANA,EAAK,GAAe,MAC9EC,MAAK,oDAAqDD,ICoZtE8C,CAAoBd,EAAAQ,EAAAO,GAEdpB,KAAAC,IAAaoB,0BAAmChB,EAAAQ,EAAAO,oGDrajB/C,QAGpB,iBAANA,EAAK,IACC,iBAANA,EAAK,IACC,kBAANA,EAAK,IACC,kBAANA,EAAK,GAAgB,MAGpBC,MAAK,qCAAsCD","sources":["src/binding/binding.ts","src/binding/index.ts"],"sourcesContent":["import type { Tree, TreeFilterIndicesResult } from \"./index\"\n\nexport declare class Zadeh {\n  constructor()\n\n  filter(query: string, maxResult: number, usePathScoring: boolean, useExtensionBonus: boolean): Array<string>\n  filterIndices(query: string, maxResult: number, usePathScoring: boolean, useExtensionBonus: boolean): Array<number>\n\n  setArrayFiltererCandidates(candidateStrings: Array<string>): boolean\n\n  filterTree(query: string, maxResult: number, usePathScoring: boolean, useExtensionBonus: boolean): Array<Tree>\n\n  filterIndicesTree(\n    query: string,\n    maxResult: number,\n    usePathScoring: boolean,\n    useExtensionBonus: boolean\n  ): Array<TreeFilterIndicesResult>\n\n  // TODO use generic Tree type\n  setTreeFiltererCandidates(candidateTrees: Array<Tree>, dataKey: string, childrenKey: string): boolean\n}\n\nexport declare function score(\n  candidate: string,\n  query: string,\n  usePathScoring: boolean,\n  useExtensionBonus: boolean\n): number\n\nexport declare function match(str: string, query: string, pathSeparator: string): Array<number>\n\nexport declare function wrap(str: string, query: string, pathSeparator: string): string\n\n// Argument validators\n\nexport function validate_filter(...args: Parameters<Zadeh[\"filter\"]>) {\n  if (\n    !(\n      typeof args[0] === \"string\" &&\n      typeof args[1] === \"number\" &&\n      typeof args[2] === \"boolean\" &&\n      typeof args[3] === \"boolean\"\n    )\n  ) {\n    throw new Error(`Invalid arguments for filter: ${args}`)\n  }\n}\n\nexport function validate_setArrayFiltererCandidates(...args: Parameters<Zadeh[\"setArrayFiltererCandidates\"]>) {\n  if (!Array.isArray(args[0])) {\n    throw new Error(`Invalid arguments for setArrayFiltererCandidates: ${args}`)\n  }\n}\n\nexport function validate_filterTree(...args: Parameters<Zadeh[\"filterIndicesTree\"]>) {\n  if (\n    !(\n      typeof args[0] === \"string\" &&\n      typeof args[1] === \"number\" &&\n      typeof args[2] === \"boolean\" &&\n      typeof args[3] === \"boolean\"\n    )\n  ) {\n    throw new Error(`Invalid arguments for filterTree: ${args}`)\n  }\n}\n\nexport function validate_setTreeFiltererCandidates(...args: Parameters<Zadeh[\"setTreeFiltererCandidates\"]>) {\n  if (!(Array.isArray(args[0]) && typeof args[1] === \"string\" && typeof args[2] === \"string\")) {\n    throw new Error(`Invalid arguments for setTreeFiltererCandidates: ${args}`)\n  }\n}\n\nexport function validate_score(...args: Parameters<typeof score>) {\n  if (\n    !(\n      typeof args[0] === \"string\" &&\n      typeof args[1] === \"string\" &&\n      typeof args[2] === \"boolean\" &&\n      typeof args[3] === \"boolean\"\n    )\n  ) {\n    throw new Error(`Invalid arguments for score: ${args}`)\n  }\n}\n\nexport function validate_match(...args: Parameters<typeof match>) {\n  if (\n    !(\n      typeof args[0] === \"string\" &&\n      typeof args[1] === \"string\" &&\n      typeof args[2] === \"string\" &&\n      /** PathSeparator */ args[2].length === 1\n    )\n  ) {\n    throw new Error(`Invalid arguments for match: ${args}`)\n  }\n}\n\nexport function validate_wrap(...args: Parameters<typeof wrap>) {\n  if (\n    !(\n      typeof args[0] === \"string\" &&\n      typeof args[1] === \"string\" &&\n      typeof args[2] === \"string\" &&\n      /** PathSeparator */ args[2].length === 1\n    )\n  ) {\n    throw new Error(`Invalid arguments for wrap: ${args}`)\n  }\n}\n","// @ts-ignore\r\nimport nodeGypBuld from \"node-gyp-build\"\r\n\r\nimport * as Binding from \"./binding\"\r\nconst binding = nodeGypBuld(__dirname) as typeof Binding // __dirname relies on Parcel to bundle this file in the root of the package, so __dirname becomes correct\r\n\r\n/*\r\n ██████  ██████  ████████ ██  ██████  ███    ██ ███████\r\n██    ██ ██   ██    ██    ██ ██    ██ ████   ██ ██\r\n██    ██ ██████     ██    ██ ██    ██ ██ ██  ██ ███████\r\n██    ██ ██         ██    ██ ██    ██ ██  ██ ██      ██\r\n ██████  ██         ██    ██  ██████  ██   ████ ███████\r\n*/\r\n\r\ntype stringWithLength1 = string\r\n\r\nexport interface IOptions {\r\n  /** @default false */\r\n  allowErrors?: boolean\r\n\r\n  /** @default true */\r\n  usePathScoring?: boolean\r\n\r\n  /** @default false */\r\n  useExtensionBonus?: boolean\r\n\r\n  /**\r\n   * A path separator which is a string with length 1. Such as \"/\" or \"\". By default, this is chosen based on the\r\n   * operating system.\r\n   */\r\n  pathSeparator?: \"/\" | \"\\\\\" | stringWithLength1\r\n\r\n  // TODO not implemented?\r\n  // optCharRegEx?: RegExp\r\n\r\n  // TODO not implemented?\r\n  // wrap?: { tagOpen?: string; tagClass?: string; tagClose?: string }\r\n\r\n  /** @deprecated: there is no major benefit by precomputing something just for the query. */\r\n  preparedQuery?: never\r\n}\r\n\r\nexport type StringArrayFilterOptions = IOptions & {\r\n  /** The maximum numbers of results to return */\r\n  maxResults?: number\r\n\r\n  // TODO not implemented\r\n  // maxInners?: number\r\n}\r\n\r\nexport type ObjectArrayFilterOptions = StringArrayFilterOptions\r\nexport type TreeFilterOptions = StringArrayFilterOptions\r\n\r\n/** @deprecated The key to use when candidates is an object Deprecated option. */\r\nexport type DeprecatedFilterOptions<T extends StringOrObjectArray> = IOptions & {\r\n  key?: T extends string ? never : keyof T\r\n}\r\n\r\nconst defaultPathSeparator = process.platform === \"win32\" ? \"\\\\\" : \"/\"\r\n\r\nfunction parseOptions(options: IOptions) {\r\n  // options.allowErrors ? = false\r\n  if (options.usePathScoring === undefined) {\r\n    options.usePathScoring = true\r\n  }\r\n  // options.useExtensionBonus ? = false\r\n  if (options.pathSeparator === undefined) {\r\n    options.pathSeparator = defaultPathSeparator\r\n  }\r\n}\r\n\r\nfunction parseFilterOptions(filterOptions: StringArrayFilterOptions | ObjectArrayFilterOptions | TreeFilterOptions) {\r\n  // options.optCharRegEx ? = null\r\n  // options.wrap ? = null\r\n  if (filterOptions.maxResults === undefined) {\r\n    filterOptions.maxResults = 0\r\n  }\r\n  // parse common options\r\n  parseOptions(filterOptions)\r\n}\r\n\r\n/*\r\n █████  ██████  ██████   █████  ██    ██     ███████ ██ ██   ████████ ███████ ██████\r\n██   ██ ██   ██ ██   ██ ██   ██  ██  ██      ██      ██ ██      ██    ██      ██   ██\r\n███████ ██████  ██████  ███████   ████       █████   ██ ██      ██    █████   ██████\r\n██   ██ ██   ██ ██   ██ ██   ██    ██        ██      ██ ██      ██    ██      ██   ██\r\n██   ██ ██   ██ ██   ██ ██   ██    ██        ██      ██ ███████ ██    ███████ ██   ██\r\n*/\r\n\r\n/** An object that stores its `dataKey` in `DataKey` */\r\nexport type ObjectWithKey<DataKey extends string | number = string | number> = {\r\n  [dk in DataKey]: string\r\n} &\r\n  Record<string | number, string>\r\n\r\nexport type StringOrObjectArray = string | ObjectWithKey\r\n\r\n/** StringArrayFilterer is a class that performs filtering on an array of strings */\r\nexport class StringArrayFilterer {\r\n  obj = new binding.Zadeh()\r\n  // typescript cannot detect that candidates is definitely assigned\r\n  // @ts-ignore\r\n  private candidates: Array<string>\r\n\r\n  /**\r\n   * Make a `StringArrayFilterer` for the candidates that are going to be filtered.\r\n   *\r\n   * @param candidates An array of strings.\r\n   */\r\n  constructor(candidates?: Array<string>) {\r\n    if (candidates !== undefined) {\r\n      this.setCandidates(candidates)\r\n    } else {\r\n      this.candidates = []\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The method to set the candidates that are going to be filtered\r\n   *\r\n   * @param candidates An array of strings.\r\n   */\r\n  setCandidates(candidates: Array<string>) {\r\n    this.candidates = candidates\r\n\r\n    Binding.validate_setArrayFiltererCandidates(candidates)\r\n    return this.obj.setArrayFiltererCandidates(candidates)\r\n  }\r\n\r\n  /**\r\n   * Filter the already set array of strings\r\n   *\r\n   * @param query A string query to match each candidate against.\r\n   * @param options Options\r\n   * @returns Returns an array of candidates sorted by best match against the query.\r\n   */\r\n  filter(query: string, options: StringArrayFilterOptions = {}): Array<string> {\r\n    return this.filterIndices(query, options).map((ind: number) => this.candidates[ind])\r\n  }\r\n\r\n  /**\r\n   * Filter the already set array of strings and get the indices of the chosen candidate\r\n   *\r\n   * @param query A string query to match each candidate against.\r\n   * @param options Options\r\n   * @returns Returns an array of numbers indicating the index of the chosen candidate sorted by best match against the query.\r\n   */\r\n  filterIndices(query: string, options: StringArrayFilterOptions = {}): Array<number> {\r\n    parseFilterOptions(options)\r\n\r\n    const maxResult = options.maxResults as number /* numberified by parseFilterOptions */\r\n    const usePathScoring = Boolean(options.usePathScoring)\r\n    const useExtensionBonus = Boolean(options.useExtensionBonus)\r\n\r\n    Binding.validate_filter(query, maxResult, usePathScoring, useExtensionBonus)\r\n    // NOTE calling obj.filter is slower than (obj.filterIndices then map) due to the interop overhead\r\n    return this.obj.filterIndices(query, maxResult, usePathScoring, useExtensionBonus)\r\n  }\r\n}\r\n\r\n/**\r\n * ObjectArrayFilterer is a class that performs filtering on an array of objects based on a string stored in the given\r\n * `dataKey` for each object\r\n */\r\nexport class ObjectArrayFilterer<DataKey extends string | number = string> {\r\n  obj = new binding.Zadeh()\r\n  // typescript cannot detect that candidates is definitely assigned\r\n  // @ts-ignore\r\n  private candidates: ObjectWithKey<DataKey>[]\r\n\r\n  /**\r\n   * Make a `ObjectArrayFilterer` for the candidates that are going to be filtered.\r\n   *\r\n   * @param candidates An array of objects.\r\n   * @param dataKey The key which is indexed for each object, and filtering is done based on the resulting string\r\n   */\r\n  constructor(candidates?: ObjectWithKey<DataKey>[], dataKey?: DataKey) {\r\n    if (candidates !== undefined && dataKey !== undefined) {\r\n      this.setCandidates(candidates, dataKey)\r\n    } else {\r\n      this.candidates = []\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Allows to set the candidates (if changed or not set in the constructor).\r\n   *\r\n   * @param candidates An array of objects.\r\n   * @param dataKey The key which is indexed for each object, and filtering is done based on the resulting string\r\n   */\r\n  setCandidates(candidates: ObjectWithKey<DataKey>[], dataKey: DataKey) {\r\n    this.candidates = candidates\r\n    const candidatesKeys = candidates.map((item) => item[dataKey])\r\n\r\n    Binding.validate_setArrayFiltererCandidates(candidatesKeys)\r\n    this.obj.setArrayFiltererCandidates(candidatesKeys)\r\n  }\r\n\r\n  /**\r\n   * Filter the already set objects\r\n   *\r\n   * @param query A string query to match the dataKey of each candidate against.\r\n   * @param options Options\r\n   * @returns Returns an array of objects sorted by best match against the query.\r\n   */\r\n  filter(query: string, options: ObjectArrayFilterOptions = {}): ObjectWithKey<DataKey>[] {\r\n    return this.filterIndices(query, options).map((ind: number) => this.candidates[ind])\r\n  }\r\n\r\n  /**\r\n   * Filter the already set array of objects and get the indices of the chosen candidate\r\n   *\r\n   * @param query A string query to match the dataKey of each candidate against.\r\n   * @param options Options\r\n   * @returns Returns an array of numbers indicating the index of the chosen candidate sorted by best match against the query.\r\n   */\r\n  filterIndices(query: string, options: StringArrayFilterOptions = {}): Array<number> {\r\n    parseFilterOptions(options)\r\n\r\n    const maxResult = options.maxResults as number /* numberified by parseFilterOptions */\r\n    const usePathScoring = Boolean(options.usePathScoring)\r\n    const useExtensionBonus = Boolean(options.useExtensionBonus)\r\n\r\n    Binding.validate_filter(query, maxResult, usePathScoring, useExtensionBonus)\r\n    if (query.length === 0) {\r\n      // optimization for query === \"\"\r\n      return []\r\n    }\r\n    // NOTE calling obj.filter is slower than (obj.filterIndices then map) due to the interop overhead\r\n    return this.obj.filterIndices(query, maxResult, usePathScoring, useExtensionBonus)\r\n  }\r\n}\r\n\r\n/** @deprecated */\r\ntype DeprecatedFilterReturn<T> = T extends string ? string[] : ObjectWithKey[]\r\n\r\nlet warnStringArrayFilterer = true\r\nlet warnfilterObjectArrayFilterer = true\r\n\r\n/**\r\n * @deprecated Use `StringArrayFilterer` or `ObjectArrayFilterer` instead Sort and filter the given candidates by\r\n *   matching them against the given query.\r\n * @param candidates An array of strings or objects.\r\n * @param query A string query to match each candidate against.\r\n * @param options Options\r\n * @returns Returns an array of candidates sorted by best match against the query.\r\n */\r\nexport function filter<T extends StringOrObjectArray>(\r\n  candidates: T[],\r\n  query: string,\r\n  options: DeprecatedFilterOptions<T> = {}\r\n): DeprecatedFilterReturn<T> {\r\n  if (!candidates || !query) {\r\n    console.warn(`Zadeh: bad input to filter candidates: ${candidates}, query: ${query}`)\r\n    // @ts-ignore: bad input guard which doesn't meet the types\r\n    return []\r\n  }\r\n\r\n  if (typeof candidates[0] === \"object\" && options.key) {\r\n    // an object (options) containing the key\r\n    if (warnfilterObjectArrayFilterer) {\r\n      console.warn(`Zadeh: deprecated function. Use 'ObjectArrayFilterer' instead`)\r\n      warnfilterObjectArrayFilterer = false\r\n    }\r\n    const dataKey = options.key\r\n    const objectArrayFilterer = new ObjectArrayFilterer(\r\n      candidates as ObjectWithKey<T extends string ? never : keyof T>[],\r\n      dataKey\r\n    )\r\n    return objectArrayFilterer.filter(query, options) as DeprecatedFilterReturn<T>\r\n  } else if (typeof candidates[0] === \"string\") {\r\n    // string array\r\n    if (warnStringArrayFilterer) {\r\n      console.warn(`Zadeh: deprecated function. Use 'StringArrayFilterer' instead`)\r\n      warnStringArrayFilterer = false\r\n    }\r\n    const stringArrayFilterer = new StringArrayFilterer(candidates as string[])\r\n    return stringArrayFilterer.filter(query, options) as DeprecatedFilterReturn<T>\r\n  } else {\r\n    throw new Error(`Zadeh: bad input to filter candidates: ${candidates}, query: ${query}, options: ${options}`)\r\n  }\r\n}\r\n\r\n/*\r\n████████ ██████  ███████ ███████     ███████ ██ ██   ████████ ███████ ██████\r\n   ██    ██   ██ ██      ██          ██      ██ ██      ██    ██      ██   ██\r\n   ██    ██████  █████   █████       █████   ██ ██      ██    █████   ██████\r\n   ██    ██   ██ ██      ██          ██      ██ ██      ██    ██      ██   ██\r\n   ██    ██   ██ ███████ ███████     ██      ██ ███████ ██    ███████ ██   ██\r\n*/\r\n\r\n// The object (an element of the array) returned from filtering trees. It has the address of the object in the tree using `index` and `parent_indices`.\r\nexport interface TreeFilterIndicesResult {\r\n  data: string\r\n  index: number\r\n  parent_indices: Array<number>\r\n}\r\n\r\n/**\r\n * TreeFilterer is a filters the given query in the nodes of the given array of trees, and returns an array of filtered\r\n * tree. A tree object is an object in which each entry stores the data in its dataKey and it has (may have) some\r\n * children (with a similar structure) in its childrenKey\r\n */\r\nexport class TreeFilterer<DataKey extends string = string, ChildrenKey extends string = string> {\r\n  obj = new binding.Zadeh()\r\n  // typescript cannot detect that candidates is definitely assigned\r\n  // @ts-ignore\r\n  private candidates: Tree<DataKey, ChildrenKey>[]\r\n\r\n  /**\r\n   * The method to set an array of trees that are going to be filtered\r\n   *\r\n   * @param candidates An array of tree objects.\r\n   * @param dataKey The key of the object (and its children) which holds the data (defaults to `\"data\"`)\r\n   * @param childrenKey The key of the object (and its children) which hold the children (defaults to `\"children\"`)\r\n   */\r\n  constructor(\r\n    candidates?: Tree<DataKey, ChildrenKey>[],\r\n    dataKey: DataKey = \"data\" as DataKey,\r\n    childrenKey: ChildrenKey = \"children\" as ChildrenKey\r\n  ) {\r\n    if (candidates) {\r\n      this.setCandidates(candidates, dataKey, childrenKey)\r\n    } else {\r\n      this.candidates = []\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The method to set an array of trees that are going to be filtered\r\n   *\r\n   * @param candidates An array of tree objects.\r\n   * @param dataKey The key of the object (and its children) which holds the data (defaults to `\"data\"`)\r\n   * @param childrenKey The key of the object (and its children) which hold the children (defaults to `\"children\"`)\r\n   */\r\n  setCandidates(\r\n    candidates: Tree<DataKey, ChildrenKey>[],\r\n    dataKey: DataKey = \"data\" as DataKey,\r\n    childrenKey: ChildrenKey = \"children\" as ChildrenKey\r\n  ) {\r\n    this.candidates = candidates\r\n\r\n    Binding.validate_setTreeFiltererCandidates(candidates, dataKey, childrenKey)\r\n    return this.obj.setTreeFiltererCandidates(candidates, dataKey, childrenKey)\r\n  }\r\n\r\n  /**\r\n   * Filter the already set trees\r\n   *\r\n   * @param query A string query to match the dataKey of each candidate against.\r\n   * @param options Options\r\n   * @returns {Tree[]} An array of filtered trees. In a tree, the filtered data is at the last level (if it has\r\n   *   children, they are not included in the filered tree)\r\n   */\r\n  filter(query: string, options: TreeFilterOptions = {}): Tree<DataKey, ChildrenKey>[] {\r\n    parseFilterOptions(options)\r\n\r\n    const maxResult = options.maxResults as number /* numberified by parseFilterOptions */\r\n    const usePathScoring = Boolean(options.usePathScoring)\r\n    const useExtensionBonus = Boolean(options.useExtensionBonus)\r\n\r\n    Binding.validate_filterTree(query, maxResult, usePathScoring, useExtensionBonus)\r\n    if (query.length === 0) {\r\n      // optimization for query === \"\"\r\n      return []\r\n    }\r\n    return this.obj.filterTree(query, maxResult, usePathScoring, useExtensionBonus)\r\n  }\r\n\r\n  /**\r\n   * The method to perform the filtering on the already set candidates\r\n   *\r\n   * @param query A string query to match the dataKey of each candidate against.\r\n   * @param options Options\r\n   * @returns {TreeFilterIndicesResult[]} An array candidate objects in form of `{data, index, parentIndices}` sorted by\r\n   *   best match against the query. Each objects has the address of the object in the tree using `index` and `parent_indices`\r\n   */\r\n  filterIndices(query: string, options: TreeFilterOptions = {}): TreeFilterIndicesResult[] {\r\n    parseOptions(options)\r\n    if (query.length === 0) {\r\n      // optimization for query === \"\"\r\n      return []\r\n    }\r\n    return this.obj.filterIndicesTree(\r\n      query,\r\n      options.maxResults ?? 0,\r\n      Boolean(options.usePathScoring),\r\n      Boolean(options.useExtensionBonus)\r\n    )\r\n  }\r\n}\r\n\r\nexport type TreeDataProperty<DataKey extends string> = {\r\n  [dk in DataKey]: string\r\n}\r\nexport type TreeChildrenProperty<ChildrenKey extends string> = {\r\n  [ck in ChildrenKey]?: string[] // children is either an array or not provided\r\n}\r\n/**\r\n * A {Tree} object is an object in which each entry stores the data in its dataKey and it has (may have) some children\r\n * (with a similar structure) in its childrenKey\r\n */\r\nexport type Tree<DataKey extends string = string, ChildrenKey extends string = string> = TreeDataProperty<DataKey> &\r\n  TreeChildrenProperty<ChildrenKey>\r\n\r\n/*\r\n███████  ██████  ██████  ██████  ███████\r\n██      ██      ██    ██ ██   ██ ██\r\n███████ ██      ██    ██ ██████  █████\r\n     ██ ██      ██    ██ ██   ██ ██\r\n███████  ██████  ██████  ██   ██ ███████\r\n*/\r\n\r\n/**\r\n * Score the given string against the given query.\r\n *\r\n * @param candidate The string the score.\r\n * @param query The query to score the string against.\r\n * @param options Options\r\n */\r\nexport function score(candidate: string, query: string, options: IOptions = {}): number {\r\n  if (!candidate || !query) {\r\n    console.warn(`Zadeh: bad input to score candidates: ${candidate}, query: ${query}`)\r\n    return 0\r\n  }\r\n  parseOptions(options)\r\n\r\n  const usePathScoring = Boolean(options.usePathScoring)\r\n  const useExtensionBonus = Boolean(options.useExtensionBonus)\r\n\r\n  Binding.validate_score(candidate, query, usePathScoring, useExtensionBonus)\r\n  return binding.score(candidate, query, usePathScoring, useExtensionBonus)\r\n}\r\n\r\n/*\r\n███    ███  █████  ████████  ██████ ██   ██\r\n████  ████ ██   ██    ██    ██      ██   ██\r\n██ ████ ██ ███████    ██    ██      ███████\r\n██  ██  ██ ██   ██    ██    ██      ██   ██\r\n██      ██ ██   ██    ██     ██████ ██   ██\r\n*/\r\n\r\n/** Gives an array of indices at which the query matches the given string */\r\nexport function match(str: string, query: string, options: IOptions = {}): number[] {\r\n  if (!str || !query) {\r\n    console.warn(`Zadeh: bad input to match str: ${str}, query: ${query}`)\r\n    return []\r\n  }\r\n  if (str === query) {\r\n    return Array.from(Array(str.length).keys())\r\n  }\r\n  parseOptions(options)\r\n\r\n  const pathSeparator = options.pathSeparator as string /* stringified by parseOption */\r\n\r\n  Binding.validate_match(str, query, pathSeparator)\r\n  return binding.match(str, query, pathSeparator)\r\n}\r\n\r\n/*\r\n██     ██ ██████   █████  ██████\r\n██     ██ ██   ██ ██   ██ ██   ██\r\n██  █  ██ ██████  ███████ ██████\r\n██ ███ ██ ██   ██ ██   ██ ██\r\n ███ ███  ██   ██ ██   ██ ██\r\n*/\r\n\r\n/** Gives an HTML/Markdown string that highlights the range for which the match happens */\r\nexport function wrap(str: string, query: string, options: IOptions = {}): string {\r\n  if (!str || !query) {\r\n    console.warn(`Zadeh: bad input to wrap str: ${str}, query: ${query}`)\r\n    // @ts-ignore\r\n    return []\r\n  }\r\n  parseOptions(options)\r\n\r\n  const pathSeparator = options.pathSeparator as string /* stringified by parseOption */\r\n\r\n  Binding.validate_wrap(str, query, pathSeparator)\r\n  return binding.wrap(str, query, pathSeparator)\r\n}\r\n\r\n/*\r\n ██████  ████████ ██   ██ ███████ ██████\r\n██    ██    ██    ██   ██ ██      ██   ██\r\n██    ██    ██    ███████ █████   ██████\r\n██    ██    ██    ██   ██ ██      ██   ██\r\n ██████     ██    ██   ██ ███████ ██   ██\r\n*/\r\n\r\n/** @deprecated: there is no major benefit by precomputing something just for the query. */\r\n/* eslint-disable @typescript-eslint/no-unused-vars */\r\n// @ts-ignore\r\nexport function prepareQuery(query: string, options: IOptions = {}): {} {\r\n  console.warn(\r\n    \"Zadeh: prepareQuery is deprecated. There is no major benefit by precomputing something just for the query. \"\r\n  )\r\n  // This is no - op since there is no major benefit by precomputing something\r\n  // just for the query.\r\n  return {}\r\n}\r\n"],"names":["$312c904d843f9c63$export$aab5ef804e443688","args","Error","$312c904d843f9c63$export$2c266012a0e2a140","Array","isArray","$3dea680f0a80efae$var$parseOptions","options","undefined","usePathScoring","pathSeparator","$3dea680f0a80efae$var$defaultPathSeparator","$3dea680f0a80efae$var$parseFilterOptions","filterOptions","maxResults","candidates3","query","$3dea680f0a80efae$var$warnfilterObjectArrayFilterer","filter","$3dea680f0a80efae$var$warnStringArrayFilterer","warn","$3dea680f0a80efae$export$6878bef6a8c9c564","length","$3dea680f0a80efae$var$binding","$kuNfY$nodegypbuild","__dirname","process","platform","this","obj","Zadeh","setCandidates","candidates1","candidates","filterIndices","map","ind","maxResult","useExtensionBonus","dataKey1","candidates2","dataKey","candidatesKeys","setArrayFiltererCandidates","[object Object]","dataKey2","childrenKey1","$312c904d843f9c63$export$83a2fa62866aca7b","childrenKey","setTreeFiltererCandidates"],"version":3,"file":"index.js.map","sourceRoot":"/"}